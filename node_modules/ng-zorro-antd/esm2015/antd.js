import { ApplicationRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Host, HostBinding, HostListener, INJECTOR, Inject, Injectable, InjectionToken, Injector, Input, IterableDiffers, NgModule, NgZone, Optional, Output, Pipe, Renderer2, Self, SimpleChange, SkipSelf, TemplateRef, Type, ViewChild, ViewChildren, ViewContainerRef, defineInjectable, forwardRef, inject } from '@angular/core';
import { CommonModule, DOCUMENT, DatePipe } from '@angular/common';
import { __decorate, __metadata } from 'tslib';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { animate, state, style, transition, trigger } from '@angular/animations';
import { BehaviorSubject, Observable, Subject, combineLatest, defer, fromEvent, merge, of } from 'rxjs';
import { auditTime, debounceTime, delay, distinct, distinctUntilChanged, filter, map, mapTo, pluck, startWith, switchMap, take, takeUntil, tap, throttleTime } from 'rxjs/operators';
import { CdkConnectedOverlay, CdkOverlayOrigin, ConnectionPositionPair, Overlay, OverlayConfig, OverlayModule, OverlayPositionBuilder, OverlayRef } from '@angular/cdk/overlay';
import { FormControl, FormsModule, NG_VALUE_ACCESSOR, NgControl, NgModel } from '@angular/forms';
import { BACKSPACE, DOWN_ARROW, ENTER, ESCAPE, LEFT_ARROW, RIGHT_ARROW, TAB, UP_ARROW } from '@angular/cdk/keycodes';
import { ComponentPortal, TemplatePortal } from '@angular/cdk/portal';
import { ObserversModule } from '@angular/cdk/observers';
import parse from 'date-fns/parse';
import setMonth from 'date-fns/set_month';
import addDays from 'date-fns/add_days';
import differenceInCalendarDays from 'date-fns/difference_in_calendar_days';
import differenceInCalendarMonths from 'date-fns/difference_in_calendar_months';
import differenceInCalendarWeeks from 'date-fns/difference_in_calendar_weeks';
import endOfMonth from 'date-fns/end_of_month';
import isSameDay from 'date-fns/is_same_day';
import isSameMonth from 'date-fns/is_same_month';
import isSameYear from 'date-fns/is_same_year';
import isThisMonth from 'date-fns/is_this_month';
import isThisYear from 'date-fns/is_this_year';
import setYear from 'date-fns/set_year';
import startOfMonth from 'date-fns/start_of_month';
import startOfWeek from 'date-fns/start_of_week';
import startOfYear from 'date-fns/start_of_year';
import addMonths from 'date-fns/add_months';
import addYears from 'date-fns/add_years';
import setDay from 'date-fns/set_day';
import { Directionality } from '@angular/cdk/bidi';
import { HttpClient, HttpEventType, HttpHeaders, HttpRequest, HttpResponse } from '@angular/common/http';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// tslint:disable:no-any typedef no-invalid-this
const availablePrefixs = ['moz', 'ms', 'webkit'];
/**
 * @return {?}
 */
function requestAnimationFramePolyfill() {
    let /** @type {?} */ lastTime = 0;
    return function (callback) {
        const /** @type {?} */ currTime = new Date().getTime();
        const /** @type {?} */ timeToCall = Math.max(0, 16 - (currTime - lastTime));
        const /** @type {?} */ id = window.setTimeout(() => { callback(currTime + timeToCall); }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };
}
/**
 * @return {?}
 */
function getRequestAnimationFrame() {
    if (typeof window === 'undefined') {
        return () => null;
    }
    if (window.requestAnimationFrame) {
        // https://github.com/vuejs/vue/issues/4465
        return window.requestAnimationFrame.bind(window);
    }
    const /** @type {?} */ prefix = availablePrefixs.filter(key => `${key}RequestAnimationFrame` in window)[0];
    return prefix
        ? window[`${prefix}RequestAnimationFrame`]
        : requestAnimationFramePolyfill();
}
/**
 * @param {?} id
 * @return {?}
 */
function cancelRequestAnimationFrame(id) {
    if (typeof window === 'undefined') {
        return null;
    }
    if (window.cancelAnimationFrame) {
        return window.cancelAnimationFrame(id);
    }
    const /** @type {?} */ prefix = availablePrefixs.filter(key => `${key}CancelAnimationFrame` in window || `${key}CancelRequestAnimationFrame` in window)[0];
    return prefix ?
        ((/** @type {?} */ (window))[`${prefix}CancelAnimationFrame`] ||
            (/** @type {?} */ (window))[`${prefix}CancelRequestAnimationFrame`]).call(this, id) : clearTimeout(id);
}
const reqAnimFrame = getRequestAnimationFrame();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} t
 * @param {?} b
 * @param {?} c
 * @param {?} d
 * @return {?}
 */
function easeInOutCubic(t, b, c, d) {
    const /** @type {?} */ cc = c - b;
    let /** @type {?} */ tt = t / (d / 2);
    if (tt < 1) {
        return cc / 2 * tt * tt * tt + b;
    }
    else {
        return cc / 2 * ((tt -= 2) * tt * tt + 2) + b;
    }
}
class NzScrollService {
    /**
     * @param {?} doc
     */
    constructor(doc) {
        this.doc = doc;
    }
    /**
     * 设置 `el` 滚动条位置
     * @param {?} el
     * @param {?=} topValue
     * @return {?}
     */
    setScrollTop(el, topValue = 0) {
        if (el === window) {
            this.doc.body.scrollTop = topValue;
            this.doc.documentElement.scrollTop = topValue;
        }
        else {
            (/** @type {?} */ (el)).scrollTop = topValue;
        }
    }
    /**
     * 获取 `el` 相对于视窗距离
     * @param {?} el
     * @return {?}
     */
    getOffset(el) {
        const /** @type {?} */ ret = {
            top: 0,
            left: 0
        };
        if (!el || !el.getClientRects().length)
            return ret;
        const /** @type {?} */ rect = el.getBoundingClientRect();
        if (rect.width || rect.height) {
            const /** @type {?} */ doc = el.ownerDocument.documentElement;
            ret.top = rect.top - doc.clientTop;
            ret.left = rect.left - doc.clientLeft;
        }
        else {
            ret.top = rect.top;
            ret.left = rect.left;
        }
        return ret;
    }
    /**
     * 获取 `el` 滚动条位置
     * @param {?=} el
     * @param {?=} top
     * @return {?}
     */
    getScroll(el, top = true) {
        const /** @type {?} */ target = el ? el : window;
        const /** @type {?} */ prop = top ? 'pageYOffset' : 'pageXOffset';
        const /** @type {?} */ method = top ? 'scrollTop' : 'scrollLeft';
        const /** @type {?} */ isWindow = target === window;
        let /** @type {?} */ ret = isWindow ? target[prop] : target[method];
        if (isWindow && typeof ret !== 'number') {
            ret = this.doc.documentElement[method];
        }
        return ret;
    }
    /**
     * 使用动画形式将 `el` 滚动至某位置
     *
     * @param {?} containerEl 容器，默认 `window`
     * @param {?=} targetTopValue 滚动至目标 `top` 值，默认：0，相当于顶部
     * @param {?=} easing 动作算法，默认：`easeInOutCubic`
     * @param {?=} callback 动画结束后回调
     * @return {?}
     */
    scrollTo(containerEl, targetTopValue = 0, easing, callback) {
        const /** @type {?} */ target = containerEl ? containerEl : window;
        const /** @type {?} */ scrollTop = this.getScroll(target);
        const /** @type {?} */ startTime = Date.now();
        const /** @type {?} */ frameFunc = () => {
            const /** @type {?} */ timestamp = Date.now();
            const /** @type {?} */ time = timestamp - startTime;
            this.setScrollTop(target, (easing || easeInOutCubic)(time, scrollTop, targetTopValue, 450));
            if (time < 450) {
                reqAnimFrame(frameFunc);
            }
            else {
                if (callback)
                    callback();
            }
        };
        reqAnimFrame(frameFunc);
    }
}
NzScrollService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NzScrollService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
/**
 * @param {?} doc
 * @param {?} scrollService
 * @return {?}
 */
function SCROLL_SERVICE_PROVIDER_FACTORY(doc, scrollService) {
    return scrollService || new NzScrollService(doc);
}
const SCROLL_SERVICE_PROVIDER = {
    provide: NzScrollService,
    useFactory: SCROLL_SERVICE_PROVIDER_FACTORY,
    deps: [DOCUMENT, [new Optional(), new SkipSelf(), NzScrollService]]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function isNotNil(value) {
    return (typeof (value) !== 'undefined') && value !== null;
}
/**
 * 校验对象是否相等
 * @param {?} objA
 * @param {?} objB
 * @return {?}
 */
function shallowEqual(objA, objB) {
    if (objA === objB)
        return true;
    if (typeof objA !== 'object' || !objA || typeof objB !== 'object' || !objB)
        return false;
    const /** @type {?} */ keysA = Object.keys(objA);
    const /** @type {?} */ keysB = Object.keys(objB);
    if (keysA.length !== keysB.length)
        return false;
    const /** @type {?} */ bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
    // tslint:disable-next-line:prefer-for-of
    for (let /** @type {?} */ idx = 0; idx < keysA.length; idx++) {
        const /** @type {?} */ key = keysA[idx];
        if (!bHasOwnProperty(key))
            return false;
        if (objA[key] !== objB[key])
            return false;
    }
    return true;
}
/**
 * @param {?} value
 * @return {?}
 */
function isInteger(value) {
    return typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value;
}
/**
 * @param {?} element
 * @return {?}
 */
function isEmpty(element) {
    const /** @type {?} */ nodes = element.childNodes;
    for (let /** @type {?} */ i = 0; i < nodes.length; i++) {
        const /** @type {?} */ node = nodes.item(i);
        if ((node.nodeType === 1) && ((/** @type {?} */ (node)).outerHTML.toString().trim().length !== 0)) {
            return false;
        }
        else if ((node.nodeType === 3) && ((node.textContent.toString().trim().length !== 0))) {
            return false;
        }
    }
    return true;
}
/**
 * @param {?} value
 * @return {?}
 */
function isNonEmptyString(value) {
    // tslint:disable-line:no-any
    return typeof value === 'string' && value !== '';
}
/**
 * @param {?} value
 * @return {?}
 */
function isTemplateRef(value) {
    // tslint:disable-line:no-any
    return value instanceof TemplateRef;
}
/**
 * @param {?} value
 * @return {?}
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} value
 * @return {?}
 */
function toBoolean(value) {
    return coerceBooleanProperty(value);
}
/**
 * @template D
 * @param {?} value
 * @param {?} fallback
 * @return {?}
 */
function toNumber(value, fallback) {
    return coerceNumberProperty(value, fallback);
}
/**
 * @template T
 * @param {?} prop
 * @param {...?} args
 * @return {?}
 */
function valueFunctionProp(prop, ...args) {
    // tslint:disable-line: no-any
    return typeof prop === 'function' ? prop(...args) : prop;
}
/**
 * Input decorator that handle a prop to do get/set automatically with toBoolean
 *
 * Why not using \@InputBoolean alone without \@Input? AOT needs \@Input to be visible
 *
 * \@howToUse
 * ```
 * \@Input() \@InputBoolean() visible: boolean = false;
 *
 * // Act as below:
 * // \@Input()
 * // get visible() { return this.__visibile; }
 * // set visible(value) { this.__visible = value; }
 * // __visible = false;
 * ```
 * @return {?}
 */
function InputBoolean() {
    // tslint:disable-line:no-any
    return function InputBooleanPropDecorator(target, name) {
        // Add our own private prop
        const /** @type {?} */ privatePropName = `$$__${name}`;
        if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
            console.warn(`The prop "${privatePropName}" is already exist, it will be overrided by InputBoolean decorator.`);
        }
        Object.defineProperty(target, privatePropName, {
            configurable: true,
            writable: true
        });
        Object.defineProperty(target, name, {
            /**
             * @return {?}
             */
            get() {
                return this[privatePropName]; // tslint:disable-line:no-invalid-this
            },
            /**
             * @param {?} value
             * @return {?}
             */
            set(value) {
                this[privatePropName] = toBoolean(value); // tslint:disable-line:no-invalid-this
            }
        });
        // // Do rest things for input decorator
        // const inputDecorator = Input();
        // inputDecorator(target, name);
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} fn
 * @return {?}
 */
function throttleByAnimationFrame(fn) {
    let /** @type {?} */ requestId;
    const /** @type {?} */ later = (args) => () => {
        requestId = null;
        fn(...args);
    };
    const /** @type {?} */ throttled = (...args) => {
        if (requestId == null) {
            requestId = reqAnimFrame(later(args));
        }
    };
    // tslint:disable-next-line:no-non-null-assertion
    (/** @type {?} */ (throttled)).cancel = () => cancelRequestAnimationFrame(/** @type {?} */ ((requestId)));
    return throttled;
}
/**
 * @return {?}
 */
function throttleByAnimationFrameDecorator() {
    return function (target, key, descriptor) {
        const /** @type {?} */ fn = descriptor.value;
        let /** @type {?} */ definingProperty = false;
        return {
            configurable: true,
            /**
             * @return {?}
             */
            get() {
                if (definingProperty || this === target.prototype || this.hasOwnProperty(key)) {
                    return fn;
                }
                const /** @type {?} */ boundFn = throttleByAnimationFrame(fn.bind(this));
                definingProperty = true;
                Object.defineProperty(this, key, {
                    value: boundFn,
                    configurable: true,
                    writable: true,
                });
                definingProperty = false;
                return boundFn;
            },
        };
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzAffixComponent {
    /**
     * @param {?} scrollSrv
     * @param {?} _el
     * @param {?} cd
     */
    constructor(scrollSrv, _el, cd) {
        this.scrollSrv = scrollSrv;
        this._el = _el;
        this.cd = cd;
        this.events = [
            'resize',
            'scroll',
            'touchstart',
            'touchmove',
            'touchend',
            'pageshow',
            'load'
        ];
        this._target = window;
        this.nzChange = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTarget(value) {
        this.clearEventListeners();
        this._target = value || window;
        this.setTargetEventListeners();
        this.updatePosition({});
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzOffsetTop(value) {
        if (typeof value === 'undefined') {
            return;
        }
        this._offsetTop = toNumber(value, null);
    }
    /**
     * @return {?}
     */
    get nzOffsetTop() {
        return this._offsetTop;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzOffsetBottom(value) {
        if (typeof value === 'undefined') {
            return;
        }
        this._offsetBottom = toNumber(value, null);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.timeout = setTimeout(() => {
            this.setTargetEventListeners();
            this.updatePosition({});
        });
    }
    /**
     * @return {?}
     */
    setTargetEventListeners() {
        this.clearEventListeners();
        this.events.forEach((eventName) => {
            this._target.addEventListener(eventName, this.updatePosition, false);
        });
    }
    /**
     * @return {?}
     */
    clearEventListeners() {
        this.events.forEach(eventName => {
            this._target.removeEventListener(eventName, this.updatePosition, false);
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.clearEventListeners();
        clearTimeout(this.timeout);
        (/** @type {?} */ (this.updatePosition)).cancel();
    }
    /**
     * @param {?} target
     * @return {?}
     */
    getTargetRect(target) {
        return target !== window ?
            (/** @type {?} */ (target)).getBoundingClientRect() : /** @type {?} */ ({ top: 0, left: 0, bottom: 0 });
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    getOffset(element, target) {
        const /** @type {?} */ elemRect = element.getBoundingClientRect();
        const /** @type {?} */ targetRect = this.getTargetRect(target);
        const /** @type {?} */ scrollTop = this.scrollSrv.getScroll(target, true);
        const /** @type {?} */ scrollLeft = this.scrollSrv.getScroll(target, false);
        const /** @type {?} */ docElem = window.document.body;
        const /** @type {?} */ clientTop = docElem.clientTop || 0;
        const /** @type {?} */ clientLeft = docElem.clientLeft || 0;
        return {
            top: elemRect.top - targetRect.top + scrollTop - clientTop,
            left: elemRect.left - targetRect.left + scrollLeft - clientLeft,
            width: elemRect.width,
            height: elemRect.height
        };
    }
    /**
     * @param {?} affixStyle
     * @return {?}
     */
    genStyle(affixStyle) {
        if (affixStyle == null) {
            return '';
        }
        return Object.keys(affixStyle).map(key => {
            const /** @type {?} */ val = affixStyle[key];
            return `${key}:${typeof val === 'string' ? val : val + 'px'}`;
        }).join(';');
    }
    /**
     * @param {?} e
     * @param {?} affixStyle
     * @return {?}
     */
    setAffixStyle(e, affixStyle) {
        const /** @type {?} */ originalAffixStyle = this.affixStyle;
        const /** @type {?} */ isWindow = this._target === window;
        if (e.type === 'scroll' && originalAffixStyle && affixStyle && isWindow) {
            return;
        }
        if (shallowEqual(originalAffixStyle, affixStyle)) {
            return;
        }
        const /** @type {?} */ fixed = !!affixStyle;
        const /** @type {?} */ wrapEl = /** @type {?} */ (this.wrap.nativeElement);
        wrapEl.style.cssText = this.genStyle(affixStyle);
        this.affixStyle = affixStyle;
        const /** @type {?} */ cls = 'ant-affix';
        if (fixed) {
            wrapEl.classList.add(cls);
        }
        else {
            wrapEl.classList.remove(cls);
        }
        if ((affixStyle && !originalAffixStyle) || (!affixStyle && originalAffixStyle)) {
            this.nzChange.emit(fixed);
        }
    }
    /**
     * @param {?} placeholderStyle
     * @return {?}
     */
    setPlaceholderStyle(placeholderStyle) {
        const /** @type {?} */ originalPlaceholderStyle = this.placeholderStyle;
        if (shallowEqual(placeholderStyle, originalPlaceholderStyle)) {
            return;
        }
        (/** @type {?} */ (this._el.nativeElement)).style.cssText = this.genStyle(placeholderStyle);
        this.placeholderStyle = placeholderStyle;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    updatePosition(e) {
        const /** @type {?} */ targetNode = this._target;
        // Backwards support
        let /** @type {?} */ offsetTop = this.nzOffsetTop;
        const /** @type {?} */ scrollTop = this.scrollSrv.getScroll(targetNode, true);
        const /** @type {?} */ affixNode = /** @type {?} */ (this._el.nativeElement);
        const /** @type {?} */ elemOffset = this.getOffset(affixNode, targetNode);
        const /** @type {?} */ elemSize = {
            width: affixNode.offsetWidth,
            height: affixNode.offsetHeight
        };
        const /** @type {?} */ offsetMode = {
            top: false,
            bottom: false
        };
        // Default to `offsetTop=0`.
        if (typeof offsetTop !== 'number' && typeof this._offsetBottom !== 'number') {
            offsetMode.top = true;
            offsetTop = 0;
        }
        else {
            offsetMode.top = typeof offsetTop === 'number';
            offsetMode.bottom = typeof this._offsetBottom === 'number';
        }
        const /** @type {?} */ targetRect = this.getTargetRect(targetNode);
        const /** @type {?} */ targetInnerHeight = (/** @type {?} */ (targetNode)).innerHeight || (/** @type {?} */ (targetNode)).clientHeight;
        if (scrollTop > elemOffset.top - (/** @type {?} */ (offsetTop)) && offsetMode.top) {
            const /** @type {?} */ width = elemOffset.width;
            const /** @type {?} */ top = targetRect.top + (/** @type {?} */ (offsetTop));
            this.setAffixStyle(e, {
                position: 'fixed',
                top,
                left: targetRect.left + elemOffset.left,
                maxHeight: `calc(100vh - ${top}px)`,
                width
            });
            this.setPlaceholderStyle({
                width,
                height: elemSize.height
            });
        }
        else if (scrollTop < elemOffset.top + elemSize.height + (/** @type {?} */ (this._offsetBottom)) - targetInnerHeight &&
            offsetMode.bottom) {
            const /** @type {?} */ targetBottomOffet = targetNode === window ? 0 : (window.innerHeight - targetRect.bottom);
            const /** @type {?} */ width = elemOffset.width;
            this.setAffixStyle(e, {
                position: 'fixed',
                bottom: targetBottomOffet + (/** @type {?} */ (this._offsetBottom)),
                left: targetRect.left + elemOffset.left,
                width
            });
            this.setPlaceholderStyle({
                width,
                height: elemOffset.height
            });
        }
        else {
            if (e.type === 'resize' && this.affixStyle && this.affixStyle.position === 'fixed' && affixNode.offsetWidth) {
                this.setAffixStyle(e, Object.assign({}, this.affixStyle, { width: affixNode.offsetWidth }));
            }
            else {
                this.setAffixStyle(e, null);
            }
            this.setPlaceholderStyle(null);
        }
    }
}
NzAffixComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-affix',
                template: `<div #wrap> <ng-content></ng-content> </div>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [
                    `:host {
      display: block;
    }`
                ]
            },] },
];
/** @nocollapse */
NzAffixComponent.ctorParameters = () => [
    { type: NzScrollService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
NzAffixComponent.propDecorators = {
    wrap: [{ type: ViewChild, args: ['wrap',] }],
    nzTarget: [{ type: Input }],
    nzOffsetTop: [{ type: Input }],
    nzOffsetBottom: [{ type: Input }],
    nzChange: [{ type: Output }]
};
__decorate([
    throttleByAnimationFrameDecorator(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], NzAffixComponent.prototype, "updatePosition", null);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzAffixModule {
}
NzAffixModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzAffixComponent],
                exports: [NzAffixComponent],
                imports: [CommonModule],
                providers: [SCROLL_SERVICE_PROVIDER]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const fadeAnimation = trigger('fadeAnimation', [
    state('void', style({ opacity: 0 })),
    state('true', style({ opacity: 1 })),
    state('false', style({ opacity: 0 })),
    transition('* => true', animate('150ms cubic-bezier(0.0, 0.0, 0.2, 1)')),
    transition('* => void', animate('150ms cubic-bezier(0.4, 0.0, 1, 1)')),
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzAlertComponent {
    constructor() {
        this._banner = false;
        this._closeable = false;
        this._showIcon = false;
        this._type = 'info';
        this.display = true;
        this.isTypeSet = false;
        this.isShowIconSet = false;
        this.prefixClass = 'ant-alert';
        this.nzOnClose = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDescription(value) {
        this.isDescriptionString = !(value instanceof TemplateRef);
        this._description = value;
        this.updateOuterClassMap();
        this.updateIconClassMap();
    }
    /**
     * @return {?}
     */
    get nzDescription() {
        return this._description;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCloseText(value) {
        this.isCloseTextString = !(value instanceof TemplateRef);
        this._closeText = value;
    }
    /**
     * @return {?}
     */
    get nzCloseText() {
        return this._closeText;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzMessage(value) {
        this.isMessageString = !(value instanceof TemplateRef);
        this._message = value;
    }
    /**
     * @return {?}
     */
    get nzMessage() {
        return this._message;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzType(value) {
        this._type = value;
        this.isTypeSet = true;
        this.updateOuterClassMap();
        this.updateIconClassMap();
    }
    /**
     * @return {?}
     */
    get nzType() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzBanner(value) {
        this._banner = toBoolean(value);
        if (!this.isTypeSet) {
            this.nzType = 'warning';
        }
        if (!this.isShowIconSet) {
            this.nzShowIcon = true;
        }
        this.updateOuterClassMap();
    }
    /**
     * @return {?}
     */
    get nzBanner() {
        return this._banner;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCloseable(value) {
        this._closeable = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzCloseable() {
        return this._closeable;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowIcon(value) {
        this._showIcon = toBoolean(value);
        this.isShowIconSet = true;
        this.updateOuterClassMap();
    }
    /**
     * @return {?}
     */
    get nzShowIcon() {
        return this._showIcon;
    }
    /**
     * @return {?}
     */
    closeAlert() {
        this.display = false;
    }
    /**
     * @return {?}
     */
    onFadeAnimationDone() {
        if (!this.display) {
            this.nzOnClose.emit(true);
        }
    }
    /**
     * @return {?}
     */
    updateOuterClassMap() {
        this.outerClassMap = {
            [`${this.prefixClass}`]: true,
            [`${this.prefixClass}-${this.nzType}`]: true,
            [`${this.prefixClass}-no-icon`]: !this.nzShowIcon,
            [`${this.prefixClass}-banner`]: this.nzBanner,
            [`${this.prefixClass}-with-description`]: !!this.nzDescription
        };
    }
    /**
     * @return {?}
     */
    updateIconClassMap() {
        this.iconClassMap = {
            'anticon-cross-circle-o': this.nzDescription && this.nzType === 'error',
            'anticon-check-circle-o': this.nzDescription && this.nzType === 'success',
            'anticon-info-circle-o': this.nzDescription && this.nzType === 'info',
            'anticon-exclamation-circle-o': this.nzDescription && this.nzType === 'warning',
            'anticon-cross-circle': (!this.nzDescription) && this.nzType === 'error',
            'anticon-check-circle': (!this.nzDescription) && this.nzType === 'success',
            'anticon-info-circle': (!this.nzDescription) && this.nzType === 'info',
            'anticon-exclamation-circle': (!this.nzDescription) && this.nzType === 'warning'
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateIconClassMap();
        this.updateOuterClassMap();
    }
}
NzAlertComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-alert',
                animations: [fadeAnimation],
                preserveWhitespaces: false,
                template: `<div [ngClass]="outerClassMap" *ngIf="display" [@fadeAnimation] (@fadeAnimation.done)="onFadeAnimationDone()"> <ng-container *ngIf="nzShowIcon"> <i class="ant-alert-icon" [ngClass]="nzIconType" *ngIf="nzIconType; else iconTemplate"></i> <ng-template #iconTemplate> <i class="ant-alert-icon anticon" [ngClass]="iconClassMap"> </i> </ng-template> </ng-container> <span class="ant-alert-message" *ngIf="nzMessage"> <ng-container *ngIf="isMessageString; else messageTemplate">{{ nzMessage }}</ng-container> <ng-template #messageTemplate> <ng-template [ngTemplateOutlet]="nzMessage"></ng-template> </ng-template> </span> <span class="ant-alert-description" *ngIf="nzDescription"> <ng-container *ngIf="isDescriptionString; else descriptionTemplate">{{ nzDescription }}</ng-container> <ng-template #descriptionTemplate> <ng-template [ngTemplateOutlet]="nzDescription"></ng-template> </ng-template> </span> <a *ngIf="nzCloseable || nzCloseText" (click)="closeAlert($event)" class="ant-alert-close-icon"> <ng-template #closeDefaultTemplate> <i class="anticon anticon-cross"></i> </ng-template> <ng-container *ngIf="nzCloseText; else closeDefaultTemplate"> <ng-container *ngIf="isCloseTextString; else closeTextTemplate">{{ nzCloseText }}</ng-container> <ng-template #closeTextTemplate> <ng-template [ngTemplateOutlet]="nzCloseText"></ng-template> </ng-template> </ng-container> </a> </div>`,
                styles: [
                    `:host {
      display: block;
    }`
                ]
            },] },
];
NzAlertComponent.propDecorators = {
    nzOnClose: [{ type: Output }],
    nzIconType: [{ type: Input }],
    nzDescription: [{ type: Input }],
    nzCloseText: [{ type: Input }],
    nzMessage: [{ type: Input }],
    nzType: [{ type: Input }],
    nzBanner: [{ type: Input }],
    nzCloseable: [{ type: Input }],
    nzShowIcon: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzAlertModule {
}
NzAlertModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzAlertComponent],
                exports: [NzAlertComponent],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const sharpMatcherRegx = /#([^#]+)$/;
class NzAnchorComponent {
    /**
     * @param {?} scrollSrv
     * @param {?} doc
     * @param {?} cd
     */
    constructor(scrollSrv, doc, cd) {
        this.scrollSrv = scrollSrv;
        this.doc = doc;
        this.cd = cd;
        this.links = [];
        this.animating = false;
        this.target = null;
        this.scroll$ = null;
        this.visible = false;
        this.wrapperStyle = { 'max-height': '100vh' };
        this._affix = true;
        this._bounds = 5;
        this._showInkInFixed = false;
        this.nzClick = new EventEmitter();
        this.nzScroll = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAffix(value) {
        this._affix = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzAffix() {
        return this._affix;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzBounds(value) {
        this._bounds = toNumber(value, 5);
    }
    /**
     * @return {?}
     */
    get nzBounds() {
        return this._bounds;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzOffsetTop(value) {
        this._offsetTop = toNumber(value, 0);
        this.wrapperStyle = {
            'max-height': `calc(100vh - ${this._offsetTop}px)`
        };
    }
    /**
     * @return {?}
     */
    get nzOffsetTop() {
        return this._offsetTop;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowInkInFixed(value) {
        this._showInkInFixed = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowInkInFixed() {
        return this._showInkInFixed;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    set nzTarget(el) {
        this.target = el;
        this.registerScrollEvent();
    }
    /**
     * @param {?} link
     * @return {?}
     */
    registerLink(link) {
        this.links.push(link);
    }
    /**
     * @param {?} link
     * @return {?}
     */
    unregisterLink(link) {
        this.links.splice(this.links.indexOf(link), 1);
    }
    /**
     * @return {?}
     */
    getTarget() {
        return this.target || window;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.registerScrollEvent();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListen();
    }
    /**
     * @return {?}
     */
    registerScrollEvent() {
        this.removeListen();
        this.scroll$ = fromEvent(this.getTarget(), 'scroll').pipe(throttleTime(50), distinctUntilChanged())
            .subscribe(e => this.handleScroll());
        // 由于页面刷新时滚动条位置的记忆
        // 倒置在dom未渲染完成，导致计算不正确
        setTimeout(() => this.handleScroll());
    }
    /**
     * @return {?}
     */
    removeListen() {
        if (this.scroll$) {
            this.scroll$.unsubscribe();
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getOffsetTop(element) {
        if (!element || !element.getClientRects().length) {
            return 0;
        }
        const /** @type {?} */ rect = element.getBoundingClientRect();
        if (!rect.width && !rect.height) {
            return rect.top;
        }
        return rect.top - element.ownerDocument.documentElement.clientTop;
    }
    /**
     * @return {?}
     */
    handleScroll() {
        if (this.animating) {
            return;
        }
        const /** @type {?} */ sections = [];
        const /** @type {?} */ scope = (this.nzOffsetTop || 0) + this.nzBounds;
        this.links.forEach(comp => {
            const /** @type {?} */ sharpLinkMatch = sharpMatcherRegx.exec(comp.nzHref.toString());
            if (!sharpLinkMatch) {
                return;
            }
            const /** @type {?} */ target = this.doc.getElementById(sharpLinkMatch[1]);
            if (target && this.getOffsetTop(target) < scope) {
                const /** @type {?} */ top = this.getOffsetTop(target);
                sections.push({
                    top,
                    comp
                });
            }
        });
        this.visible = !!sections.length;
        if (!this.visible) {
            this.clearActive();
            this.cd.detectChanges();
        }
        else {
            const /** @type {?} */ maxSection = sections.reduce((prev, curr) => curr.top > prev.top ? curr : prev);
            this.handleActive(maxSection.comp);
        }
    }
    /**
     * @return {?}
     */
    clearActive() {
        this.links.forEach(i => i.active = false);
    }
    /**
     * @param {?} comp
     * @return {?}
     */
    handleActive(comp) {
        this.clearActive();
        comp.active = true;
        this.cd.detectChanges();
        const /** @type {?} */ linkNode = /** @type {?} */ ((/** @type {?} */ (comp.el.nativeElement)).querySelector('.ant-anchor-link-title'));
        this.ink.nativeElement.style.top = `${linkNode.offsetTop + linkNode.clientHeight / 2 - 4.5}px`;
        this.nzScroll.emit(comp);
    }
    /**
     * @param {?} linkComp
     * @return {?}
     */
    handleScrollTo(linkComp) {
        const /** @type {?} */ el = this.doc.querySelector(linkComp.nzHref);
        if (!el) {
            return;
        }
        this.animating = true;
        const /** @type {?} */ containerScrollTop = this.scrollSrv.getScroll(this.getTarget());
        const /** @type {?} */ elOffsetTop = this.scrollSrv.getOffset(el).top;
        const /** @type {?} */ targetScrollTop = containerScrollTop + elOffsetTop - (this.nzOffsetTop || 0);
        this.scrollSrv.scrollTo(this.getTarget(), targetScrollTop, null, () => {
            this.animating = false;
            this.handleActive(linkComp);
        });
        this.nzClick.emit(linkComp.nzHref);
    }
}
NzAnchorComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-anchor',
                preserveWhitespaces: false,
                template: `<nz-affix *ngIf="nzAffix;else content" [nzOffsetTop]="nzOffsetTop"> <ng-template [ngTemplateOutlet]="content"></ng-template> </nz-affix> <ng-template #content> <div class="ant-anchor-wrapper" #wrap [ngStyle]="wrapperStyle"> <div class="ant-anchor" [ngClass]="{'fixed': !nzAffix && !nzShowInkInFixed}"> <div class="ant-anchor-ink"> <div class="ant-anchor-ink-ball" [class.visible]="visible" #ink></div> </div> <ng-content></ng-content> </div> </div> </ng-template>`,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
NzAnchorComponent.ctorParameters = () => [
    { type: NzScrollService },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef }
];
NzAnchorComponent.propDecorators = {
    wrap: [{ type: ViewChild, args: ['wrap',] }],
    ink: [{ type: ViewChild, args: ['ink',] }],
    nzAffix: [{ type: Input }],
    nzBounds: [{ type: Input }],
    nzOffsetTop: [{ type: Input }],
    nzShowInkInFixed: [{ type: Input }],
    nzTarget: [{ type: Input }],
    nzClick: [{ type: Output }],
    nzScroll: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzAnchorLinkComponent {
    /**
     * @param {?} el
     * @param {?} anchorComp
     */
    constructor(el, anchorComp) {
        this.el = el;
        this.anchorComp = anchorComp;
        this.nzHref = '#';
        this.titleStr = '';
        this.active = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTitle(value) {
        if (value instanceof TemplateRef) {
            this.titleTpl = value;
        }
        else {
            this.titleStr = value;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.anchorComp.registerLink(this);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    goToClick(e) {
        e.preventDefault();
        e.stopPropagation();
        this.anchorComp.handleScrollTo(this);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.anchorComp.unregisterLink(this);
    }
}
NzAnchorLinkComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-link',
                preserveWhitespaces: false,
                template: `<a (click)="goToClick($event)" href="{{nzHref}}" class="ant-anchor-link-title" title="{{titleStr}}"> <span *ngIf="titleStr; else (titleTpl || nzTemplate)">{{ titleStr }}</span> </a> <ng-content></ng-content>`,
                host: {
                    '[class.ant-anchor-link]': 'true',
                    'style': 'display:block'
                }
            },] },
];
/** @nocollapse */
NzAnchorLinkComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NzAnchorComponent }
];
NzAnchorLinkComponent.propDecorators = {
    nzHref: [{ type: Input }],
    nzTitle: [{ type: Input }],
    nzTemplate: [{ type: ContentChild, args: ['nzTemplate',] }],
    active: [{ type: HostBinding, args: ['class.ant-anchor-link-active',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzAnchorModule {
}
NzAnchorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzAnchorComponent, NzAnchorLinkComponent],
                exports: [NzAnchorComponent, NzAnchorLinkComponent],
                imports: [CommonModule, NzAffixModule],
                providers: [SCROLL_SERVICE_PROVIDER]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzAutocompleteOptgroupComponent {
    constructor() {
    }
    /**
     * group 的 label，支持 'string' 和 `TemplateRef`
     * @param {?} value
     * @return {?}
     */
    set nzLabel(value) {
        this.isLabelString = !(value instanceof TemplateRef);
        this._label = value;
    }
    /**
     * @return {?}
     */
    get nzLabel() {
        return this._label;
    }
}
NzAutocompleteOptgroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-auto-optgroup',
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `<div class="ant-select-dropdown-menu-item-group-title"> <ng-container *ngIf="isLabelString; else labelTemplate">{{nzLabel}}</ng-container> <ng-template #labelTemplate> <ng-template [ngTemplateOutlet]="nzLabel"></ng-template> </ng-template> </div> <ul class="ant-select-dropdown-menu-item-group-list"> <ng-content select="nz-auto-option"></ng-content> </ul> `,
                host: {
                    'role': 'group',
                    'class': 'ant-select-dropdown-menu-item-group'
                }
            },] },
];
/** @nocollapse */
NzAutocompleteOptgroupComponent.ctorParameters = () => [];
NzAutocompleteOptgroupComponent.propDecorators = {
    nzLabel: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzOptionSelectionChange {
    /**
     * @param {?} source
     * @param {?=} isUserInput
     */
    constructor(source, isUserInput = false) {
        this.source = source;
        this.isUserInput = isUserInput;
    }
}
class NzAutocompleteOptionComponent {
    /**
     * @param {?} changeDetectorRef
     * @param {?} element
     */
    constructor(changeDetectorRef, element) {
        this.changeDetectorRef = changeDetectorRef;
        this.element = element;
        this.disabled = false;
        this.active = false;
        this.selected = false;
        this.selectionChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this.disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this.disabled = toBoolean(value);
    }
    /**
     * 选择
     * @return {?}
     */
    select() {
        this.selected = true;
        this.changeDetectorRef.markForCheck();
        this.emitSelectionChangeEvent();
    }
    /**
     * 取消选择
     * @return {?}
     */
    deselect() {
        this.selected = false;
        this.changeDetectorRef.markForCheck();
        this.emitSelectionChangeEvent();
    }
    /**
     * 获取用于显示的 label
     * @return {?}
     */
    getLabel() {
        return this.nzLabel || this.nzValue.toString();
    }
    /**
     * 设置激活样式 (仅限样式)
     * @return {?}
     */
    setActiveStyles() {
        if (!this.active) {
            this.active = true;
            this.changeDetectorRef.markForCheck();
        }
    }
    /**
     * 设置非激活样式 (仅限样式)
     * @return {?}
     */
    setInactiveStyles() {
        if (this.active) {
            this.active = false;
            this.changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    scrollIntoViewIfNeeded() {
        /* tslint:disable-next-line:no-string-literal */
        if (this.element.nativeElement && this.element.nativeElement['scrollIntoViewIfNeeded']) {
            /* tslint:disable-next-line:no-string-literal */
            setTimeout(() => this.element.nativeElement['scrollIntoViewIfNeeded'](false), 150);
        }
    }
    /**
     * @param {?=} isUserInput
     * @return {?}
     */
    emitSelectionChangeEvent(isUserInput = false) {
        this.selectionChange.emit(new NzOptionSelectionChange(this, isUserInput));
    }
    /**
     * @return {?}
     */
    selectViaInteraction() {
        if (!this.disabled) {
            this.selected = !this.selected;
            if (this.selected) {
                this.setActiveStyles();
            }
            else {
                this.setInactiveStyles();
            }
            this.emitSelectionChangeEvent(true);
            this.changeDetectorRef.markForCheck();
        }
    }
}
NzAutocompleteOptionComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-auto-option',
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `<ng-content></ng-content>`,
                host: {
                    'role': 'menuitem',
                    'class': 'ant-select-dropdown-menu-item',
                    '[class.ant-select-dropdown-menu-item-selected]': 'selected',
                    '[class.ant-select-dropdown-menu-item-active]': 'active',
                    '[class.ant-select-dropdown-menu-item-disabled]': 'nzDisabled',
                    '[attr.aria-selected]': 'selected.toString()',
                    '[attr.aria-disabled]': 'nzDisabled.toString()',
                    '(click)': 'selectViaInteraction()'
                }
            },] },
];
/** @nocollapse */
NzAutocompleteOptionComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
NzAutocompleteOptionComponent.propDecorators = {
    nzValue: [{ type: Input }],
    nzLabel: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    selectionChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const dropDownAnimation = trigger('dropDownAnimation', [
    state('bottom', style({
        opacity: 1,
        transform: 'scaleY(1)',
        transformOrigin: '0% 0%'
    })),
    transition('void => bottom', [
        style({
            opacity: 0,
            transform: 'scaleY(0.8)',
            transformOrigin: '0% 0%'
        }),
        animate('150ms cubic-bezier(0.23, 1, 0.32, 1)')
    ]),
    transition('bottom => void', [
        animate('150ms cubic-bezier(0.23, 1, 0.32, 1)', style({
            opacity: 0,
            transform: 'scaleY(0.8)',
            transformOrigin: '0% 0%'
        }))
    ]),
    state('top', style({
        opacity: 1,
        transform: 'scaleY(1)',
        transformOrigin: '0% 100%'
    })),
    transition('void => top', [
        style({
            opacity: 0,
            transform: 'scaleY(0.8)',
            transformOrigin: '0% 100%'
        }),
        animate('150ms cubic-bezier(0.23, 1, 0.32, 1)')
    ]),
    transition('top => void', [
        animate('150ms cubic-bezier(0.23, 1, 0.32, 1)', style({
            opacity: 0,
            transform: 'scaleY(0.8)',
            transformOrigin: '0% 100%'
        }))
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class NzAutocompleteComponent {
    /**
     * @param {?} changeDetectorRef
     * @param {?} _ngZone
     */
    constructor(changeDetectorRef, _ngZone) {
        this.changeDetectorRef = changeDetectorRef;
        this._ngZone = _ngZone;
        this.activeItemIndex = -1;
        this.showPanel = false;
        this.isOpen = false;
        this.dropDownPosition = 'bottom';
        this._defaultActiveFirstOption = true;
        this._backfill = false;
        /**
         * 选择时发出的事件
         */
        this.selectionChange = new EventEmitter();
        /**
         * 用于组件内部监听 options 的选择变化
         */
        this.optionSelectionChanges = defer(() => {
            if (this.options) {
                return merge(...this.options.map(option => option.selectionChange));
            }
            return this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap(() => this.optionSelectionChanges));
        });
    }
    /**
     * 组件支持设置 dataSource 和 content 设置 options
     *  这个属性为其提供方便的访问方式
     * @return {?}
     */
    get options() {
        // 优先使用 dataSource
        if (this.nzDataSource) {
            return this.fromDataSourceOptions;
        }
        else {
            return this.fromContentOptions;
        }
    }
    /**
     * 是否默认高亮第一个选项，默认 `true`
     * @return {?}
     */
    get nzDefaultActiveFirstOption() {
        return this._defaultActiveFirstOption;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDefaultActiveFirstOption(value) {
        this._defaultActiveFirstOption = toBoolean(value);
    }
    /**
     * 使用键盘选择选项的时候把选中项回填到输入框中，默认 `false`
     * @return {?}
     */
    get nzBackfill() {
        return this._backfill;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzBackfill(value) {
        this._backfill = toBoolean(value);
    }
    /**
     * 自动完成的数据源
     * @return {?}
     */
    get nzDataSource() {
        return this._dataSource;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDataSource(value) {
        this._dataSource = value;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.optionsInit();
    }
    /**
     * @return {?}
     */
    setVisibility() {
        this.showPanel = !!this.options.length;
        this.changeDetectorRef.markForCheck();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    setActiveItem(index) {
        const /** @type {?} */ activeItem = this.options.toArray()[index];
        if (activeItem && !activeItem.active) {
            this.activeItem = activeItem;
            this.activeItemIndex = index;
            this.clearSelectedOptions(this.activeItem);
            this.activeItem.setActiveStyles();
            this.changeDetectorRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    setNextItemActive() {
        const /** @type {?} */ nextIndex = this.activeItemIndex + 1 <= this.options.length - 1 ? this.activeItemIndex + 1 : 0;
        this.setActiveItem(nextIndex);
    }
    /**
     * @return {?}
     */
    setPreviousItemActive() {
        const /** @type {?} */ previousIndex = this.activeItemIndex - 1 < 0 ? this.options.length - 1 : this.activeItemIndex - 1;
        this.setActiveItem(previousIndex);
    }
    /**
     * @param {?} option
     * @return {?}
     */
    getOptionIndex(option) {
        return this.options.reduce((result, current, index) => {
            return result === undefined ? (option === current ? index : undefined) : result;
        }, undefined);
    }
    /**
     * @return {?}
     */
    optionsInit() {
        this.setVisibility();
        this.subscribeOptionChanges();
        const /** @type {?} */ changes = this.nzDataSource ? this.fromDataSourceOptions.changes : this.fromContentOptions.changes;
        // 用于处理动态/异步的 options
        changes.subscribe(e => {
            if (!e.dirty && this.isOpen) {
                setTimeout(_ => this.setVisibility());
            }
            this.subscribeOptionChanges();
        });
    }
    /**
     * 清除 Options 的激活状态
     * @param {?=} skip
     * @param {?=} deselect
     * @return {?}
     */
    clearSelectedOptions(skip, deselect = false) {
        this.options.forEach(option => {
            if (option !== skip) {
                if (deselect) {
                    option.deselect();
                }
                option.setInactiveStyles();
            }
        });
    }
    /**
     * @return {?}
     */
    subscribeOptionChanges() {
        this.selectionChangeSubscription = this.optionSelectionChanges
            .pipe(filter((event) => event.isUserInput))
            .subscribe((event) => {
            event.source.select();
            event.source.setActiveStyles();
            this.activeItem = event.source;
            this.activeItemIndex = this.getOptionIndex(this.activeItem);
            this.clearSelectedOptions(event.source, true);
            this.selectionChange.emit(event.source);
        });
    }
}
NzAutocompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-autocomplete',
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                animations: [
                    dropDownAnimation
                ],
                template: `<ng-template> <div class="ant-select-dropdown ant-select-dropdown--single ant-select-dropdown-placement-bottomLeft" #panel [@dropDownAnimation]="dropDownPosition" [class.ant-select-dropdown-hidden]="!showPanel"> <div style="overflow: auto;"> <ul class="ant-select-dropdown-menu  ant-select-dropdown-menu-root ant-select-dropdown-menu-vertical" role="menu" aria-activedescendant> <ng-template *ngTemplateOutlet="nzDataSource ? optionsTemplate : contentTemplate"></ng-template> </ul> </div> </div> <ng-template #contentTemplate> <ng-content></ng-content> </ng-template> <ng-template #optionsTemplate> <nz-auto-option *ngFor="let option of nzDataSource" [nzValue]="option">{{option}}</nz-auto-option> </ng-template> </ng-template>`,
                styles: [
                    `
    .ant-select-dropdown {
      top: 100%;
      left: 0;
      position: relative;
      width: 100%;
      margin-top: 4px;
      margin-bottom: 4px;
    }
    `
                ]
            },] },
];
/** @nocollapse */
NzAutocompleteComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone }
];
NzAutocompleteComponent.propDecorators = {
    template: [{ type: ViewChild, args: [TemplateRef,] }],
    panel: [{ type: ViewChild, args: ['panel',] }],
    content: [{ type: ViewChild, args: ['content',] }],
    fromContentOptions: [{ type: ContentChildren, args: [NzAutocompleteOptionComponent, { descendants: true },] }],
    fromDataSourceOptions: [{ type: ViewChildren, args: [NzAutocompleteOptionComponent,] }],
    nzWidth: [{ type: Input }],
    nzDefaultActiveFirstOption: [{ type: Input }],
    nzBackfill: [{ type: Input }],
    nzDataSource: [{ type: Input }],
    selectionChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const NZ_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NzAutocompleteTriggerDirective),
    multi: true
};
/**
 * @return {?}
 */
function getNzAutocompleteMissingPanelError() {
    return Error('Attempting to open an undefined instance of `nz-autocomplete`. ' +
        'Make sure that the id passed to the `nzAutocomplete` is correct and that ' +
        'you\'re attempting to open it after the ngAfterContentInit hook.');
}
class NzAutocompleteTriggerDirective {
    /**
     * @param {?} _element
     * @param {?} _overlay
     * @param {?} _viewContainerRef
     * @param {?} _document
     */
    constructor(_element, _overlay, _viewContainerRef, 
    // tslint:disable-next-line:no-any
    _document) {
        this._element = _element;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._document = _document;
        this._onChange = () => { };
        this._onTouched = () => { };
        this.panelOpen = false;
    }
    /**
     * 当前被激活的 Option
     * @return {?}
     */
    get activeOption() {
        if (this.nzAutocomplete && this.nzAutocomplete.options.length) {
            return this.nzAutocomplete.activeItem;
        }
    }
    /**
     * @return {?}
     */
    openPanel() {
        this.attachOverlay();
    }
    /**
     * @return {?}
     */
    closePanel() {
        if (this.panelOpen) {
            this.nzAutocomplete.isOpen = this.panelOpen = false;
            if (this.overlayRef && this.overlayRef.hasAttached()) {
                this.overlayRef.detach();
                this.selectionChangeSubscription.unsubscribe();
                this.overlayBackdropClickSubscription.unsubscribe();
                this.overlayPositionChangeSubscription.unsubscribe();
                this.optionsChangeSubscription.unsubscribe();
            }
        }
    }
    /**
     * 订阅数据源改变事件
     * @return {?}
     */
    subscribeOptionsChange() {
        return this.nzAutocomplete.options.changes.pipe(delay(0)).subscribe(() => {
            this.resetActiveItem();
        });
    }
    /**
     * 订阅 option 选择事件
     * 并设置值
     * @return {?}
     */
    subscribeSelectionChange() {
        return this.nzAutocomplete.selectionChange
            .subscribe((option) => {
            this.setValueAndClose(option);
        });
    }
    /**
     * 订阅组件外部的单击事件
     * 并关闭弹窗
     * @return {?}
     */
    subscribeOverlayBackdropClick() {
        return merge(fromEvent(this._document, 'click'), fromEvent(this._document, 'touchend'))
            .subscribe((event) => {
            const /** @type {?} */ clickTarget = /** @type {?} */ (event.target);
            // 确保不是点击组件自身
            if (clickTarget !== this._element.nativeElement && this.panelOpen) {
                this.closePanel();
            }
        });
    }
    /**
     * 订阅 Overlay 位置改变事件
     * 并重新设置动画方向
     * @return {?}
     */
    subscribeOverlayPositionChange() {
        return this.positionStrategy.positionChanges
            .pipe(map((position) => position.connectionPair.originY), distinct())
            .subscribe((position) => {
            this.nzAutocomplete.dropDownPosition = position;
        });
    }
    /**
     * @return {?}
     */
    attachOverlay() {
        if (!this.nzAutocomplete) {
            throw getNzAutocompleteMissingPanelError();
        }
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.nzAutocomplete.template, this._viewContainerRef);
            this.overlayRef = this._overlay.create(this.getOverlayConfig());
        }
        else {
            // 如果没有设置 nzDisplayWith 则使用 Host 元素的宽度
            this.overlayRef.updateSize({ width: this.nzAutocomplete.nzWidth || this.getHostWidth() });
        }
        this.overlayPositionChangeSubscription = this.subscribeOverlayPositionChange();
        if (this.overlayRef && !this.overlayRef.hasAttached()) {
            this.overlayRef.attach(this.portal);
            this.selectionChangeSubscription = this.subscribeSelectionChange();
            this.overlayBackdropClickSubscription = this.subscribeOverlayBackdropClick();
            this.optionsChangeSubscription = this.subscribeOptionsChange();
        }
        this.nzAutocomplete.isOpen = this.panelOpen = true;
        this.nzAutocomplete.setVisibility();
        this.resetActiveItem();
        if (this.activeOption) {
            this.activeOption.scrollIntoViewIfNeeded();
        }
    }
    /**
     * @return {?}
     */
    destroyPanel() {
        if (this.overlayRef) {
            this.closePanel();
            this.overlayRef.dispose();
            this.overlayRef = null;
        }
    }
    /**
     * @return {?}
     */
    getOverlayConfig() {
        return new OverlayConfig({
            positionStrategy: this.getOverlayPosition(),
            scrollStrategy: this._overlay.scrollStrategies.reposition(),
            // 如果没有设置 nzWidth 则使用 Host 元素的宽度
            width: this.nzAutocomplete.nzWidth || this.getHostWidth()
        });
    }
    /**
     * @return {?}
     */
    getConnectedElement() {
        return this._element;
    }
    /**
     * @return {?}
     */
    getHostWidth() {
        return this.getConnectedElement().nativeElement.getBoundingClientRect().width;
    }
    /**
     * @return {?}
     */
    getOverlayPosition() {
        const /** @type {?} */ positions = [
            new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
            new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
        ];
        this.positionStrategy = this._overlay.position()
            .flexibleConnectedTo(this.getConnectedElement())
            .withPositions(positions)
            .withFlexibleDimensions(false)
            .withPush(false);
        return this.positionStrategy;
    }
    /**
     * @return {?}
     */
    resetActiveItem() {
        if (this.nzAutocomplete.activeItem && this.nzAutocomplete.getOptionIndex(this.nzAutocomplete.activeItem)) {
            this.nzAutocomplete.setActiveItem(this.nzAutocomplete.getOptionIndex(this.nzAutocomplete.activeItem));
        }
        else {
            this.nzAutocomplete.setActiveItem(this.nzAutocomplete.nzDefaultActiveFirstOption ? 0 : -1);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleKeydown(event) {
        const /** @type {?} */ keyCode = event.keyCode;
        const /** @type {?} */ isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;
        if (keyCode === ESCAPE) {
            event.preventDefault();
        }
        if (this.panelOpen && (keyCode === ESCAPE || keyCode === TAB)) {
            // 通过 tab / ESC 关闭，重置输入标签 value
            if (this.activeOption.getLabel() !== this.previousValue) {
                this.setTriggerValue(this.previousValue);
            }
            this.closePanel();
        }
        else if (this.panelOpen && keyCode === ENTER) {
            event.preventDefault();
            if (this.nzAutocomplete.showPanel && this.activeOption) {
                this.activeOption.selectViaInteraction();
            }
        }
        else if (this.panelOpen && isArrowKey && this.nzAutocomplete.showPanel) {
            event.stopPropagation();
            if (keyCode === UP_ARROW) {
                this.nzAutocomplete.setPreviousItemActive();
            }
            else {
                this.nzAutocomplete.setNextItemActive();
            }
            if (this.activeOption) {
                this.activeOption.scrollIntoViewIfNeeded();
            }
            this.doBackfill();
        }
    }
    /**
     * @param {?} option
     * @return {?}
     */
    setValueAndClose(option) {
        const /** @type {?} */ value = option.nzValue;
        this.setTriggerValue(option.getLabel());
        this._onChange(value);
        this._element.nativeElement.focus();
        this.closePanel();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setTriggerValue(value) {
        this._element.nativeElement.value = value || '';
    }
    /**
     * @return {?}
     */
    doBackfill() {
        if (this.nzAutocomplete.nzBackfill) {
            // 只设置标签显示值
            this.setTriggerValue(this.nzAutocomplete.activeItem.getLabel());
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleInput(event) {
        const /** @type {?} */ target = /** @type {?} */ (event.target);
        let /** @type {?} */ value = target.value;
        if (target.type === 'number') {
            value = value === '' ? null : parseFloat(value);
        }
        if (this.canOpen() && document.activeElement === event.target &&
            this.previousValue !== value) {
            this.previousValue = value;
            this._onChange(value);
            this.openPanel();
        }
    }
    /**
     * @return {?}
     */
    handleFocus() {
        if (this.canOpen()) {
            this.previousValue = this._element.nativeElement.value;
            this.openPanel();
        }
    }
    /**
     * @return {?}
     */
    handleBlur() {
        this._onTouched();
    }
    /**
     * @return {?}
     */
    canOpen() {
        const /** @type {?} */ element = this._element.nativeElement;
        return !element.readOnly && !element.disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.setTriggerValue(value);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        const /** @type {?} */ element = this._element.nativeElement;
        element.disabled = isDisabled;
        this.closePanel();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyPanel();
    }
}
NzAutocompleteTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: `input[nzAutocomplete], textarea[nzAutocomplete]`,
                providers: [NZ_AUTOCOMPLETE_VALUE_ACCESSOR],
                host: {
                    'autocomplete': 'off',
                    'aria-autocomplete': 'list',
                    '(focusin)': 'handleFocus()',
                    '(blur)': 'handleBlur()',
                    '(input)': 'handleInput($event)',
                    '(keydown)': 'handleKeydown($event)'
                }
            },] },
];
/** @nocollapse */
NzAutocompleteTriggerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Overlay },
    { type: ViewContainerRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
NzAutocompleteTriggerDirective.propDecorators = {
    nzAutocomplete: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzAutocompleteModule {
}
NzAutocompleteModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzAutocompleteComponent, NzAutocompleteOptionComponent, NzAutocompleteTriggerDirective, NzAutocompleteOptgroupComponent],
                exports: [NzAutocompleteComponent, NzAutocompleteOptionComponent, NzAutocompleteTriggerDirective, NzAutocompleteOptgroupComponent],
                imports: [CommonModule, OverlayModule, FormsModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzUpdateHostClassService {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this.classMap = {};
    }
    /**
     * @param {?} el
     * @param {?} classMap
     * @return {?}
     */
    updateHostClass(el, classMap) {
        this.removeClass(el, this.classMap, this.renderer);
        this.classMap = Object.assign({}, classMap);
        this.addClass(el, this.classMap, this.renderer);
    }
    /**
     * @param {?} el
     * @param {?} classMap
     * @param {?} renderer
     * @return {?}
     */
    removeClass(el, classMap, renderer) {
        for (const /** @type {?} */ i in classMap) {
            if (classMap.hasOwnProperty(i)) {
                renderer.removeClass(el, i);
            }
        }
    }
    /**
     * @param {?} el
     * @param {?} classMap
     * @param {?} renderer
     * @return {?}
     */
    addClass(el, classMap, renderer) {
        for (const /** @type {?} */ i in classMap) {
            if (classMap.hasOwnProperty(i)) {
                if (classMap[i]) {
                    renderer.addClass(el, i);
                }
            }
        }
    }
}
NzUpdateHostClassService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NzUpdateHostClassService.ctorParameters = () => [
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzAvatarComponent {
    /**
     * @param {?} elementRef
     * @param {?} cd
     * @param {?} updateHostClassService
     */
    constructor(elementRef, cd, updateHostClassService) {
        this.cd = cd;
        this.updateHostClassService = updateHostClassService;
        this.prefixCls = 'ant-avatar';
        this.sizeMap = { large: 'lg', small: 'sm' };
        this.hasText = false;
        this.hasSrc = true;
        this.hasIcon = false;
        this.nzShape = 'circle';
        this.nzSize = 'default';
        this.el = elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    setClass() {
        const /** @type {?} */ classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-${this.sizeMap[this.nzSize]}`]: this.sizeMap[this.nzSize],
            [`${this.prefixCls}-${this.nzShape}`]: this.nzShape,
            [`${this.prefixCls}-icon`]: this.nzIcon,
            [`${this.prefixCls}-image`]: this.nzSrc
        };
        this.updateHostClassService.updateHostClass(this.el, classMap);
        this.cd.detectChanges();
        return this;
    }
    /**
     * @return {?}
     */
    imgError() {
        this.hasSrc = false;
        this.hasIcon = false;
        this.hasText = false;
        if (this.nzIcon) {
            this.hasIcon = true;
        }
        else if (this.nzText) {
            this.hasText = true;
        }
        this.setClass().notifyCalc();
    }
    /**
     * @return {?}
     */
    calcStringSize() {
        if (!this.hasText) {
            return;
        }
        const /** @type {?} */ childrenWidth = this.textEl.nativeElement.offsetWidth;
        const /** @type {?} */ avatarWidth = this.el.getBoundingClientRect().width;
        const /** @type {?} */ scale = avatarWidth - 8 < childrenWidth ? (avatarWidth - 8) / childrenWidth : 1;
        if (scale === 1) {
            this.textStyles = {};
        }
        else {
            this.textStyles = {
                transform: `scale(${scale})`,
                position: 'absolute',
                display: 'inline-block',
                left: `calc(50% - ${Math.round(childrenWidth / 2)}px)`
            };
        }
        this.cd.detectChanges();
    }
    /**
     * @return {?}
     */
    notifyCalc() {
        // If use ngAfterViewChecked, always demands more computations, so......
        setTimeout(() => {
            this.calcStringSize();
        });
        return this;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.hasText = !this.nzSrc && !!this.nzText;
        this.hasIcon = !this.nzSrc && !!this.nzIcon;
        this.setClass().notifyCalc();
    }
}
NzAvatarComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-avatar',
                template: `<i *ngIf="nzIcon && hasIcon" [ngClass]="nzIcon"></i> <img [src]="nzSrc" *ngIf="nzSrc && hasSrc" (error)="imgError()"/> <span class="ant-avatar-string" #textEl [ngStyle]="textStyles" *ngIf="nzText && hasText">{{ nzText }}</span>`,
                providers: [NzUpdateHostClassService],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
NzAvatarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NzUpdateHostClassService }
];
NzAvatarComponent.propDecorators = {
    textEl: [{ type: ViewChild, args: ['textEl',] }],
    nzShape: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzText: [{ type: Input }],
    nzSrc: [{ type: Input }],
    nzIcon: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzAvatarModule {
}
NzAvatarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzAvatarComponent],
                exports: [NzAvatarComponent],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzBackTopComponent {
    /**
     * @param {?} scrollSrv
     * @param {?} cd
     */
    constructor(scrollSrv, cd) {
        this.scrollSrv = scrollSrv;
        this.cd = cd;
        this.scroll$ = null;
        this.target = null;
        this.visible = false;
        this._visibilityHeight = 400;
        this.nzClick = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzVisibilityHeight(value) {
        this._visibilityHeight = toNumber(value, 400);
    }
    /**
     * @return {?}
     */
    get nzVisibilityHeight() {
        return this._visibilityHeight;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    set nzTarget(el) {
        this.target = el;
        this.registerScrollEvent();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.scroll$) {
            this.registerScrollEvent();
        }
    }
    /**
     * @return {?}
     */
    clickBackTop() {
        this.scrollSrv.scrollTo(this.getTarget(), 0);
        this.nzClick.emit(true);
    }
    /**
     * @return {?}
     */
    getTarget() {
        return this.target || window;
    }
    /**
     * @return {?}
     */
    handleScroll() {
        if (this.visible === this.scrollSrv.getScroll(this.getTarget()) > this.nzVisibilityHeight) {
            return;
        }
        this.visible = !this.visible;
        this.cd.detectChanges();
    }
    /**
     * @return {?}
     */
    removeListen() {
        if (this.scroll$) {
            this.scroll$.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    registerScrollEvent() {
        this.removeListen();
        this.handleScroll();
        this.scroll$ = fromEvent(this.getTarget(), 'scroll').pipe(throttleTime(50), distinctUntilChanged())
            .subscribe(e => this.handleScroll());
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListen();
    }
}
NzBackTopComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-back-top',
                animations: [
                    trigger('enterLeave', [
                        transition(':enter', [
                            style({ opacity: 0 }),
                            animate(300, style({ opacity: 1 }))
                        ]),
                        transition(':leave', [
                            style({ opacity: 1 }),
                            animate(300, style({ opacity: 0 }))
                        ])
                    ])
                ],
                template: `<div class="ant-back-top" (click)="clickBackTop()" [@enterLeave] *ngIf="visible"> <ng-template #defaultContent> <div class="ant-back-top-content"> <div class="ant-back-top-icon"></div> </div> </ng-template> <ng-template [ngTemplateOutlet]="nzTemplate || defaultContent"></ng-template> </div>`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            },] },
];
/** @nocollapse */
NzBackTopComponent.ctorParameters = () => [
    { type: NzScrollService },
    { type: ChangeDetectorRef }
];
NzBackTopComponent.propDecorators = {
    nzTemplate: [{ type: Input }],
    nzVisibilityHeight: [{ type: Input }],
    nzTarget: [{ type: Input }],
    nzClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzBackTopModule {
}
NzBackTopModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzBackTopComponent],
                exports: [NzBackTopComponent],
                imports: [CommonModule],
                providers: [SCROLL_SERVICE_PROVIDER]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzBadgeComponent {
    /**
     * @param {?} zone
     * @param {?} renderer
     * @param {?} elementRef
     */
    constructor(zone, renderer, elementRef) {
        this.zone = zone;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this._showDot = false;
        this._showZero = false;
        this.maxNumberArray = [];
        this.countArray = [];
        this.countSingleArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        this.nzOverflowCount = 99;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowZero(value) {
        this._showZero = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowZero() {
        return this._showZero;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDot(value) {
        this._showDot = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDot() {
        return this._showDot;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCount(value) {
        if (value < 0) {
            this._count = 0;
        }
        else {
            this._count = value;
        }
        this.countArray = this._count.toString().split('');
    }
    /**
     * @return {?}
     */
    get nzCount() {
        return this._count;
    }
    /**
     * @return {?}
     */
    get showSup() {
        return this.nzDot || this.nzCount > 0 || ((this.nzCount === 0) && this.nzShowZero);
    }
    /**
     * @return {?}
     */
    checkContent() {
        if (isEmpty(this.contentElement.nativeElement)) {
            this.renderer.addClass(this.elementRef.nativeElement, 'ant-badge-not-a-wrapper');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'ant-badge-not-a-wrapper');
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.maxNumberArray = this.nzOverflowCount.toString().split('');
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.checkContent();
    }
}
NzBadgeComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-badge',
                preserveWhitespaces: false,
                animations: [
                    trigger('enterLeave', [
                        transition('void => *', [
                            style({ opacity: 0 }),
                            animate('0.3s cubic-bezier(0.12, 0.4, 0.29, 1.46)')
                        ]),
                        transition('* => void', [
                            style({ opacity: 1 }),
                            animate('0.3s cubic-bezier(0.12, 0.4, 0.29, 1.46)')
                        ])
                    ])
                ],
                template: `<span (cdkObserveContent)="checkContent()" #contentElement><ng-content></ng-content></span> <span class="ant-badge-status-dot ant-badge-status-{{nzStatus}}" *ngIf="nzStatus" [ngStyle]="nzStyle"></span> <span class="ant-badge-status-text" *ngIf="nzStatus">{{ nzText }}</span> <sup *ngIf="showSup" [@enterLeave] [ngStyle]="nzStyle" class="ant-scroll-number" [class.ant-badge-count]="!nzDot" [class.ant-badge-dot]="nzDot" [class.ant-badge-multiple-words]="countArray.length>=2"> <ng-template ngFor [ngForOf]="maxNumberArray" let-number let-i="index"> <span *ngIf="nzCount<=nzOverflowCount" class="ant-scroll-number-only" [style.transform]="'translateY('+((-countArray[i]*100))+'%)'"> <ng-template [ngIf]="(!nzDot)&&(countArray[i]!=null)"> <p *ngFor="let p of countSingleArray" [class.current]="p==countArray[i]">{{ p }}</p> </ng-template> </span> </ng-template> <ng-template [ngIf]="nzCount>nzOverflowCount">{{ nzOverflowCount }}+</ng-template> </sup>`,
                host: {
                    '[class.ant-badge]': 'true',
                    '[class.ant-badge-status]': 'nzStatus'
                },
                styles: [
                    `
      :host:not(.ant-badge-not-a-wrapper) .ant-badge-count {
        position: absolute;
        transform: translateX(50%);
        right: 0;
      }

      :host .ant-badge-dot {
        position: absolute;
        transform: translateX(50%);
        right: 0;
      }
    `
                ]
            },] },
];
/** @nocollapse */
NzBadgeComponent.ctorParameters = () => [
    { type: NgZone },
    { type: Renderer2 },
    { type: ElementRef }
];
NzBadgeComponent.propDecorators = {
    contentElement: [{ type: ViewChild, args: ['contentElement',] }],
    nzOverflowCount: [{ type: Input }],
    nzText: [{ type: Input }],
    nzStyle: [{ type: Input }],
    nzStatus: [{ type: Input }],
    nzShowZero: [{ type: Input }],
    nzDot: [{ type: Input }],
    nzCount: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzBadgeModule {
}
NzBadgeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzBadgeComponent],
                exports: [NzBadgeComponent],
                imports: [CommonModule, ObserversModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzBreadCrumbComponent {
    constructor() {
        this._separator = '/';
        this.isTemplateRef = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSeparator(value) {
        this._separator = value;
        this.isTemplateRef = value instanceof TemplateRef;
    }
    /**
     * @return {?}
     */
    get nzSeparator() {
        return this._separator;
    }
}
NzBreadCrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-breadcrumb',
                preserveWhitespaces: false,
                template: `<ng-content></ng-content>`,
                host: {
                    '[class.ant-breadcrumb]': 'true'
                },
                styles: [`
    :host {
      display: block;
    }
  `]
            },] },
];
NzBreadCrumbComponent.propDecorators = {
    nzSeparator: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzBreadCrumbItemComponent {
    /**
     * @param {?} nzBreadCrumbComponent
     */
    constructor(nzBreadCrumbComponent) {
        this.nzBreadCrumbComponent = nzBreadCrumbComponent;
    }
}
NzBreadCrumbItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-breadcrumb-item',
                preserveWhitespaces: false,
                template: `
    <span class="ant-breadcrumb-link">
      <ng-content></ng-content>
    </span>
    <span class="ant-breadcrumb-separator">
      <ng-container *ngIf="nzBreadCrumbComponent.isTemplateRef; else stringTemplate">
        <ng-template [ngTemplateOutlet]="nzBreadCrumbComponent.nzSeparator"></ng-template>
      </ng-container>
      <ng-template #stringTemplate>
         {{ nzBreadCrumbComponent.nzSeparator }}
      </ng-template>
    </span>`,
                styles: [
                    `:host:last-child {
      color: rgba(0, 0, 0, 0.65);
    }

    :host:last-child .ant-breadcrumb-separator{
      display: none;
    }
    `
                ]
            },] },
];
/** @nocollapse */
NzBreadCrumbItemComponent.ctorParameters = () => [
    { type: NzBreadCrumbComponent }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzBreadCrumbModule {
}
NzBreadCrumbModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NzBreadCrumbComponent, NzBreadCrumbItemComponent],
                exports: [NzBreadCrumbComponent, NzBreadCrumbItemComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzButtonGroupComponent {
    constructor() {
        this.prefixCls = 'ant-btn-group';
        this.sizeMap = { large: 'lg', small: 'sm' };
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-${this.sizeMap[this.nzSize]}`]: this.sizeMap[this.nzSize]
        };
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this._size = value;
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-${this.sizeMap[this.nzSize]}`]: this.sizeMap[this.nzSize]
        };
    }
}
NzButtonGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-button-group',
                preserveWhitespaces: false,
                template: `<div [ngClass]="classMap" #groupWrapper> <ng-content></ng-content> </div>`
            },] },
];
NzButtonGroupComponent.propDecorators = {
    groupWrapper: [{ type: ViewChild, args: ['groupWrapper',] }],
    nzSize: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzButtonComponent {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} renderer
     * @param {?} nzUpdateHostClassService
     */
    constructor(elementRef, cdr, renderer, nzUpdateHostClassService) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.renderer = renderer;
        this.nzUpdateHostClassService = nzUpdateHostClassService;
        this._ghost = false;
        this._search = false;
        this._loading = false;
        this.iconOnly = false;
        this.clicked = false;
        this.prefixCls = 'ant-btn';
        this.sizeMap = { large: 'lg', small: 'sm' };
        this.el = this.elementRef.nativeElement;
        this.renderer.addClass(this.el, this.prefixCls);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzGhost(value) {
        this._ghost = toBoolean(value);
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzGhost() {
        return this._ghost;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSearch(value) {
        this._search = toBoolean(value);
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzSearch() {
        return this._search;
    }
    /**
     * @return {?}
     */
    get nzType() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzType(value) {
        this._type = value;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzShape() {
        return this._shape;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShape(value) {
        this._shape = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this._size = value;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzLoading(value) {
        this._loading = toBoolean(value);
        this.setClassMap();
        this.updateIconDisplay(value);
    }
    /**
     * @return {?}
     */
    get nzLoading() {
        return this._loading;
    }
    /**
     * toggle button clicked animation
     * @return {?}
     */
    onClick() {
        this.clicked = true;
        this.setClassMap();
        setTimeout(() => {
            this.clicked = false;
            this.setClassMap();
        }, 300);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateIconDisplay(value) {
        if (this.iconElement) {
            this.renderer.setStyle(this.iconElement, 'display', value ? 'none' : 'inline-block');
        }
    }
    /**
     * temp solution since no method add classMap to host https://github.com/angular/angular/issues/7289
     * @return {?}
     */
    setClassMap() {
        const /** @type {?} */ classMap = {
            [`${this.prefixCls}-${this.nzType}`]: this.nzType,
            [`${this.prefixCls}-${this.nzShape}`]: this.nzShape,
            [`${this.prefixCls}-${this.sizeMap[this.nzSize]}`]: this.sizeMap[this.nzSize],
            [`${this.prefixCls}-loading`]: this.nzLoading,
            [`${this.prefixCls}-clicked`]: this.clicked,
            [`${this.prefixCls}-icon-only`]: this.iconOnly,
            [`${this.prefixCls}-background-ghost`]: this.nzGhost,
            [`ant-input-search-button`]: this.nzSearch
        };
        this.nzUpdateHostClassService.updateHostClass(this.el, classMap);
    }
    /**
     * @return {?}
     */
    checkContent() {
        this.moveIcon();
        this.renderer.removeStyle(this.contentElement.nativeElement, 'display');
        /** https://github.com/angular/angular/issues/12530 **/
        if (isEmpty(this.contentElement.nativeElement)) {
            this.renderer.setStyle(this.contentElement.nativeElement, 'display', 'none');
            this.iconOnly = !!this.iconElement;
        }
        else {
            this.renderer.removeStyle(this.contentElement.nativeElement, 'display');
            this.iconOnly = false;
        }
        this.setClassMap();
        this.updateIconDisplay(this.nzLoading);
        this.cdr.detectChanges();
    }
    /**
     * @return {?}
     */
    moveIcon() {
        const /** @type {?} */ firstChildElement = this.findFirstNotEmptyNode(this.contentElement.nativeElement);
        const /** @type {?} */ lastChildElement = this.findLastNotEmptyNode(this.contentElement.nativeElement);
        if (firstChildElement && (firstChildElement.nodeName === 'I')) {
            this.renderer.insertBefore(this.el, firstChildElement, this.contentElement.nativeElement);
            this.iconElement = /** @type {?} */ (firstChildElement);
        }
        else if (lastChildElement && (lastChildElement.nodeName === 'I')) {
            this.renderer.appendChild(this.el, lastChildElement);
            this.iconElement = /** @type {?} */ (lastChildElement);
        }
        else {
            this.iconElement = null;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    findFirstNotEmptyNode(value) {
        const /** @type {?} */ children = value.childNodes;
        for (let /** @type {?} */ i = 0; i < children.length; i++) {
            const /** @type {?} */ node = children.item(i);
            if (node && (node.nodeType === 1) && ((/** @type {?} */ (node)).outerHTML.toString().trim().length !== 0)) {
                return node;
            }
            else if (node && (node.nodeType === 3) && ((node.textContent.toString().trim().length !== 0))) {
                return node;
            }
        }
        return null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    findLastNotEmptyNode(value) {
        const /** @type {?} */ children = value.childNodes;
        for (let /** @type {?} */ i = children.length - 1; i >= 0; i--) {
            const /** @type {?} */ node = children.item(i);
            if (node && (node.nodeType === 1) && ((/** @type {?} */ (node)).outerHTML.toString().trim().length !== 0)) {
                return node;
            }
            else if (node && (node.nodeType === 3) && ((node.textContent.toString().trim().length !== 0))) {
                return node;
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.checkContent();
    }
}
NzButtonComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-button]',
                providers: [NzUpdateHostClassService],
                preserveWhitespaces: false,
                template: `<i class="anticon anticon-spin anticon-loading" *ngIf="nzLoading"></i> <span (cdkObserveContent)="checkContent()" #contentElement><ng-content></ng-content></span>`
            },] },
];
/** @nocollapse */
NzButtonComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: NzUpdateHostClassService }
];
NzButtonComponent.propDecorators = {
    contentElement: [{ type: ViewChild, args: ['contentElement',] }],
    nzGhost: [{ type: Input }],
    nzSearch: [{ type: Input }],
    nzType: [{ type: Input }],
    nzShape: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzLoading: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzButtonModule {
}
NzButtonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzButtonComponent, NzButtonGroupComponent],
                exports: [NzButtonComponent, NzButtonGroupComponent],
                imports: [CommonModule, ObserversModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LoggerService {
    /**
     * @param {?} _loggerState
     */
    constructor(_loggerState) {
        this._loggerState = _loggerState;
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    log(...args) {
        if (this._loggerState) {
            // console.log(...args);
            console.log.apply(console, arguments);
        }
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    warn(...args) {
        if (this._loggerState) {
            // console.warn(...args);
            console.warn.apply(console, arguments);
        }
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    error(...args) {
        if (this._loggerState) {
            // console.error(...args);
            console.error.apply(console, arguments);
        }
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    info(...args) {
        if (this._loggerState) {
            // console.log(...args);
            console.log.apply(console, arguments);
        }
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    debug(...args) {
        if (this._loggerState) {
            // console.log('[NG-ZORRO-DEBUG]', ...args);
            const /** @type {?} */ arrs = Array.prototype.slice.call(arguments);
            console.log.apply(console, ['[NG-ZORRO-DEBUG]'].concat(arrs));
        }
    }
}
LoggerService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
LoggerService.ctorParameters = () => [
    { type: Boolean, decorators: [{ type: Inject, args: [NZ_LOGGER_STATE,] }] }
];
const NZ_LOGGER_STATE = new InjectionToken('nz-logger-state');
/**
 * @param {?} exist
 * @param {?} loggerState
 * @return {?}
 */
function LOGGER_SERVICE_PROVIDER_FACTORY(exist, loggerState) { return exist || new LoggerService(loggerState); }
const LOGGER_SERVICE_PROVIDER = {
    provide: LoggerService,
    useFactory: LOGGER_SERVICE_PROVIDER_FACTORY,
    deps: [[new Optional(), new SkipSelf(), LoggerService], NZ_LOGGER_STATE]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class LoggerModule {
}
LoggerModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    { provide: NZ_LOGGER_STATE, useValue: false },
                    LOGGER_SERVICE_PROVIDER,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale = {
    today: '今天',
    now: '此刻',
    backToToday: '返回今天',
    ok: '确定',
    timeSelect: '选择时间',
    dateSelect: '选择日期',
    clear: '清除',
    month: '月',
    year: '年',
    previousMonth: '上个月 (翻页上键)',
    nextMonth: '下个月 (翻页下键)',
    monthSelect: '选择月份',
    yearSelect: '选择年份',
    decadeSelect: '选择年代',
    yearFormat: 'YYYY年',
    dayFormat: 'D日',
    dateFormat: 'YYYY年M月D日',
    dateTimeFormat: 'YYYY年M月D日 HH时mm分ss秒',
    previousYear: '上一年 (Control键加左方向键)',
    nextYear: '下一年 (Control键加右方向键)',
    previousDecade: '上一年代',
    nextDecade: '下一年代',
    previousCentury: '上一世纪',
    nextCentury: '下一世纪',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$1 = {
    placeholder: '请选择时间',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale = {
    lang: Object.assign({ placeholder: '请选择日期', rangePlaceholder: ['开始日期', '结束日期'] }, CalendarLocale),
    timePickerLocale: Object.assign({}, locale$1),
};
// should add whitespace between char in Button
locale.lang.ok = '确 定';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination = {
    // Options.jsx
    items_per_page: '条/页',
    jump_to: '跳至',
    jump_to_confirm: '确定',
    page: '页',
    // Pagination.jsx
    prev_page: '上一页',
    next_page: '下一页',
    prev_5: '向前 5 页',
    next_5: '向后 5 页',
    prev_3: '向前 3 页',
    next_3: '向后 3 页',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var zh_CN = {
    locale: 'zh-cn',
    Pagination,
    DatePicker: locale,
    TimePicker: locale$1,
    Calendar: CalendarLocale,
    Table: {
        filterTitle: '筛选',
        filterConfirm: '确定',
        filterReset: '重置',
        emptyText: '暂无数据',
        selectAll: '全选当页',
        selectInvert: '反选当页',
    },
    Modal: {
        okText: '确定',
        cancelText: '取消',
        justOkText: '知道了',
    },
    Popconfirm: {
        cancelText: '取消',
        okText: '确定',
    },
    Transfer: {
        notFoundContent: '无匹配结果',
        searchPlaceholder: '请输入搜索内容',
        itemUnit: '项',
        itemsUnit: '项',
    },
    Select: {
        notFoundContent: '无匹配结果',
    },
    Upload: {
        uploading: '文件上传中',
        removeFile: '删除文件',
        uploadError: '上传错误',
        previewFile: '预览文件',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const NZ_I18N = new InjectionToken('nz-i18n');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzI18nService {
    /**
     * @param {?} locale
     * @param {?} _logger
     * @param {?} datePipe
     */
    constructor(locale, _logger, datePipe) {
        this._logger = _logger;
        this.datePipe = datePipe;
        this._change = new BehaviorSubject(this._locale);
        this.setLocale(locale || zh_CN);
    }
    /**
     * @return {?}
     */
    get localeChange() {
        return this._change.asObservable();
    }
    /**
     * @param {?} path
     * @param {?=} data
     * @return {?}
     */
    translate(path, data) {
        // this._logger.debug(`[NzI18nService] Translating(${this._locale.locale}): ${path}`);
        let /** @type {?} */ content = /** @type {?} */ (this._getObjectPath(this._locale, path));
        if (typeof content === 'string') {
            if (data) {
                Object.keys(data).forEach((key) => content = content.replace(new RegExp(`%${key}%`, 'g'), data[key]));
            }
            return content;
        }
        return path;
    }
    /**
     * Set/Change current locale globally throughout the WHOLE application
     * [NOTE] If called at runtime, rendered interface may not change along with the locale change (because this do not trigger another render schedule)
     * @param {?} locale The translating letters
     * @return {?}
     */
    setLocale(locale) {
        if (this._locale && this._locale.locale === locale.locale) {
            return;
        }
        this._locale = locale;
        this._change.next(locale);
    }
    /**
     * @return {?}
     */
    getLocale() {
        return this._locale;
    }
    /**
     * @return {?}
     */
    getLocaleId() {
        return this._locale ? this._locale.locale : '';
    }
    /**
     * Get locale data
     * @param {?=} path dot paths for finding exist value from locale data, eg. "a.b.c"
     * @param {?=} defaultValue default value if the result is not "truthy"
     * @return {?}
     */
    getLocaleData(path, defaultValue) {
        // tslint:disable-line:no-any
        const /** @type {?} */ result = path ? this._getObjectPath(this._locale, path) : this._locale;
        return result || defaultValue;
    }
    /**
     * @param {?} date
     * @param {?=} format
     * @param {?=} locale
     * @return {?}
     */
    formatDate(date, format, locale) {
        return date ? this.datePipe.transform(date, format, null, locale || this.getLocale().locale) : '';
    }
    /**
     * Format date with compatible for the format of moment and others
     * Why? For now, we need to support the existing language formats in AntD, and AntD uses the default temporal syntax.
     * @param {?} date
     * @param {?=} format
     * @param {?=} locale
     * @return {?}
     */
    formatDateCompatible(date, format, locale) {
        return this.formatDate(date, this.compatDateFormat(format), locale);
    }
    /**
     * @param {?} text
     * @return {?}
     */
    parseDate(text) {
        if (!text) {
            return;
        }
        return parse(text);
    }
    /**
     * @param {?} text
     * @return {?}
     */
    parseTime(text) {
        if (!text) {
            return;
        }
        return parse(`1970-01-01 ${text}`);
    }
    /**
     * @param {?} obj
     * @param {?} path
     * @return {?}
     */
    _getObjectPath(obj, path) {
        // tslint:disable-line:no-any
        let /** @type {?} */ res = obj;
        const /** @type {?} */ paths = path.split('.');
        const /** @type {?} */ depth = paths.length;
        let /** @type {?} */ index = 0;
        while (res && index < depth) {
            res = res[paths[index++]];
        }
        return index === depth ? res : null;
    }
    /**
     * Compatible translate the moment-like format pattern to angular's pattern
     * Why? For now, we need to support the existing language formats in AntD, and AntD uses the default temporal syntax.
     *
     * TODO: compare and complete all format patterns
     * Each format docs as below:
     * @link https://momentjs.com/docs/#/displaying/format/
     * @link https://angular.io/api/common/DatePipe#description
     * @param {?} format input format pattern
     * @return {?}
     */
    compatDateFormat(format) {
        return format && format
            .replace(/Y/g, 'y') // only support y, yy, yyy, yyyy
            .replace(/D/g, 'd'); // d, dd represent of D, DD for momentjs, others are not support
    }
}
NzI18nService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NzI18nService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NZ_I18N,] }] },
    { type: LoggerService },
    { type: DatePipe }
];
/**
 * @param {?} exist
 * @param {?} locale
 * @param {?} logger
 * @param {?} datePipe
 * @return {?}
 */
function NZ_LOCALE_SERVICE_PROVIDER_FACTORY(exist, locale, logger, datePipe) {
    return exist || new NzI18nService(locale, logger, datePipe);
}
const NZ_I18N_SERVICE_PROVIDER = {
    provide: NzI18nService,
    useFactory: NZ_LOCALE_SERVICE_PROVIDER_FACTORY,
    deps: [[new Optional(), new SkipSelf(), NzI18nService], NZ_I18N, LoggerService, DatePipe]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzI18nPipe {
    /**
     * @param {?} _locale
     */
    constructor(_locale) {
        this._locale = _locale;
    }
    /**
     * @param {?} path
     * @param {?=} keyValue
     * @return {?}
     */
    transform(path, keyValue) {
        return this._locale.translate(path, keyValue);
    }
}
NzI18nPipe.decorators = [
    { type: Pipe, args: [{
                name: 'nzI18n'
            },] },
];
/** @nocollapse */
NzI18nPipe.ctorParameters = () => [
    { type: NzI18nService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ɵ0 = zh_CN;
class NzI18nModule {
}
NzI18nModule.decorators = [
    { type: NgModule, args: [{
                imports: [LoggerModule],
                declarations: [NzI18nPipe],
                exports: [NzI18nPipe],
                providers: [
                    { provide: NZ_I18N, useValue: ɵ0 },
                    DatePipe,
                    NZ_I18N_SERVICE_PROVIDER
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzRadioGroupComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this._size = 'default';
        // ngModel Access
        this.onChange = () => null;
        this.onTouched = () => null;
        this.radios = [];
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this._size = value;
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
        this.updateDisabledState();
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzName(value) {
        this._name = value;
        this.updateChildrenName();
    }
    /**
     * @return {?}
     */
    get nzName() {
        return this._name;
    }
    /**
     * @return {?}
     */
    updateDisabledState() {
        if (isNotNil(this.nzDisabled)) {
            this.radios.forEach((radio) => {
                radio.nzDisabled = this.nzDisabled;
            });
        }
    }
    /**
     * @return {?}
     */
    updateChildrenName() {
        if (this.nzName) {
            this.radios.forEach((item) => {
                item.name = this.nzName;
            });
        }
    }
    /**
     * @return {?}
     */
    syncCheckedValue() {
        this.radios.forEach((item) => {
            item.nzChecked = item.nzValue === this.value;
        });
    }
    /**
     * @return {?}
     */
    get isLarge() {
        return this.nzSize === 'large';
    }
    /**
     * @return {?}
     */
    get isSmall() {
        return this.nzSize === 'small';
    }
    /**
     * @param {?} radio
     * @return {?}
     */
    addRadio(radio) {
        this.radios.push(radio);
        radio.nzChecked = radio.nzValue === this.value;
    }
    /**
     * @param {?} radio
     * @return {?}
     */
    selectRadio(radio) {
        this.updateValue(radio.nzValue, true);
    }
    /**
     * @param {?} value
     * @param {?} emit
     * @return {?}
     */
    updateValue(value, emit) {
        this.value = value;
        this.syncCheckedValue();
        if (emit) {
            this.onChange(value);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.syncCheckedValue();
        this.updateChildrenName();
        Promise.resolve().then(() => {
            this.updateDisabledState();
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.updateValue(value, false);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
    }
}
NzRadioGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-radio-group',
                preserveWhitespaces: false,
                template: `<ng-content></ng-content>`,
                host: {
                    '[class.ant-radio-group]': 'true'
                },
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzRadioGroupComponent),
                        multi: true
                    }
                ]
            },] },
];
/** @nocollapse */
NzRadioGroupComponent.ctorParameters = () => [
    { type: ElementRef }
];
NzRadioGroupComponent.propDecorators = {
    nzSize: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzName: [{ type: Input }],
    isLarge: [{ type: HostBinding, args: ['class.ant-radio-group-large',] }],
    isSmall: [{ type: HostBinding, args: ['class.ant-radio-group-small',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzRadioComponent {
    /**
     * @param {?} nzRadioGroup
     * @param {?} renderer
     * @param {?} document
     */
    constructor(nzRadioGroup, renderer, document) {
        this.nzRadioGroup = nzRadioGroup;
        this.renderer = renderer;
        this.document = document;
        this._checked = false;
        this._disabled = false;
        this._autoFocus = false;
        this.isInit = false;
        this.prefixCls = 'ant-radio';
        this.onChange = () => null;
        this.onTouched = () => null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzChecked(value) {
        this._checked = toBoolean(value);
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzChecked() {
        return this._checked;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAutoFocus(value) {
        this._autoFocus = toBoolean(value);
        this.updateAutoFocus();
    }
    /**
     * @return {?}
     */
    get nzAutoFocus() {
        return this._autoFocus;
    }
    /**
     * @return {?}
     */
    updateAutoFocus() {
        if (this.isInit) {
            if (this.nzAutoFocus) {
                this.renderer.setAttribute(this.inputElement.nativeElement, 'autofocus', 'autofocus');
            }
            else {
                this.renderer.removeAttribute(this.inputElement.nativeElement, 'autofocus');
            }
        }
    }
    /**
     * @return {?}
     */
    updateInputFocus() {
        if (this.inputElement) {
            if (this.nzChecked) {
                if (this.document.activeElement.nodeName === 'BODY') {
                    this.inputElement.nativeElement.focus();
                }
            }
            else {
                this.inputElement.nativeElement.blur();
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        e.preventDefault();
        this.setClassMap();
        if (this.nzDisabled || this.nzChecked) {
            this.updateInputFocus();
            return;
        }
        else {
            if (this.nzRadioGroup) {
                this.nzRadioGroup.selectRadio(this);
            }
            else {
                this.updateValue(true);
            }
            this.updateInputFocus();
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.onTouched();
        if (this.nzRadioGroup) {
            this.nzRadioGroup.onTouched();
        }
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-checked`]: this.nzChecked,
            [`${this.prefixCls}-disabled`]: this.nzDisabled
        };
    }
    /**
     * @return {?}
     */
    focus() {
        this.inputElement.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    blur() {
        this.inputElement.nativeElement.blur();
        this.onBlur();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.nzRadioGroup) {
            this.nzRadioGroup.addRadio(this);
        }
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this.onChange(value);
        this.nzChecked = value;
        this.setClassMap();
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.nzChecked = value;
        this.setClassMap();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.isInit = true;
        this.updateAutoFocus();
        this.updateInputFocus();
    }
}
NzRadioComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-radio]',
                preserveWhitespaces: false,
                template: `<span [ngClass]="classMap"> <input #inputElement type="radio" class="ant-radio-input" [disabled]="nzDisabled" [(ngModel)]="nzChecked" (blur)="onBlur()" [attr.name]="name"> <span class="ant-radio-inner"></span> </span> <span><ng-content></ng-content></span>`,
                host: {
                    '[class.ant-radio-wrapper]': 'true',
                    '[class.ant-radio-wrapper-checked]': 'nzChecked',
                    '[class.ant-radio-wrapper-disabled]': 'nzDisabled'
                },
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzRadioComponent),
                        multi: true
                    }
                ]
            },] },
];
/** @nocollapse */
NzRadioComponent.ctorParameters = () => [
    { type: NzRadioGroupComponent, decorators: [{ type: Optional }] },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
NzRadioComponent.propDecorators = {
    inputElement: [{ type: ViewChild, args: ['inputElement',] }],
    nzValue: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzAutoFocus: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzRadioButtonComponent extends NzRadioComponent {
    constructor() {
        super(...arguments);
        this.prefixCls = 'ant-radio-button';
    }
}
NzRadioButtonComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-radio-button]',
                preserveWhitespaces: false,
                template: `<span [ngClass]="classMap"> <input type="radio" #inputElement class="ant-radio-button-input" [disabled]="nzDisabled" [(ngModel)]="nzChecked" (blur)="onBlur()" [attr.name]="name"> <span class="ant-radio-button-inner"></span> </span> <span><ng-content></ng-content></span>`,
                host: {
                    '[class.ant-radio-button-wrapper]': 'true',
                    '[class.ant-radio-button-wrapper-checked]': 'nzChecked',
                    '[class.ant-radio-button-wrapper-disabled]': 'nzDisabled'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzRadioModule {
}
NzRadioModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                exports: [NzRadioComponent, NzRadioButtonComponent, NzRadioGroupComponent],
                declarations: [NzRadioComponent, NzRadioButtonComponent, NzRadioGroupComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzOptionComponent {
    constructor() {
        this._disabled = false;
        this._customContent = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCustomContent(value) {
        this._customContent = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzCustomContent() {
        return this._customContent;
    }
}
NzOptionComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-option',
                template: `<ng-template> <ng-content></ng-content> </ng-template>`
            },] },
];
NzOptionComponent.propDecorators = {
    template: [{ type: ViewChild, args: [TemplateRef,] }],
    nzLabel: [{ type: Input }],
    nzValue: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzCustomContent: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzOptionLiComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.selected = false;
        this.active = false;
        this.nzShowActive = true;
        this.el = elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzActiveOption(value) {
        if (value) {
            this.active = this.compareWith(value.nzValue, this.nzOption.nzValue);
        }
        else {
            this.active = false;
        }
    }
    /**
     * @param {?} valueList
     * @return {?}
     */
    set nzListOfSelectedValue(valueList) {
        this.selected = isNotNil(valueList.find(v => this.compareWith(v, this.nzOption.nzValue)));
    }
}
NzOptionLiComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-option-li]',
                template: `<ng-container *ngIf="nzOption.nzCustomContent"> <ng-template [ngTemplateOutlet]="nzOption.template"></ng-template> </ng-container> <ng-container *ngIf="!nzOption.nzCustomContent"> {{nzOption.nzLabel}} </ng-container>`,
                host: {
                    '[class.ant-select-dropdown-menu-item]': 'true',
                    '[class.ant-select-dropdown-menu-item-selected]': 'selected && !nzOption.nzDisabled',
                    '[class.ant-select-dropdown-menu-item-disabled]': 'nzOption.nzDisabled',
                    '[class.ant-select-dropdown-menu-item-active]': 'active && !nzOption.nzDisabled && nzShowActive && !selected',
                    '[attr.unselectable]': '"unselectable"',
                    '[style.user-select]': '"none"'
                }
            },] },
];
/** @nocollapse */
NzOptionLiComponent.ctorParameters = () => [
    { type: ElementRef }
];
NzOptionLiComponent.propDecorators = {
    nzOption: [{ type: Input }],
    nzShowActive: [{ type: Input }],
    compareWith: [{ type: Input }],
    nzActiveOption: [{ type: Input }],
    nzListOfSelectedValue: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzOptionPipe {
    /**
     * @param {?} options
     * @param {?} input
     * @param {?} filterOption
     * @param {?} serverSearch
     * @return {?}
     */
    transform(options, input, filterOption, serverSearch) {
        if (serverSearch || !input) {
            return options;
        }
        else {
            return options.filter(o => filterOption(input, o));
        }
    }
}
NzOptionPipe.decorators = [
    { type: Pipe, args: [{ name: 'nzFilterOptionPipe' },] },
];
class NzSubOptionPipe {
    /**
     * @param {?} groups
     * @param {?} input
     * @param {?} filterOption
     * @param {?} serverSearch
     * @return {?}
     */
    transform(groups, input, filterOption, serverSearch) {
        if (serverSearch || !input) {
            return groups;
        }
        else {
            return groups.filter(g => {
                return g.listOfNzOptionComponent.some(o => filterOption(input, o));
            });
        }
    }
}
NzSubOptionPipe.decorators = [
    { type: Pipe, args: [{ name: 'nzSubFilterOptionPipe' },] },
];
/**
 * @param {?} input
 * @param {?} option
 * @return {?}
 */
function defaultFilterOption(input, option) {
    if (option && option.nzLabel) {
        return option.nzLabel.toLowerCase().indexOf(input.toLowerCase()) > -1;
    }
    else {
        return false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzOptionContainerComponent {
    constructor() {
        this.isInit = false;
        this.isAddTagOptionDisplay = false;
        this.listOfAllTemplateOption = [];
        this.listOfTagOption = [];
        this.listOfFilterOption = [];
        // tslint:disable-next-line:no-any
        this.nzListOfSelectedValueChange = new EventEmitter();
        this.nzListOfTemplateOptionChange = new EventEmitter();
        this.nzClickOption = new EventEmitter();
        this.nzScrollToBottom = new EventEmitter();
        this.nzMode = 'default';
        this.nzServerSearch = false;
        this.nzFilterOption = defaultFilterOption;
        this.nzMaxMultipleCount = Infinity;
        // tslint:disable-next-line:no-any
        this.compareWith = (o1, o2) => o1 === o2;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSearchValue(value) {
        this._searchValue = value;
        this.updateAddTagOptionDisplay();
        this.updateListOfFilterOption();
    }
    /**
     * @return {?}
     */
    get nzSearchValue() {
        return this._searchValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzListOfSelectedValue(value) {
        if (this._listOfSelectedValue !== value) {
            this._listOfSelectedValue = value;
            /** should clear activedOption when listOfSelectedValue change **/
            this.clearActivatedOption();
            this.refreshAllOptionStatus(false);
        }
    }
    /**
     * @return {?}
     */
    get nzListOfSelectedValue() {
        return this._listOfSelectedValue;
    }
    /**
     * @return {?}
     */
    addTagOption() {
        if (this.nzListOfSelectedValue.length < this.nzMaxMultipleCount) {
            this.nzListOfSelectedValue = [...this.nzListOfSelectedValue, this.nzSearchValue];
            this.nzListOfSelectedValueChange.emit(this.nzListOfSelectedValue);
        }
    }
    /**
     * @param {?} option
     * @param {?} isPressEnter
     * @return {?}
     */
    clickOption(option, isPressEnter) {
        this.updateSelectedOption(option, isPressEnter);
        this.nzClickOption.emit();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDownUl(e) {
        if ([38, 40, 13].indexOf(e.keyCode) > -1) {
            e.preventDefault();
            const /** @type {?} */ activeIndex = this.listOfFilterOption.findIndex(item => item === this.activatedOption);
            if (e.keyCode === 38) {
                // arrow up
                const /** @type {?} */ preIndex = activeIndex > 0 ? (activeIndex - 1) : (this.listOfFilterOption.length - 1);
                this.setActiveOption(this.listOfFilterOption[preIndex]);
            }
            else if (e.keyCode === 40) {
                // arrow down
                const /** @type {?} */ nextIndex = activeIndex < this.listOfFilterOption.length - 1 ? (activeIndex + 1) : 0;
                this.setActiveOption(this.listOfFilterOption[nextIndex]);
            }
            else if (e.keyCode === 13) {
                // enter
                if (this.isTagsMode) {
                    if (!this.isAddTagOptionDisplay) {
                        this.clickOption(this.activatedOption, true);
                    }
                    else {
                        this.addTagOption();
                        this.nzClickOption.emit();
                    }
                }
                else {
                    this.clickOption(this.activatedOption, true);
                }
            }
        }
    }
    /**
     * @return {?}
     */
    resetActiveOption() {
        const /** @type {?} */ firstActiveOption = this.listOfAllTemplateOption.concat(this.listOfTagOption).find(item => this.compareWith(item.nzValue, this.nzListOfSelectedValue[0]));
        this.setActiveOption(firstActiveOption);
    }
    /**
     * @return {?}
     */
    clearActivatedOption() {
        this.setActiveOption(null);
    }
    /**
     * @param {?} option
     * @param {?=} scroll
     * @return {?}
     */
    setActiveOption(option, scroll = true) {
        this.activatedOption = option;
        if (scroll) {
            this.scrollIntoView();
        }
    }
    /**
     * @return {?}
     */
    scrollIntoView() {
        if (this.listOfNzOptionLiComponent && this.listOfNzOptionLiComponent.length) {
            const /** @type {?} */ targetOption = this.listOfNzOptionLiComponent.find(o => o.nzOption === this.activatedOption);
            /* tslint:disable-next-line:no-string-literal */
            if (targetOption && targetOption.el && targetOption.el['scrollIntoViewIfNeeded']) {
                /* tslint:disable-next-line:no-string-literal */
                setTimeout(() => targetOption.el['scrollIntoViewIfNeeded'](false), 150);
            }
        }
    }
    /**
     * @param {?} option
     * @param {?} isPressEnter
     * @return {?}
     */
    updateSelectedOption(option, isPressEnter) {
        /** update listOfSelectedOption -> update nzListOfSelectedValue -> emit nzListOfSelectedValueChange **/
        if (option && !option.nzDisabled) {
            let /** @type {?} */ changed = false;
            this.setActiveOption(option);
            let /** @type {?} */ listOfSelectedValue = [...this.nzListOfSelectedValue];
            if (this.isMultipleOrTags) {
                const /** @type {?} */ targetValue = listOfSelectedValue.find(o => this.compareWith(o, option.nzValue));
                if (isNotNil(targetValue)) {
                    if (!isPressEnter) {
                        /** should not toggle option when press enter **/
                        listOfSelectedValue.splice(listOfSelectedValue.indexOf(targetValue), 1);
                        changed = true;
                    }
                }
                else if (this.nzListOfSelectedValue.length < this.nzMaxMultipleCount) {
                    listOfSelectedValue.push(option.nzValue);
                    changed = true;
                }
            }
            else if (!this.compareWith(listOfSelectedValue[0], option.nzValue)) {
                listOfSelectedValue = [option.nzValue];
                changed = true;
            }
            /** update selectedValues when click option **/
            if (changed) {
                this._listOfSelectedValue = listOfSelectedValue;
                this.nzListOfSelectedValueChange.emit(this.nzListOfSelectedValue);
                if (this.isTagsMode) {
                    this.refreshAllOptionStatus(false);
                }
            }
        }
    }
    /**
     * @return {?}
     */
    refreshListOfTagOption() {
        if (this.isTagsMode) {
            /**
             * refresh tags option *
             */
            const /** @type {?} */ listOfTagsOption = [];
            this.nzListOfSelectedValue.forEach(value => {
                const /** @type {?} */ existedOption = this.listOfAllTemplateOption.find(o => this.compareWith(o.nzValue, value));
                if (!existedOption) {
                    const /** @type {?} */ nzOptionComponent = new NzOptionComponent();
                    nzOptionComponent.nzValue = value;
                    nzOptionComponent.nzLabel = value;
                    listOfTagsOption.push(nzOptionComponent);
                }
            });
            this.listOfTagOption = listOfTagsOption;
        }
    }
    /**
     * @return {?}
     */
    refreshListOfAllTemplateOption() {
        this.listOfAllTemplateOption = this.listOfNzOptionComponent.toArray().concat(this.listOfNzOptionGroupComponent.toArray().reduce((pre, cur) => [...pre, ...cur.listOfNzOptionComponent.toArray()], []));
        Promise.resolve().then(() => this.nzListOfTemplateOptionChange.emit(this.listOfAllTemplateOption));
    }
    /**
     * @param {?} isTemplateOptionChange
     * @return {?}
     */
    refreshAllOptionStatus(isTemplateOptionChange) {
        /** update nzListOfSelectedValue | update option list -> update listOfAllTemplateOption -> update listOfSelectedOption -> update activatedOption **/
        if (this.isInit) {
            if (isTemplateOptionChange) {
                this.refreshListOfAllTemplateOption();
            }
            this.refreshListOfTagOption();
            this.updateListOfFilterOption();
            this.updateAddTagOptionDisplay();
        }
    }
    /**
     * @return {?}
     */
    updateListOfFilterOption() {
        this.listOfFilterOption = new NzOptionPipe().transform(this.listOfAllTemplateOption.concat(this.listOfTagOption), this.nzSearchValue, this.nzFilterOption, this.nzServerSearch);
        if (this.nzSearchValue) {
            this.setActiveOption(this.listOfFilterOption[0]);
        }
    }
    /**
     * watch options change in option group *
     * @return {?}
     */
    watchSubOptionChanges() {
        this.unsubscribeOption();
        let /** @type {?} */ optionChanges$ = merge(new Subject().asObservable(), this.listOfNzOptionGroupComponent.changes, this.listOfNzOptionComponent.changes);
        if (this.listOfNzOptionGroupComponent.length) {
            this.listOfNzOptionGroupComponent.forEach(group => optionChanges$ = group.listOfNzOptionComponent ? merge(group.listOfNzOptionComponent.changes, optionChanges$) : optionChanges$);
        }
        this.optionSubscription = optionChanges$.subscribe(() => this.refreshAllOptionStatus(true));
    }
    /**
     * @return {?}
     */
    unsubscribeGroup() {
        if (this.groupSubscription) {
            this.groupSubscription.unsubscribe();
            this.groupSubscription = null;
        }
    }
    /**
     * @return {?}
     */
    unsubscribeOption() {
        if (this.optionSubscription) {
            this.optionSubscription.unsubscribe();
            this.optionSubscription = null;
        }
    }
    /**
     * @return {?}
     */
    get isTagsMode() {
        return this.nzMode === 'tags';
    }
    /**
     * @return {?}
     */
    get isMultipleOrTags() {
        return this.nzMode === 'tags' || this.nzMode === 'multiple';
    }
    /**
     * @return {?}
     */
    get isNotFoundDisplay() {
        return (!this.isTagsMode) && (!this.listOfFilterOption.length);
    }
    /**
     * @return {?}
     */
    updateAddTagOptionDisplay() {
        const /** @type {?} */ listOfAllOption = this.listOfAllTemplateOption.concat(this.listOfTagOption).map(item => item.nzLabel);
        const /** @type {?} */ isMatch = listOfAllOption.indexOf(this.nzSearchValue) > -1;
        this.isAddTagOptionDisplay = this.isTagsMode && this.nzSearchValue && (!isMatch);
    }
    /**
     * @param {?} e
     * @param {?} ul
     * @return {?}
     */
    dropDownScroll(e, ul) {
        e.preventDefault();
        e.stopPropagation();
        if (ul && (ul.scrollHeight - ul.scrollTop === ul.clientHeight)) {
            this.nzScrollToBottom.emit();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.isInit = true;
        this.refreshAllOptionStatus(true);
        this.watchSubOptionChanges();
        this.groupSubscription = this.listOfNzOptionGroupComponent.changes.subscribe(() => this.watchSubOptionChanges());
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribeGroup();
        this.unsubscribeOption();
    }
}
NzOptionContainerComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-option-container]',
                preserveWhitespaces: false,
                template: `<ul #dropdownUl class="ant-select-dropdown-menu ant-select-dropdown-menu-root ant-select-dropdown-menu-vertical" role="menu" (keydown)="onKeyDownUl($event)" (scroll)="dropDownScroll($event,dropdownUl)" tabindex="0"> <li *ngIf="isNotFoundDisplay" nz-select-unselectable class="ant-select-dropdown-menu-item ant-select-dropdown-menu-item-disabled"> {{ nzNotFoundContent ? nzNotFoundContent : ('Select.notFoundContent' | nzI18n) }} </li> <li *ngIf="isAddTagOptionDisplay" nz-select-unselectable (click)="addTagOption()" class="ant-select-dropdown-menu-item ant-select-dropdown-menu-item-active"> {{ nzSearchValue }} </li> <li nz-option-li [compareWith]="compareWith" *ngFor="let option of listOfNzOptionComponent | nzFilterOptionPipe : nzSearchValue : nzFilterOption : nzServerSearch " (click)="clickOption(option,false)" [nzActiveOption]="activatedOption" [nzOption]="option" [nzListOfSelectedValue]="nzListOfSelectedValue"> </li> <li *ngFor="let group of listOfNzOptionGroupComponent | nzSubFilterOptionPipe : nzSearchValue : nzFilterOption : nzServerSearch" class="ant-select-dropdown-menu-item-group"> <div class="ant-select-dropdown-menu-item-group-title" [attr.title]="group.isLabelString ? group.nzLabel : ''"> <ng-container *ngIf="group.isLabelString; else labelTemplate">{{ group.nzLabel }}</ng-container> <ng-template #labelTemplate> <ng-template [ngTemplateOutlet]="group.nzLabel"></ng-template> </ng-template> </div> <ul class="ant-select-dropdown-menu-item-group-list"> <li nz-option-li [compareWith]="compareWith" *ngFor="let option of group.listOfNzOptionComponent | nzFilterOptionPipe : nzSearchValue : nzFilterOption : nzServerSearch" (click)="clickOption(option,false)" [nzActiveOption]="activatedOption" [nzShowActive]="!isAddTagOptionDisplay" [nzOption]="option" [nzListOfSelectedValue]="nzListOfSelectedValue"> </li> </ul> </li> <li nz-option-li [compareWith]="compareWith" *ngFor="let option of listOfTagOption | nzFilterOptionPipe : nzSearchValue : nzFilterOption : nzServerSearch " (click)="clickOption(option,false)" [nzActiveOption]="activatedOption" [nzShowActive]="!isAddTagOptionDisplay" [nzOption]="option" [nzListOfSelectedValue]="nzListOfSelectedValue"> </li> </ul>`
            },] },
];
NzOptionContainerComponent.propDecorators = {
    listOfNzOptionLiComponent: [{ type: ViewChildren, args: [NzOptionLiComponent,] }],
    listOfNzOptionComponent: [{ type: Input }],
    listOfNzOptionGroupComponent: [{ type: Input }],
    nzListOfSelectedValueChange: [{ type: Output }],
    nzListOfTemplateOptionChange: [{ type: Output }],
    nzClickOption: [{ type: Output }],
    nzScrollToBottom: [{ type: Output }],
    nzMode: [{ type: Input }],
    nzServerSearch: [{ type: Input }],
    nzFilterOption: [{ type: Input }],
    nzMaxMultipleCount: [{ type: Input }],
    nzNotFoundContent: [{ type: Input }],
    compareWith: [{ type: Input }],
    nzSearchValue: [{ type: Input }],
    nzListOfSelectedValue: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzOptionGroupComponent {
    /**
     * @param {?} value
     * @return {?}
     */
    set nzLabel(value) {
        this.isLabelString = !(value instanceof TemplateRef);
        this._label = value;
    }
    /**
     * @return {?}
     */
    get nzLabel() {
        return this._label;
    }
}
NzOptionGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-option-group',
                template: `<ng-content></ng-content>`
            },] },
];
NzOptionGroupComponent.propDecorators = {
    listOfNzOptionComponent: [{ type: ContentChildren, args: [NzOptionComponent,] }],
    nzLabel: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSelectTopControlComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this._listTemplateOfOption = [];
        this.listOfCachedSelectedOption = [];
        this.isComposing = false;
        // tslint:disable-next-line:no-any
        this.nzListOfSelectedValueChange = new EventEmitter();
        this.nzOnSearch = new EventEmitter();
        this.nzMode = 'default';
        this.nzShowSearch = false;
        this.nzDisabled = false;
        this.nzOpen = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzListOfSelectedValue(value) {
        this._listOfSelectedValue = value;
        this.updateListOfCachedOption();
    }
    /**
     * @return {?}
     */
    get nzListOfSelectedValue() {
        return this._listOfSelectedValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzListTemplateOfOption(value) {
        this._listTemplateOfOption = value;
        this.updateListOfCachedOption();
    }
    /**
     * @return {?}
     */
    get nzListTemplateOfOption() {
        return this._listTemplateOfOption;
    }
    /**
     * cached selected option list *
     * @return {?}
     */
    updateListOfCachedOption() {
        if (this.isSingleMode) {
            const /** @type {?} */ selectedOption = this.nzListTemplateOfOption.find(o => this.compareWith(o.nzValue, this.nzListOfSelectedValue[0]));
            if (isNotNil(selectedOption)) {
                this.listOfCachedSelectedOption = [selectedOption];
            }
        }
        else {
            const /** @type {?} */ listOfCachedOptionFromLatestTemplate = this.nzListTemplateOfOption.filter(o => isNotNil(this.nzListOfSelectedValue.find(v => this.compareWith(v, o.nzValue))));
            const /** @type {?} */ restSelectedValue = this.nzListOfSelectedValue.filter(v => !isNotNil(listOfCachedOptionFromLatestTemplate.find(o => this.compareWith(o.nzValue, v))));
            const /** @type {?} */ listOfCachedOptionFromOld = this.listOfCachedSelectedOption.filter(o => isNotNil(restSelectedValue.find(v => this.compareWith(o.nzValue, v))));
            this.listOfCachedSelectedOption = listOfCachedOptionFromLatestTemplate.concat(listOfCachedOptionFromOld);
        }
    }
    /**
     * @param {?} value
     * @param {?} emit
     * @return {?}
     */
    setInputValue(value, emit) {
        this.inputValue = value;
        this.updateWidth();
        this.nzOnSearch.emit({ value, emit });
    }
    /**
     * @return {?}
     */
    get isSingleMode() {
        return this.nzMode === 'default';
    }
    /**
     * @return {?}
     */
    get isMultipleOrTags() {
        return this.nzMode === 'tags' || this.nzMode === 'multiple';
    }
    /**
     * @return {?}
     */
    get placeHolderDisplay() {
        return this.inputValue || this.isComposing || this.nzListOfSelectedValue.length ? 'none' : 'block';
    }
    /**
     * @return {?}
     */
    get selectedValueDisplay() {
        let /** @type {?} */ showSelectedValue = false;
        let /** @type {?} */ opacity = 1;
        if (!this.nzShowSearch) {
            showSelectedValue = true;
        }
        else {
            if (this.nzOpen) {
                showSelectedValue = !(this.inputValue || this.isComposing);
                if (showSelectedValue) {
                    opacity = 0.4;
                }
            }
            else {
                showSelectedValue = true;
            }
        }
        return {
            display: showSelectedValue ? 'block' : 'none',
            opacity: `${opacity}`
        };
    }
    /**
     * @return {?}
     */
    get singleValueLabel() {
        return this.getPropertyFromValue(this.nzListOfSelectedValue[0], 'nzLabel');
    }
    /**
     * @return {?}
     */
    focusOnInput() {
        setTimeout(() => {
            if (this.inputElement) {
                this.inputElement.nativeElement.focus();
            }
        });
    }
    /**
     * @param {?} value
     * @param {?} prop
     * @return {?}
     */
    getPropertyFromValue(value, prop) {
        const /** @type {?} */ targetOption = this.listOfCachedSelectedOption.find(item => this.compareWith(item.nzValue, value));
        return targetOption ? targetOption[prop] : '';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isOptionDisplay(value) {
        return (this.nzMode === 'tags') || !!this.getPropertyFromValue(value, 'nzLabel');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    removeValueFormSelected(value) {
        if (this.nzDisabled || this.getPropertyFromValue(value, 'nzDisabled')) {
            return;
        }
        this._listOfSelectedValue = this.nzListOfSelectedValue.filter(item => item !== value);
        this.nzListOfSelectedValueChange.emit(this.nzListOfSelectedValue);
    }
    /**
     * @return {?}
     */
    updateWidth() {
        if (this.isMultipleOrTags && this.inputElement) {
            if (this.inputValue || this.isComposing) {
                this.renderer.setStyle(this.inputElement.nativeElement, 'width', `${this.inputElement.nativeElement.scrollWidth}px`);
            }
            else {
                this.renderer.removeStyle(this.inputElement.nativeElement, 'width');
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDownInput(e) {
        const /** @type {?} */ keyCode = e.keyCode;
        const /** @type {?} */ eventTarget = /** @type {?} */ (e.target);
        if (this.isMultipleOrTags &&
            !eventTarget.value &&
            // BackSpace
            keyCode === 8) {
            e.preventDefault();
            if (this.nzListOfSelectedValue.length) {
                this.removeValueFormSelected(this.nzListOfSelectedValue[this.nzListOfSelectedValue.length - 1]);
            }
        }
    }
}
NzSelectTopControlComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-select-top-control]',
                preserveWhitespaces: false,
                animations: [
                    trigger('tagAnimation', [
                        state('*', style({ opacity: 1, transform: 'scale(1)' })),
                        transition('void => *', [
                            style({ opacity: 0, transform: 'scale(0)' }),
                            animate('150ms linear')
                        ]),
                        state('void', style({ opacity: 0, transform: 'scale(0)' })),
                        transition('* => void', [
                            style({ opacity: 1, transform: 'scale(1)' }),
                            animate('150ms linear')
                        ])
                    ])
                ],
                template: `<ng-template #inputTemplate> <input #inputElement autocomplete="something-new" class="ant-select-search__field" (compositionstart)="isComposing = true" (compositionend)="isComposing = false" (input)="updateWidth()" (keydown)="onKeyDownInput($event)" [ngModel]="inputValue" (ngModelChange)="setInputValue($event,true)" [disabled]="nzDisabled"> </ng-template> <div *ngIf="nzPlaceHolder" nz-select-unselectable [style.display]="placeHolderDisplay" (click)="focusOnInput()" class="ant-select-selection__placeholder">{{ nzPlaceHolder }}</div> <!--single mode--> <ng-container *ngIf="isSingleMode"> <!--selected label--> <div *ngIf="nzListOfSelectedValue.length" class="ant-select-selection-selected-value" [attr.title]="nzListOfSelectedValue[0].nzLabel" [ngStyle]="selectedValueDisplay"> {{ singleValueLabel }} </div> <!--show search--> <div *ngIf="nzShowSearch" class="ant-select-search ant-select-search--inline"> <div class="ant-select-search__field__wrap"> <ng-template [ngTemplateOutlet]="inputTemplate"></ng-template> <span class="ant-select-search__field__mirror">{{inputValue}}&nbsp;</span> </div> </div> </ng-container> <!--multiple or tags mode--> <ul *ngIf="isMultipleOrTags"> <ng-container *ngFor="let value of nzListOfSelectedValue"> <li *ngIf="isOptionDisplay(value)" [@tagAnimation] [attr.title]="getPropertyFromValue(value,'nzLabel')" [class.ant-select-selection__choice__disabled]="getPropertyFromValue(value,'nzDisabled')" class="ant-select-selection__choice"> <div class="ant-select-selection__choice__content">{{ getPropertyFromValue(value, 'nzLabel') || value }}</div> <span *ngIf="!getPropertyFromValue(value,'nzDisabled')" class="ant-select-selection__choice__remove" (click)="removeValueFormSelected(value)"></span> </li> </ng-container> <li class="ant-select-search ant-select-search--inline"> <ng-template [ngTemplateOutlet]="inputTemplate"></ng-template> </li> </ul>`,
                host: {
                    '[class.ant-select-selection__rendered]': 'true'
                }
            },] },
];
/** @nocollapse */
NzSelectTopControlComponent.ctorParameters = () => [
    { type: Renderer2 }
];
NzSelectTopControlComponent.propDecorators = {
    inputElement: [{ type: ViewChild, args: ['inputElement',] }],
    nzListOfSelectedValueChange: [{ type: Output }],
    nzOnSearch: [{ type: Output }],
    nzMode: [{ type: Input }],
    nzShowSearch: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzPlaceHolder: [{ type: Input }],
    nzOpen: [{ type: Input }],
    compareWith: [{ type: Input }],
    nzListOfSelectedValue: [{ type: Input }],
    nzListTemplateOfOption: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSelectUnselectableDirective {
}
NzSelectUnselectableDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-select-unselectable]',
                host: {
                    '[attr.unselectable]': '"unselectable"',
                    '[style.user-select]': '"none"'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSelectComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this._disabled = false;
        this._allowClear = false;
        this._showSearch = false;
        this._open = false;
        this._autoFocus = false;
        this.onChange = () => null;
        this.onTouched = () => null;
        this.dropDownPosition = 'bottom';
        // tslint:disable-next-line:no-any
        this.listOfSelectedValue = [];
        this.listOfTemplateOption = [];
        this.searchValue = '';
        this.isDestroy = true;
        this.isInit = false;
        this.nzOnSearch = new EventEmitter();
        this.nzScrollToBottom = new EventEmitter();
        this.nzOpenChange = new EventEmitter();
        this.nzSize = 'default';
        this.nzServerSearch = false;
        this.nzMode = 'default';
        this.nzDropdownMatchSelectWidth = true;
        this.nzFilterOption = defaultFilterOption;
        this.nzMaxMultipleCount = Infinity;
        /**
         * https://github.com/angular/angular/pull/13349/files *
         */
        this.compareWith = (o1, o2) => o1 === o2;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDropdownClassName(value) {
        this._dropdownClassName = value;
        this.updateDropDownClassMap();
    }
    /**
     * @return {?}
     */
    get nzDropdownClassName() {
        return this._dropdownClassName;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAutoFocus(value) {
        this._autoFocus = toBoolean(value);
        this.updateAutoFocus();
    }
    /**
     * @return {?}
     */
    get nzAutoFocus() {
        return this._autoFocus;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzOpen(value) {
        this._open = value;
        this.handleEscBug();
        this.updateCdkConnectedOverlayStatus();
        this.updateDropDownClassMap();
        if (this.nzOpen) {
            if (this.nzSelectTopControlComponent) {
                this.nzSelectTopControlComponent.focusOnInput();
                this.nzSelectTopControlComponent.setInputValue('', true);
            }
            if (this.nzOptionContainerComponent) {
                this.nzOptionContainerComponent.scrollIntoView();
            }
            if (this.cdkConnectedOverlay && this.cdkConnectedOverlay.overlayRef) {
                this.cdkConnectedOverlay.overlayRef.updatePosition();
                const /** @type {?} */ backdropElement = this.cdkConnectedOverlay.overlayRef.backdropElement;
                const /** @type {?} */ parentNode = this.renderer.parentNode(backdropElement);
                const /** @type {?} */ hostElement = this.cdkConnectedOverlay.overlayRef.hostElement;
                this.renderer.appendChild(parentNode, backdropElement);
                this.renderer.appendChild(parentNode, hostElement);
            }
        }
        else {
            if (this.nzSelectTopControlComponent) {
                this.nzSelectTopControlComponent.setInputValue('', false);
            }
            if (this.nzOptionContainerComponent) {
                this.nzOptionContainerComponent.resetActiveOption();
            }
        }
    }
    /**
     * @return {?}
     */
    get nzOpen() {
        return this._open;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
        if (this.nzDisabled) {
            this.closeDropDown();
        }
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAllowClear(value) {
        this._allowClear = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzAllowClear() {
        return this._allowClear;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowSearch(value) {
        this._showSearch = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowSearch() {
        return this._showSearch;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPlaceHolder(value) {
        this._placeholder = value;
    }
    /**
     * @return {?}
     */
    get nzPlaceHolder() {
        return this._placeholder;
    }
    /**
     * @return {?}
     */
    onClick() {
        if (!this.nzDisabled) {
            this.nzOpen = !this.nzOpen;
            this.nzOpenChange.emit(this.nzOpen);
        }
    }
    /**
     * @return {?}
     */
    updateAutoFocus() {
        if (this.isInit && this.nzSelectTopControlComponent.inputElement) {
            if (this.nzAutoFocus) {
                this.renderer.setAttribute(this.nzSelectTopControlComponent.inputElement.nativeElement, 'autofocus', 'autofocus');
            }
            else {
                this.renderer.removeAttribute(this.nzSelectTopControlComponent.inputElement.nativeElement, 'autofocus');
            }
        }
    }
    /**
     * @return {?}
     */
    focus() {
        if (this.nzSelectTopControlComponent.inputElement) {
            this.nzSelectTopControlComponent.inputElement.nativeElement.focus();
        }
    }
    /**
     * @return {?}
     */
    blur() {
        if (this.nzSelectTopControlComponent.inputElement) {
            this.nzSelectTopControlComponent.inputElement.nativeElement.blur();
        }
    }
    /**
     * overlay can not be always open , reopen overlay after press esc *
     * @return {?}
     */
    handleEscBug() {
        if (this.nzOpen && this.cdkConnectedOverlay && this.cdkConnectedOverlay.overlayRef && !this.cdkConnectedOverlay.overlayRef.backdropElement) {
            this.cdkConnectedOverlay.open = true;
            this.cdkConnectedOverlay.ngOnChanges({ open: new SimpleChange(false, true, false) });
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDownCdkOverlayOrigin(e) {
        if (this.nzOptionContainerComponent) {
            this.nzOptionContainerComponent.onKeyDownUl(e);
        }
    }
    /**
     * @return {?}
     */
    closeDropDown() {
        if (this.nzOpen) {
            this.onTouched();
            this.nzOpen = false;
            this.nzOpenChange.emit(this.nzOpen);
        }
    }
    /**
     * @param {?} position
     * @return {?}
     */
    onPositionChange(position) {
        this.dropDownPosition = position.connectionPair.originY;
        this.updateDropDownClassMap();
    }
    /**
     * @return {?}
     */
    onClickOptionFromOptionContainer() {
        if (this.isSingleMode) {
            this.closeDropDown();
        }
        else if (this.nzMode === 'tags') {
            this.onSearch('', true);
        }
    }
    /**
     * @return {?}
     */
    updateCdkConnectedOverlayStatus() {
        if (this.isInit && this.nzOpen && this.cdkOverlayOrigin) {
            if (this.nzDropdownMatchSelectWidth) {
                this.overlayWidth = this.cdkOverlayOrigin.elementRef.nativeElement.getBoundingClientRect().width;
                this.cdkConnectedOverlay.overlayRef.updateSize({ width: this.overlayWidth });
            }
            else {
                this.overlayMinWidth = this.cdkOverlayOrigin.elementRef.nativeElement.getBoundingClientRect().width;
                this.cdkConnectedOverlay.overlayRef.updateSize({ minWidth: this.overlayMinWidth });
            }
        }
        this.updateCdkConnectedOverlayPositions();
        if (this.cdkConnectedOverlay && this.cdkConnectedOverlay.overlayRef && this.cdkConnectedOverlay.overlayRef.backdropElement) {
            if (this.nzOpen) {
                this.renderer.removeStyle(this.cdkConnectedOverlay.overlayRef.backdropElement, 'display');
            }
            else {
                this.renderer.setStyle(this.cdkConnectedOverlay.overlayRef.backdropElement, 'display', 'none');
            }
        }
    }
    /**
     * @return {?}
     */
    updateCdkConnectedOverlayPositions() {
        /** wait for input size change **/
        setTimeout(() => this.cdkConnectedOverlay.overlayRef.updatePosition(), 160);
    }
    /**
     * @return {?}
     */
    get isSingleMode() {
        return this.nzMode === 'default';
    }
    /**
     * @return {?}
     */
    get isMultipleOrTags() {
        return this.nzMode === 'tags' || this.nzMode === 'multiple';
    }
    /**
     * option container nzListOfSelectedValueChange -> update ngModel *
     * @param {?} value
     * @return {?}
     */
    updateListOfSelectedValueFromOptionContainer(value) {
        this.clearSearchValue();
        this.updateFromSelectedList(value);
    }
    /**
     * option container nzListOfSelectedValueChange -> update ngModel *
     * @param {?} value
     * @return {?}
     */
    updateListOfSelectedValueFromTopControl(value) {
        this.clearSearchValue();
        this.updateFromSelectedList(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateFromSelectedList(value) {
        let /** @type {?} */ modelValue;
        if (this.isSingleMode) {
            if (value.length) {
                modelValue = value[0];
            }
        }
        else {
            modelValue = value;
            this.updateCdkConnectedOverlayPositions();
        }
        this.updateNgModel(value, modelValue);
    }
    /**
     * @param {?} value
     * @param {?} emit
     * @return {?}
     */
    onSearch(value, emit) {
        if (emit && (this.searchValue !== value)) {
            this.nzOnSearch.emit(value);
            this.searchValue = value;
        }
    }
    /**
     * @return {?}
     */
    clearNgModel() {
        if (this.isSingleMode) {
            this.updateNgModel([], null);
        }
        else {
            this.updateNgModel([], []);
        }
    }
    /**
     * @param {?} list
     * @param {?} value
     * @return {?}
     */
    updateNgModel(list, value) {
        this.listOfSelectedValue = list;
        if (value !== this.value) {
            this.value = value;
            this.onChange(this.value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    listOfTemplateOptionChange(value) {
        this.listOfTemplateOption = value;
    }
    /**
     * @return {?}
     */
    updateDropDownClassMap() {
        this.dropDownClassMap = {
            ['ant-select-dropdown']: true,
            [`ant-select-dropdown--single`]: this.isSingleMode,
            [`ant-select-dropdown--multiple`]: this.isMultipleOrTags,
            [`ant-select-dropdown-placement-bottomLeft`]: this.dropDownPosition === 'bottom',
            [`ant-select-dropdown-placement-topLeft`]: this.dropDownPosition === 'top',
            [`${this.nzDropdownClassName}`]: !!this.nzDropdownClassName
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClearSelection(e) {
        // TODO: should not clear disabled option ?
        e.stopPropagation();
        this.clearNgModel();
    }
    /**
     * @return {?}
     */
    clearSearchValue() {
        if (this.isSingleMode) {
            this.nzSelectTopControlComponent.setInputValue('', false);
        }
        else {
            this.nzSelectTopControlComponent.setInputValue('', false);
        }
    }
    /**
     * update ngModel -> update listOfSelectedValue *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
        if (isNotNil(value)) {
            if (Array.isArray(value)) {
                this.listOfSelectedValue = value;
            }
            else {
                this.listOfSelectedValue = [value];
            }
        }
        else {
            this.listOfSelectedValue = [];
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isDestroy = false;
        this.updateDropDownClassMap();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.isInit = true;
        Promise.resolve().then(() => this.updateCdkConnectedOverlayStatus());
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.isDestroy = true;
    }
}
NzSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-select',
                preserveWhitespaces: false,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzSelectComponent),
                        multi: true
                    }
                ],
                animations: [
                    trigger('dropDownAnimation', [
                        state('hidden', style({
                            opacity: 0,
                            display: 'none'
                        })),
                        state('bottom', style({
                            opacity: 1,
                            transform: 'scaleY(1)',
                            transformOrigin: '0% 0%'
                        })),
                        state('top', style({
                            opacity: 1,
                            transform: 'scaleY(1)',
                            transformOrigin: '0% 100%'
                        })),
                        transition('hidden => bottom', [
                            style({
                                opacity: 0,
                                transform: 'scaleY(0.8)',
                                transformOrigin: '0% 0%'
                            }),
                            animate('100ms cubic-bezier(0.755, 0.05, 0.855, 0.06)')
                        ]),
                        transition('bottom => hidden', [
                            animate('100ms cubic-bezier(0.755, 0.05, 0.855, 0.06)', style({
                                opacity: 0,
                                transform: 'scaleY(0.8)',
                                transformOrigin: '0% 0%'
                            }))
                        ]),
                        transition('hidden => top', [
                            style({
                                opacity: 0,
                                transform: 'scaleY(0.8)',
                                transformOrigin: '0% 100%'
                            }),
                            animate('100ms cubic-bezier(0.755, 0.05, 0.855, 0.06)')
                        ]),
                        transition('top => hidden', [
                            animate('100ms cubic-bezier(0.755, 0.05, 0.855, 0.06)', style({
                                opacity: 0,
                                transform: 'scaleY(0.8)',
                                transformOrigin: '0% 100%'
                            }))
                        ])
                    ])
                ],
                template: `<div cdkOverlayOrigin class="ant-select-selection" [class.ant-select-selection--single]="isSingleMode" [class.ant-select-selection--multiple]="isMultipleOrTags" (keydown)="onKeyDownCdkOverlayOrigin($event)" tabindex="0"> <div nz-select-top-control [nzOpen]="nzOpen" [compareWith]="compareWith" [nzPlaceHolder]="nzPlaceHolder" [nzShowSearch]="nzShowSearch" [nzDisabled]="nzDisabled" [nzMode]="nzMode" [nzListTemplateOfOption]="listOfTemplateOption" [nzListOfSelectedValue]="listOfSelectedValue" (nzOnSearch)="onSearch($event.value,$event.emit)" (nzListOfSelectedValueChange)="updateListOfSelectedValueFromTopControl($event)"> </div> <span *ngIf="nzAllowClear" class="ant-select-selection__clear" nz-select-unselectable (click)="onClearSelection($event)"></span> <span class="ant-select-arrow" nz-select-unselectable><b></b></span> </div> <ng-template cdkConnectedOverlay [cdkConnectedOverlayHasBackdrop]="true" [cdkConnectedOverlayOrigin]="cdkOverlayOrigin" (backdropClick)="closeDropDown()" (detach)="closeDropDown();" (positionChange)="onPositionChange($event)" [cdkConnectedOverlayWidth]="overlayWidth" [cdkConnectedOverlayMinWidth]="overlayMinWidth" [cdkConnectedOverlayOpen]="!isDestroy"> <div [ngClass]="dropDownClassMap" [@dropDownAnimation]="nzOpen ? dropDownPosition : 'hidden' " [ngStyle]="nzDropdownStyle"> <div style="overflow: auto" nz-option-container [listOfNzOptionComponent]="listOfNzOptionComponent" [listOfNzOptionGroupComponent]="listOfNzOptionGroupComponent" [nzSearchValue]="searchValue" [nzFilterOption]="nzFilterOption" [nzServerSearch]="nzServerSearch" [compareWith]="compareWith" [nzNotFoundContent]="nzNotFoundContent" [nzMaxMultipleCount]="nzMaxMultipleCount" [nzMode]="nzMode" (nzScrollToBottom)="nzScrollToBottom.emit()" (nzClickOption)="onClickOptionFromOptionContainer()" (nzListOfTemplateOptionChange)="listOfTemplateOptionChange($event)" (nzListOfSelectedValueChange)="updateListOfSelectedValueFromOptionContainer($event)" [nzListOfSelectedValue]="listOfSelectedValue"> </div> </div> </ng-template> <!--can not use ViewChild since it will match sub options in option group --> <ng-template> <ng-content></ng-content> </ng-template>`,
                host: {
                    '[class.ant-select]': 'true',
                    '[class.ant-select-lg]': 'nzSize==="large"',
                    '[class.ant-select-sm]': 'nzSize==="small"',
                    '[class.ant-select-enabled]': '!nzDisabled',
                    '[class.ant-select-disabled]': 'nzDisabled',
                    '[class.ant-select-allow-clear]': 'nzAllowClear',
                    '[class.ant-select-open]': 'nzOpen'
                },
                styles: [`
    .ant-select-dropdown {
      top: 100%;
      left: 0;
      position: relative;
      width: 100%;
      margin-top: 4px;
      margin-bottom: 4px;
    }
  `]
            },] },
];
/** @nocollapse */
NzSelectComponent.ctorParameters = () => [
    { type: Renderer2 }
];
NzSelectComponent.propDecorators = {
    cdkOverlayOrigin: [{ type: ViewChild, args: [CdkOverlayOrigin,] }],
    cdkConnectedOverlay: [{ type: ViewChild, args: [CdkConnectedOverlay,] }],
    nzSelectTopControlComponent: [{ type: ViewChild, args: [NzSelectTopControlComponent,] }],
    nzOptionContainerComponent: [{ type: ViewChild, args: [NzOptionContainerComponent,] }],
    listOfNzOptionComponent: [{ type: ContentChildren, args: [NzOptionComponent,] }],
    listOfNzOptionGroupComponent: [{ type: ContentChildren, args: [NzOptionGroupComponent,] }],
    nzOnSearch: [{ type: Output }],
    nzScrollToBottom: [{ type: Output }],
    nzOpenChange: [{ type: Output }],
    nzSize: [{ type: Input }],
    nzServerSearch: [{ type: Input }],
    nzMode: [{ type: Input }],
    nzDropdownMatchSelectWidth: [{ type: Input }],
    nzFilterOption: [{ type: Input }],
    nzMaxMultipleCount: [{ type: Input }],
    nzDropdownStyle: [{ type: Input }],
    nzNotFoundContent: [{ type: Input }],
    compareWith: [{ type: Input }],
    nzDropdownClassName: [{ type: Input }],
    nzAutoFocus: [{ type: Input }],
    nzOpen: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzAllowClear: [{ type: Input }],
    nzShowSearch: [{ type: Input }],
    nzPlaceHolder: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSelectModule {
}
NzSelectModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, OverlayModule, NzI18nModule],
                declarations: [NzOptionPipe, NzSubOptionPipe, NzOptionComponent, NzSelectComponent, NzOptionContainerComponent, NzOptionGroupComponent, NzOptionLiComponent, NzSelectTopControlComponent, NzSelectUnselectableDirective],
                exports: [NzOptionComponent, NzSelectComponent, NzOptionContainerComponent, NzOptionGroupComponent, NzSelectTopControlComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDateCellDirective {
}
NzDateCellDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nzDateCell]'
            },] },
];
class NzMonthCellDirective {
}
NzMonthCellDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nzMonthCell]'
            },] },
];
class NzDateFullCellDirective {
}
NzDateFullCellDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nzDateFullCell]'
            },] },
];
class NzMonthFullCellDirective {
}
NzMonthFullCellDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nzMonthFullCell]'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCalendarHeaderComponent {
    /**
     * @param {?} i18n
     */
    constructor(i18n) {
        this.i18n = i18n;
        this.mode = 'month';
        this.modeChange = new EventEmitter();
        this.fullscreen = true;
        this.activeDate = new Date();
        this.yearChange = new EventEmitter();
        this.monthChange = new EventEmitter();
        this.yearOffset = 10;
        this.yearTotal = 20;
        this.prefixCls = 'ant-fullcalendar';
    }
    /**
     * @return {?}
     */
    get activeYear() {
        return this.activeDate.getFullYear();
    }
    /**
     * @return {?}
     */
    get activeMonth() {
        return this.activeDate.getMonth();
    }
    /**
     * @return {?}
     */
    get size() {
        return this.fullscreen ? 'default' : 'small';
    }
    /**
     * @return {?}
     */
    get yearTypeText() {
        return this.i18n.getLocale().Calendar.year;
    }
    /**
     * @return {?}
     */
    get monthTypeText() {
        return this.i18n.getLocale().Calendar.month;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setUpYears();
        this.setUpMonths();
    }
    /**
     * @return {?}
     */
    setUpYears() {
        const /** @type {?} */ start = this.activeYear - this.yearOffset;
        const /** @type {?} */ end = start + this.yearTotal;
        this.years = [];
        for (let /** @type {?} */ i = start; i < end; i++) {
            this.years.push({ label: `${i}`, value: i });
        }
    }
    /**
     * @return {?}
     */
    setUpMonths() {
        this.months = [];
        for (let /** @type {?} */ i = 0; i < 12; i++) {
            const /** @type {?} */ dateInMonth = setMonth(this.activeDate, i);
            const /** @type {?} */ monthText = this.i18n.formatDate(dateInMonth, 'MMM');
            this.months.push({ label: monthText, value: i });
        }
    }
}
NzCalendarHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-calendar-header',
                template: `<nz-select class="ant-fullcalendar-year-select" [nzSize]="size" [nzDropdownMatchSelectWidth]="false" [ngModel]="activeYear" (ngModelChange)="yearChange.emit($event)"> <nz-option *ngFor="let year of years" [nzLabel]="year.label" [nzValue]="year.value"></nz-option> </nz-select> <nz-select *ngIf="mode === 'month'" class="ant-fullcalendar-month-select" [nzSize]="size" [nzDropdownMatchSelectWidth]="false" [ngModel]="activeMonth" (ngModelChange)="monthChange.emit($event)"> <nz-option *ngFor="let month of months" [nzLabel]="month.label" [nzValue]="month.value"></nz-option> </nz-select> <nz-radio-group [(ngModel)]="mode" (ngModelChange)="modeChange.emit($event)" [nzSize]="size"> <label nz-radio-button nzValue="month">{{ monthTypeText }}</label> <label nz-radio-button nzValue="year">{{ yearTypeText }}</label> </nz-radio-group> `,
                host: {
                    '[style.display]': `'block'`,
                    '[class.ant-fullcalendar-header]': `true`
                }
            },] },
];
/** @nocollapse */
NzCalendarHeaderComponent.ctorParameters = () => [
    { type: NzI18nService }
];
NzCalendarHeaderComponent.propDecorators = {
    mode: [{ type: Input }],
    modeChange: [{ type: Output }],
    fullscreen: [{ type: Input }],
    activeDate: [{ type: Input }],
    yearChange: [{ type: Output }],
    monthChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCalendarComponent {
    /**
     * @param {?} i18n
     */
    constructor(i18n) {
        this.i18n = i18n;
        this.nzMode = 'month';
        this.nzModeChange = new EventEmitter();
        this.nzValueChange = new EventEmitter();
        this.fullscreen = true;
        this.daysInWeek = [];
        this.monthsInYear = [];
        this.dateMatrix = [];
        this.activeDate = new Date();
        this.currentDateRow = -1;
        this.currentDateCol = -1;
        this.activeDateRow = -1;
        this.activeDateCol = -1;
        this.currentMonthRow = -1;
        this.currentMonthCol = -1;
        this.activeMonthRow = -1;
        this.activeMonthCol = -1;
        this.dateCell = null;
        this.dateFullCell = null;
        this.monthCell = null;
        this.monthFullCell = null;
        this.prefixCls = 'ant-fullcalendar';
        this.currentDate = new Date();
        this.onChangeFn = () => { };
        this.onTouchFn = () => { };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzValue(value) { this.updateDate(value, false); }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDateCell(value) { this.dateCell = value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDateFullCell(value) { this.dateFullCell = value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzMonthCell(value) { this.monthCell = value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzMonthFullCell(value) { this.monthFullCell = value; }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzFullscreen(value) { this.fullscreen = coerceBooleanProperty(value); }
    /**
     * @return {?}
     */
    get nzFullscreen() { return this.fullscreen; }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCard(value) { this.fullscreen = !coerceBooleanProperty(value); }
    /**
     * @return {?}
     */
    get nzCard() { return !this.fullscreen; }
    /**
     * @param {?} value
     * @return {?}
     */
    set dateCellChild(value) { if (value) {
        this.dateCell = value;
    } }
    /**
     * @param {?} value
     * @return {?}
     */
    set dateFullCellChild(value) { if (value) {
        this.dateFullCell = value;
    } }
    /**
     * @param {?} value
     * @return {?}
     */
    set monthCellChild(value) { if (value) {
        this.monthCell = value;
    } }
    /**
     * @param {?} value
     * @return {?}
     */
    set monthFullCellChild(value) { if (value) {
        this.monthFullCell = value;
    } }
    /**
     * @return {?}
     */
    get calendarStart() {
        return startOfWeek(startOfMonth(this.activeDate));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setUpDaysInWeek();
        this.setUpMonthsInYear();
        this.setUpDateMatrix();
        this.calculateCurrentDate();
        this.calculateActiveDate();
        this.calculateCurrentMonth();
        this.calculateActiveMonth();
    }
    /**
     * @param {?} mode
     * @return {?}
     */
    onModeChange(mode) {
        this.nzModeChange.emit(mode);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    onDateSelect(date) {
        this.updateDate(date);
    }
    /**
     * @param {?} year
     * @return {?}
     */
    onYearSelect(year) {
        const /** @type {?} */ date = setYear(this.activeDate, year);
        this.updateDate(date);
    }
    /**
     * @param {?} month
     * @return {?}
     */
    onMonthSelect(month) {
        const /** @type {?} */ date = setMonth(this.activeDate, month);
        this.updateDate(date);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.updateDate(value || new Date(), false);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchFn = fn;
    }
    /**
     * @param {?} date
     * @param {?=} touched
     * @return {?}
     */
    updateDate(date, touched = true) {
        const /** @type {?} */ dayChanged = !isSameDay(date, this.activeDate);
        const /** @type {?} */ monthChanged = !isSameMonth(date, this.activeDate);
        const /** @type {?} */ yearChanged = !isSameYear(date, this.activeDate);
        this.activeDate = date;
        if (dayChanged) {
            this.calculateActiveDate();
        }
        if (monthChanged) {
            this.setUpDateMatrix();
            this.calculateCurrentDate();
            this.calculateActiveMonth();
        }
        if (yearChanged) {
            this.calculateCurrentMonth();
        }
        if (touched) {
            this.onChangeFn(date);
            this.onTouchFn();
            this.nzValueChange.emit(date);
        }
    }
    /**
     * @return {?}
     */
    setUpDaysInWeek() {
        this.daysInWeek = [];
        const /** @type {?} */ weekStart = startOfWeek(this.activeDate);
        for (let /** @type {?} */ i = 0; i < 7; i++) {
            const /** @type {?} */ date = addDays(weekStart, i);
            const /** @type {?} */ title = this.i18n.formatDate(date, 'E');
            const /** @type {?} */ label = this.i18n.formatDate(date, 'EEEEEE');
            this.daysInWeek.push({ title, label });
        }
    }
    /**
     * @return {?}
     */
    setUpMonthsInYear() {
        this.monthsInYear = [];
        for (let /** @type {?} */ i = 0; i < 12; i++) {
            const /** @type {?} */ date = setMonth(this.activeDate, i);
            const /** @type {?} */ title = this.i18n.formatDate(date, 'MMM');
            const /** @type {?} */ label = this.i18n.formatDate(date, 'MMM');
            const /** @type {?} */ start = startOfMonth(date);
            this.monthsInYear.push({ title, label, start });
        }
    }
    /**
     * @return {?}
     */
    setUpDateMatrix() {
        this.dateMatrix = [];
        const /** @type {?} */ monthStart = startOfMonth(this.activeDate);
        const /** @type {?} */ monthEnd = endOfMonth(this.activeDate);
        const /** @type {?} */ weekDiff = differenceInCalendarWeeks(monthEnd, monthStart) + 2;
        for (let /** @type {?} */ week = 0; week < weekDiff; week++) {
            const /** @type {?} */ row = [];
            const /** @type {?} */ weekStart = addDays(this.calendarStart, week * 7);
            for (let /** @type {?} */ day = 0; day < 7; day++) {
                const /** @type {?} */ date = addDays(weekStart, day);
                const /** @type {?} */ monthDiff = differenceInCalendarMonths(date, this.activeDate);
                const /** @type {?} */ title = this.i18n.formatDate(date, 'longDate');
                const /** @type {?} */ label = this.i18n.formatDate(date, 'dd');
                const /** @type {?} */ rel = monthDiff === 0 ? 'current' : monthDiff < 0 ? 'last' : 'next';
                row.push({ title, label, rel, value: date });
            }
            this.dateMatrix.push(row);
        }
    }
    /**
     * @return {?}
     */
    calculateCurrentDate() {
        if (isThisMonth(this.activeDate)) {
            this.currentDateRow = differenceInCalendarWeeks(this.currentDate, this.calendarStart);
            this.currentDateCol = differenceInCalendarDays(this.currentDate, addDays(this.calendarStart, this.currentDateRow * 7));
        }
        else {
            this.currentDateRow = -1;
            this.currentDateCol = -1;
        }
    }
    /**
     * @return {?}
     */
    calculateActiveDate() {
        this.activeDateRow = differenceInCalendarWeeks(this.activeDate, this.calendarStart);
        this.activeDateCol = differenceInCalendarDays(this.activeDate, addDays(this.calendarStart, this.activeDateRow * 7));
    }
    /**
     * @return {?}
     */
    calculateCurrentMonth() {
        if (isThisYear(this.activeDate)) {
            const /** @type {?} */ yearStart = startOfYear(this.currentDate);
            const /** @type {?} */ monthDiff = differenceInCalendarMonths(this.currentDate, yearStart);
            this.currentMonthRow = Math.floor(monthDiff / 3);
            this.currentMonthCol = monthDiff % 3;
        }
        else {
            this.currentMonthRow = -1;
            this.currentMonthCol = -1;
        }
    }
    /**
     * @return {?}
     */
    calculateActiveMonth() {
        this.activeMonthRow = Math.floor(this.activeDate.getMonth() / 3);
        this.activeMonthCol = this.activeDate.getMonth() % 3;
    }
}
NzCalendarComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-calendar',
                template: `<nz-calendar-header [fullscreen]="fullscreen" [activeDate]="activeDate" [(mode)]="nzMode" (modeChange)="onModeChange($event)" (yearChange)="onYearSelect($event)" (monthChange)="onMonthSelect($event)"> </nz-calendar-header> <div class="ant-fullcalendar ant-fullcalendar-full" [ngClass]="fullscreen ? 'ant-fullcalendar-fullscreen' : ''"> <div class="ant-fullcalendar-calendar-body"> <ng-container *ngIf="nzMode === 'month' then monthModeTable else yearModeTable"></ng-container> </div> </div> <ng-template #monthModeTable> <table class="ant-fullcalendar-table" cellspacing="0" role="grid"> <thead> <tr role="row"> <th *ngFor="let day of daysInWeek" class="ant-fullcalendar-column-header" role="columnheader" [title]="day.title"> <span class="ant-fullcalendar-column-header-inner">{{ day.label }}</span> </th> </tr> </thead> <tbody class="ant-fullcalendar-tbody"> <tr *ngFor="let week of dateMatrix; index as row" [class.ant-fullcalendar-current-week]="row === currentDateRow" [class.ant-fullcalendar-active-week]="row === activeDateRow"> <td *ngFor="let day of week; index as col" role="gridcell" class="ant-fullcalendar-cell" [title]="day.title" [class.ant-fullcalendar-today]="row === currentDateRow && col === currentDateCol" [class.ant-fullcalendar-selected-day]="row === activeDateRow && col === activeDateCol" [class.ant-fullcalendar-last-month-cell]="day.rel === 'last'" [class.ant-fullcalendar-next-month-btn-day]="day.rel === 'next'" (click)="onDateSelect(day.value, row, col)"> <div class="ant-fullcalendar-date"> <ng-container *ngIf="dateFullCell else defaultCell"> <ng-container *ngTemplateOutlet="dateFullCell; context: {$implicit: day.value}"></ng-container> </ng-container> <ng-template #defaultCell> <div class="ant-fullcalendar-value">{{ day.label }}</div> <div *ngIf="dateCell" class="ant-fullcalendar-content"> <ng-container *ngTemplateOutlet="dateCell; context: {$implicit: day.value}"></ng-container> </div> </ng-template> </div> </td> </tr> </tbody> </table> </ng-template> <ng-template #yearModeTable> <table class="ant-fullcalendar-month-panel-table" cellspacing="0" role="grid"> <tbody class="ant-fullcalendar-month-panel-tbody"> <tr *ngFor="let row of [0, 1, 2, 3]" role="row"> <td *ngFor="let col of [0, 1, 2]" role="gridcell" [title]="monthsInYear[row * 3 + col].title" class="ant-fullcalendar-month-panel-cell" [class.ant-fullcalendar-month-panel-current-cell]="row === currentMonthRow && col === currentMonthCol" [class.ant-fullcalendar-month-panel-selected-cell]="row === activeMonthRow && col === activeMonthCol" (click)="onMonthSelect(row * 3 + col)"> <div class="ant-fullcalendar-month"> <ng-container *ngIf="monthFullCell else defaultCell"> <ng-container *ngTemplateOutlet="monthFullCell; context: {$implicit: monthsInYear[row * 3 + col].start}"></ng-container> </ng-container> <ng-template #defaultCell> <div class="ant-fullcalendar-value">{{ monthsInYear[row * 3 + col].label }}</div> <div *ngIf="monthCell" class="ant-fullcalendar-content"> <ng-container *ngTemplateOutlet="monthCell; context: {$implicit: monthsInYear[row * 3 + col].start}"></ng-container> </div> </ng-template> </div> </td> </tr> </tbody> </table> </ng-template> `,
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => NzCalendarComponent), multi: true }
                ]
            },] },
];
/** @nocollapse */
NzCalendarComponent.ctorParameters = () => [
    { type: NzI18nService }
];
NzCalendarComponent.propDecorators = {
    nzMode: [{ type: Input }],
    nzModeChange: [{ type: Output }],
    nzValue: [{ type: Input }],
    nzValueChange: [{ type: Output }],
    nzDateCell: [{ type: Input }],
    nzDateFullCell: [{ type: Input }],
    nzMonthCell: [{ type: Input }],
    nzMonthFullCell: [{ type: Input }],
    nzFullscreen: [{ type: Input }],
    nzCard: [{ type: Input }],
    dateCellChild: [{ type: ContentChild, args: [NzDateCellDirective, { read: TemplateRef },] }],
    dateFullCellChild: [{ type: ContentChild, args: [NzDateFullCellDirective, { read: TemplateRef },] }],
    monthCellChild: [{ type: ContentChild, args: [NzMonthCellDirective, { read: TemplateRef },] }],
    monthFullCellChild: [{ type: ContentChild, args: [NzMonthFullCellDirective, { read: TemplateRef },] }],
    fullscreen: [{ type: HostBinding, args: ['class.ant-fullcalendar--fullscreen',] }]
};
/**
 * @record
 */

/**
 * @record
 */

/**
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCalendarModule {
}
NzCalendarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NzCalendarHeaderComponent,
                    NzCalendarComponent,
                    NzDateCellDirective,
                    NzDateFullCellDirective,
                    NzMonthCellDirective,
                    NzMonthFullCellDirective
                ],
                exports: [
                    NzCalendarComponent,
                    NzDateCellDirective,
                    NzDateFullCellDirective,
                    NzMonthCellDirective,
                    NzMonthFullCellDirective
                ],
                imports: [CommonModule, FormsModule, NzI18nModule, NzRadioModule, NzSelectModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCardGridDirective {
}
NzCardGridDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-card-grid]',
                host: {
                    '[class.ant-card-grid]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCardLoadingComponent {
}
NzCardLoadingComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-card-loading',
                template: `<div class="ant-card-loading-content"> <div class="ant-row" style="margin-left: -4px; margin-right: -4px;"> <div class="ant-col-22" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> </div> <div class="ant-row" style="margin-left: -4px; margin-right: -4px;"> <div class="ant-col-8" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> <div class="ant-col-15" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> </div> <div class="ant-row" style="margin-left: -4px; margin-right: -4px;"> <div class="ant-col-6" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> <div class="ant-col-18" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> </div> <div class="ant-row" style="margin-left: -4px; margin-right: -4px;"> <div class="ant-col-13" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> <div class="ant-col-9" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> </div> <div class="ant-row" style="margin-left: -4px; margin-right: -4px;"> <div class="ant-col-4" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> <div class="ant-col-3" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> <div class="ant-col-16" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> </div> <div class="ant-row" style="margin-left: -4px; margin-right: -4px;"> <div class="ant-col-8" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> <div class="ant-col-6" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> <div class="ant-col-8" style="padding-left: 4px; padding-right: 4px;"> <div class="ant-card-loading-block"></div> </div> </div> </div>`,
                host: {
                    '[class.ant-card-loading-content]': 'true'
                },
                styles: [`
    :host {
      display: block;
    }
  `]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCardMetaComponent {
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTitle(value) {
        this.isTitleString = !(value instanceof TemplateRef);
        this._title = value;
    }
    /**
     * @return {?}
     */
    get nzTitle() {
        return this._title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDescription(value) {
        this.isDescriptionString = !(value instanceof TemplateRef);
        this._description = value;
    }
    /**
     * @return {?}
     */
    get nzDescription() {
        return this._description;
    }
}
NzCardMetaComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-card-meta',
                preserveWhitespaces: false,
                template: `<div class="ant-card-meta-avatar" *ngIf="nzAvatar"> <ng-template [ngTemplateOutlet]="nzAvatar"></ng-template> </div> <div class="ant-card-meta-detail" *ngIf="nzTitle || nzDescription"> <div class="ant-card-meta-title" *ngIf="nzTitle"> <ng-container *ngIf="isTitleString; else titleTemplate">{{ nzTitle }}</ng-container> <ng-template #titleTemplate> <ng-template [ngTemplateOutlet]="nzTitle"></ng-template> </ng-template> </div> <div class="ant-card-meta-description" *ngIf="nzDescription"> <ng-container *ngIf="isDescriptionString; else descriptionTemplate">{{ nzDescription }}</ng-container> <ng-template #descriptionTemplate> <ng-template [ngTemplateOutlet]="nzDescription"></ng-template> </ng-template> </div> </div>`,
                styles: [`
    :host {
      display: block;
    }
  `],
                host: {
                    '[class.ant-card-meta]': 'true'
                }
            },] },
];
NzCardMetaComponent.propDecorators = {
    nzAvatar: [{ type: Input }],
    nzTitle: [{ type: Input }],
    nzDescription: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCardTabComponent {
}
NzCardTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-card-tab',
                template: `<ng-template> <ng-content></ng-content> </ng-template>`
            },] },
];
NzCardTabComponent.propDecorators = {
    template: [{ type: ViewChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCardComponent {
    constructor() {
        this._bordered = true;
        this._loading = false;
        this._hoverable = false;
        this.nzActions = [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTitle(value) {
        this.isTitleString = !(value instanceof TemplateRef);
        this._title = value;
    }
    /**
     * @return {?}
     */
    get nzTitle() {
        return this._title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzExtra(value) {
        this.isExtraString = !(value instanceof TemplateRef);
        this._extra = value;
    }
    /**
     * @return {?}
     */
    get nzExtra() {
        return this._extra;
    }
    /**
     * @return {?}
     */
    get isInner() {
        return this.nzType === 'inner';
    }
    /**
     * @return {?}
     */
    get isTabs() {
        return !!this.tab;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzBordered(value) {
        this._bordered = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzBordered() {
        return this._bordered;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzLoading(value) {
        this._loading = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzLoading() {
        return this._loading;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzHoverable(value) {
        this._hoverable = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzHoverable() {
        return this._hoverable;
    }
}
NzCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-card',
                preserveWhitespaces: false,
                template: `<ng-template #titleTemplate> <ng-template [ngTemplateOutlet]="nzTitle"></ng-template> </ng-template> <ng-template #extraTemplate> <ng-template [ngTemplateOutlet]="nzExtra"></ng-template> </ng-template> <div class="ant-card-head" *ngIf="nzTitle||nzExtra||tab"> <div class="ant-card-head-wrapper"> <div class="ant-card-head-title" *ngIf="nzTitle"> <ng-container *ngIf="isTitleString; else titleTemplate">{{ nzTitle }}</ng-container> </div> <div class="ant-card-extra" *ngIf="nzExtra"> <ng-container *ngIf="isExtraString; else extraTemplate">{{ nzExtra }}</ng-container> </div> </div> <ng-container *ngIf="tab"> <ng-template [ngTemplateOutlet]="tab.template"></ng-template> </ng-container> </div> <div class="ant-card-cover" *ngIf="nzCover"> <ng-template [ngTemplateOutlet]="nzCover"></ng-template> </div> <div class="ant-card-body" [ngStyle]="nzBodyStyle"> <ng-container *ngIf="!nzLoading"> <ng-content></ng-content> </ng-container> <nz-card-loading *ngIf="nzLoading"></nz-card-loading> </div> <ul class="ant-card-actions" *ngIf="nzActions.length"> <li *ngFor="let action of nzActions" [style.width.%]="100/nzActions.length"> <span><ng-template [ngTemplateOutlet]="action"></ng-template></span> </li> </ul>`,
                styles: [`
    :host {
      display: block;
      position: relative;
    }
  `],
                host: {
                    '[class.ant-card]': 'true',
                    '[class.ant-card-loading]': 'nzLoading'
                }
            },] },
];
NzCardComponent.propDecorators = {
    tab: [{ type: ContentChild, args: [NzCardTabComponent,] }],
    nzBodyStyle: [{ type: Input }],
    nzCover: [{ type: Input }],
    nzActions: [{ type: Input }],
    nzType: [{ type: Input }],
    nzTitle: [{ type: Input }],
    nzExtra: [{ type: Input }],
    isInner: [{ type: HostBinding, args: ['class.ant-card-type-inner',] }],
    isTabs: [{ type: HostBinding, args: ['class.ant-card-contain-tabs',] }],
    nzBordered: [{ type: Input }, { type: HostBinding, args: ['class.ant-card-bordered',] }],
    nzLoading: [{ type: Input }],
    nzHoverable: [{ type: Input }, { type: HostBinding, args: ['class.ant-card-hoverable',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCardModule {
}
NzCardModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NzCardComponent, NzCardGridDirective, NzCardMetaComponent, NzCardLoadingComponent, NzCardTabComponent],
                exports: [NzCardComponent, NzCardGridDirective, NzCardMetaComponent, NzCardLoadingComponent, NzCardTabComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCarouselContentDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._active = false;
        this._width = 0;
        this._fadeMode = false;
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set width(value) {
        this._width = value;
        this.renderer.setStyle(this.el, 'width', `${this.width}px`);
    }
    /**
     * @return {?}
     */
    get width() {
        return this._width;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set left(value) {
        this._left = value;
        if (isNotNil(this.left)) {
            this.renderer.setStyle(this.el, 'left', `${this.left}px`);
        }
        else {
            this.renderer.removeStyle(this.el, 'left');
        }
    }
    /**
     * @return {?}
     */
    get left() {
        return this._left;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set top(value) {
        this._top = value;
        if (isNotNil(this.top)) {
            this.renderer.setStyle(this.el, 'top', `${this.top}px`);
        }
        else {
            this.renderer.removeStyle(this.el, 'top');
        }
    }
    /**
     * @return {?}
     */
    get top() {
        return this._top;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isActive(value) {
        this._active = value;
        this.updateOpacity();
        if (this.isActive) {
            this.renderer.addClass(this.el, 'slick-active');
        }
        else {
            this.renderer.removeClass(this.el, 'slick-active');
        }
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this._active;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set fadeMode(value) {
        this._fadeMode = value;
        if (this.fadeMode) {
            this.renderer.setStyle(this.el, 'position', 'relative');
        }
        else {
            this.renderer.removeStyle(this.el, 'position');
        }
        this.updateOpacity();
    }
    /**
     * @return {?}
     */
    get fadeMode() {
        return this._fadeMode;
    }
    /**
     * @return {?}
     */
    updateOpacity() {
        if (this.fadeMode) {
            this.renderer.setStyle(this.el, 'opacity', this.isActive ? 1 : 0);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.renderer.setStyle(this.el, 'transition', 'opacity 500ms ease');
    }
}
NzCarouselContentDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-carousel-content]',
                host: {
                    '[class.slick-slide]': 'true'
                }
            },] },
];
/** @nocollapse */
NzCarouselContentDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCarouselComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._autoPlay = false;
        this._autoPlaySpeed = 3000;
        this._dots = true;
        this._vertical = false;
        this._effect = 'scrollx';
        this.unsubscribe$ = new Subject();
        this.activeIndex = 0;
        this.transform = 'translate3d(0px, 0px, 0px)';
        this.nzAfterChange = new EventEmitter();
        this.nzBeforeChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get nextIndex() {
        return this.activeIndex < this.slideContents.length - 1 ? (this.activeIndex + 1) : 0;
    }
    /**
     * @return {?}
     */
    get prevIndex() {
        return this.activeIndex > 0 ? (this.activeIndex - 1) : (this.slideContents.length - 1);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDots(value) {
        this._dots = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDots() {
        return this._dots;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzEffect(value) {
        this._effect = value;
        this.updateMode();
    }
    /**
     * @return {?}
     */
    get nzEffect() {
        return this._effect;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAutoPlay(value) {
        this._autoPlay = toBoolean(value);
        this.setUpAutoPlay();
    }
    /**
     * @return {?}
     */
    get nzAutoPlay() {
        return this._autoPlay;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAutoPlaySpeed(value) {
        this._autoPlaySpeed = toNumber(value, null);
        this.setUpAutoPlay();
    }
    /**
     * @return {?}
     */
    get nzAutoPlaySpeed() {
        return this._autoPlaySpeed;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzVertical(value) {
        this._vertical = toBoolean(value);
        this.updateMode();
    }
    /**
     * @return {?}
     */
    get nzVertical() {
        return this._vertical;
    }
    /**
     * @param {?} content
     * @param {?} i
     * @return {?}
     */
    setActive(content, i) {
        if (this.slideContents && this.slideContents.length) {
            this.setUpAutoPlay();
            const /** @type {?} */ beforeIndex = this.slideContents.toArray().findIndex(slide => slide.isActive);
            this.nzBeforeChange.emit({ from: beforeIndex, to: i });
            this.activeIndex = i;
            if (this.nzEffect === 'scrollx') {
                if (this.nzVertical) {
                    this.transform = `translate3d(0px, ${-this.activeIndex * this.elementRef.nativeElement.offsetHeight}px, 0px)`;
                }
                else {
                    this.transform = `translate3d(${-this.activeIndex * this.elementRef.nativeElement.offsetWidth}px, 0px, 0px)`;
                }
            }
            else {
                this.transform = 'translate3d(0px, 0px, 0px)';
            }
            this.slideContents.forEach(slide => slide.isActive = slide === content);
            this.nzAfterChange.emit(i);
        }
    }
    /**
     * @return {?}
     */
    renderContent() {
        if (this.slideContents && this.slideContents.length) {
            this.slideContents.forEach((content, i) => {
                content.width = this.elementRef.nativeElement.offsetWidth;
                if (this.nzEffect === 'fade') {
                    content.fadeMode = true;
                    if (this.nzVertical) {
                        content.top = -i * this.elementRef.nativeElement.offsetHeight;
                    }
                    else {
                        content.left = -i * content.width;
                    }
                }
                else {
                    content.fadeMode = false;
                    content.left = null;
                    content.top = null;
                }
            });
            if (this.nzVertical) {
                this.renderer.removeStyle(this.slickTrack.nativeElement, 'width');
                this.renderer.removeStyle(this.slickList.nativeElement, 'width');
                this.renderer.removeStyle(this.slickList.nativeElement, 'height');
                this.renderer.setStyle(this.slickList.nativeElement, 'height', `${this.slideContents.first.el.offsetHeight}px`);
                this.renderer.removeStyle(this.slickTrack.nativeElement, 'height');
                this.renderer.setStyle(this.slickTrack.nativeElement, 'height', `${this.slideContents.length * this.elementRef.nativeElement.offsetHeight}px`);
            }
            else {
                this.renderer.removeStyle(this.slickTrack.nativeElement, 'height');
                this.renderer.removeStyle(this.slickList.nativeElement, 'height');
                this.renderer.removeStyle(this.slickTrack.nativeElement, 'width');
                this.renderer.setStyle(this.slickTrack.nativeElement, 'width', `${this.slideContents.length * this.elementRef.nativeElement.offsetWidth}px`);
            }
            this.setUpAutoPlay();
        }
    }
    /**
     * @return {?}
     */
    setUpAutoPlay() {
        this.clearTimeout();
        if (this.nzAutoPlay && this.nzAutoPlaySpeed > 0) {
            this.timeout = setTimeout(_ => {
                this.setActive(this.slideContents.toArray()[this.nextIndex], this.nextIndex);
            }, this.nzAutoPlaySpeed);
        }
    }
    /**
     * @return {?}
     */
    updateMode() {
        if (this.slideContents && this.slideContents.length) {
            this.renderContent();
            this.setActive(this.slideContents.first, 0);
        }
    }
    /**
     * @return {?}
     */
    clearTimeout() {
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    }
    /**
     * @return {?}
     */
    next() {
        this.setActive(this.slideContents.toArray()[this.nextIndex], this.nextIndex);
    }
    /**
     * @return {?}
     */
    pre() {
        this.setActive(this.slideContents.toArray()[this.prevIndex], this.prevIndex);
    }
    /**
     * @param {?} index
     * @return {?}
     */
    goTo(index) {
        if (index >= 0 && index <= this.slideContents.length - 1) {
            this.setActive(this.slideContents.toArray()[index], index);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        if (e.keyCode === 37) {
            // Left
            this.pre();
            e.preventDefault();
        }
        else if (e.keyCode === 39) {
            // Right
            this.next();
            e.preventDefault();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.slideContents && this.slideContents.length) {
            this.slideContents.first.isActive = true;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.slideContents.changes
            .pipe(takeUntil(this.unsubscribe$))
            .subscribe(() => {
            this.renderContent();
        });
        this.renderContent();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
        this.clearTimeout();
    }
}
NzCarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-carousel',
                preserveWhitespaces: false,
                template: `<div class="slick-initialized slick-slider" [class.slick-vertical]="nzVertical"> <div class="slick-list" #slickList tabindex="-1" (keydown)="onKeyDown($event)"> <div class="slick-track" [style.transform]="transform" #slickTrack> <ng-content></ng-content> </div> </div> <ul class="slick-dots" *ngIf="nzDots"> <li *ngFor="let content of slideContents; let i =index" [class.slick-active]="content.isActive" (click)="setActive(content,i)"> <button>{{i + 1}}</button> </li> </ul> </div>`,
                host: {
                    '[class.ant-carousel]': 'true'
                },
                styles: [
                    `
      :host {
        display: block;
        position: relative;
        overflow: hidden;
        width: 100%;
        height: 100%;
      }

      .slick-dots {
        display: block;
      }

      .slick-track {
        opacity: 1;
        transition: all 0.5s ease;
      }

      .slick-slide {
        transition: opacity 500ms ease;
      }

    `
                ]
            },] },
];
/** @nocollapse */
NzCarouselComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NzCarouselComponent.propDecorators = {
    slideContents: [{ type: ContentChildren, args: [NzCarouselContentDirective,] }],
    slickList: [{ type: ViewChild, args: ['slickList',] }],
    slickTrack: [{ type: ViewChild, args: ['slickTrack',] }],
    nzAfterChange: [{ type: Output }],
    nzBeforeChange: [{ type: Output }],
    nzDots: [{ type: Input }],
    nzEffect: [{ type: Input }],
    nzAutoPlay: [{ type: Input }],
    nzAutoPlaySpeed: [{ type: Input }],
    nzVertical: [{ type: Input }, { type: HostBinding, args: ['class.ant-carousel-vertical',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCarouselModule {
}
NzCarouselModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzCarouselComponent, NzCarouselContentDirective],
                exports: [NzCarouselComponent, NzCarouselContentDirective],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Thanks to https://github.com/andreypopp/react-textarea-autosize/
/**
 * calculateNodeHeight(uiTextNode, useCache = false)
 */
const HIDDEN_TEXTAREA_STYLE = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important
`;
const SIZING_STYLE = [
    'letter-spacing',
    'line-height',
    'padding-top',
    'padding-bottom',
    'font-family',
    'font-weight',
    'font-size',
    'text-rendering',
    'text-transform',
    'width',
    'text-indent',
    'padding-left',
    'padding-right',
    'border-width',
    'box-sizing'
];
/**
 * @record
 */

/**
 * @record
 */

const computedStyleCache = {};
let hiddenTextarea;
/**
 * @param {?} node
 * @param {?=} useCache
 * @return {?}
 */
function calculateNodeStyling(node, useCache = false) {
    const /** @type {?} */ nodeRef = /** @type {?} */ ((node.getAttribute('id') ||
        node.getAttribute('data-reactid') ||
        node.getAttribute('name')));
    if (useCache && computedStyleCache[nodeRef]) {
        return computedStyleCache[nodeRef];
    }
    const /** @type {?} */ style$$1 = window.getComputedStyle(node);
    const /** @type {?} */ boxSizing = (style$$1.getPropertyValue('box-sizing') ||
        style$$1.getPropertyValue('-moz-box-sizing') ||
        style$$1.getPropertyValue('-webkit-box-sizing'));
    const /** @type {?} */ paddingSize = (parseFloat(style$$1.getPropertyValue('padding-bottom')) +
        parseFloat(style$$1.getPropertyValue('padding-top')));
    const /** @type {?} */ borderSize = (parseFloat(style$$1.getPropertyValue('border-bottom-width')) +
        parseFloat(style$$1.getPropertyValue('border-top-width')));
    const /** @type {?} */ sizingStyle = SIZING_STYLE
        .map(name => `${name}:${style$$1.getPropertyValue(name)}`)
        .join(';');
    const /** @type {?} */ nodeInfo = {
        sizingStyle,
        paddingSize,
        borderSize,
        boxSizing
    };
    if (useCache && nodeRef) {
        computedStyleCache[nodeRef] = nodeInfo;
    }
    return nodeInfo;
}
/**
 * @param {?} uiTextNode
 * @param {?=} useCache
 * @param {?=} minRows
 * @param {?=} maxRows
 * @return {?}
 */
function calculateNodeHeight(uiTextNode, useCache = false, minRows = null, maxRows = null) {
    if (!hiddenTextarea) {
        hiddenTextarea = document.createElement('textarea');
        document.body.appendChild(hiddenTextarea);
    }
    // Fix wrap="off" issue
    // https://github.com/ant-design/ant-design/issues/6577
    if (uiTextNode.getAttribute('wrap')) {
        hiddenTextarea.setAttribute('wrap', /** @type {?} */ (uiTextNode.getAttribute('wrap')));
    }
    else {
        hiddenTextarea.removeAttribute('wrap');
    }
    // Copy all CSS properties that have an impact on the height of the content in
    // the textbox
    const { paddingSize, borderSize, boxSizing, sizingStyle } = calculateNodeStyling(uiTextNode, useCache);
    // Need to have the overflow attribute to hide the scrollbar otherwise
    // text-lines will not calculated properly as the shadow will technically be
    // narrower for content
    hiddenTextarea.setAttribute('style', `${sizingStyle};${HIDDEN_TEXTAREA_STYLE}`);
    hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || '';
    let /** @type {?} */ minHeight = Number.MIN_SAFE_INTEGER;
    let /** @type {?} */ maxHeight = Number.MAX_SAFE_INTEGER;
    let /** @type {?} */ height = hiddenTextarea.scrollHeight;
    let /** @type {?} */ overflowY;
    if (boxSizing === 'border-box') {
        // border-box: add border, since height = content + padding + border
        height = height + borderSize;
    }
    else if (boxSizing === 'content-box') {
        // remove padding, since height = content
        height = height - paddingSize;
    }
    if (minRows !== null || maxRows !== null) {
        // measure height of a textarea with a single row
        hiddenTextarea.value = '';
        const /** @type {?} */ singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (minRows !== null) {
            minHeight = singleRowHeight * minRows;
            if (boxSizing === 'border-box') {
                minHeight = minHeight + paddingSize + borderSize;
            }
            height = Math.max(minHeight, height);
        }
        if (maxRows !== null) {
            maxHeight = singleRowHeight * maxRows;
            if (boxSizing === 'border-box') {
                maxHeight = maxHeight + paddingSize + borderSize;
            }
            overflowY = height > maxHeight ? '' : 'hidden';
            height = Math.min(maxHeight, height);
        }
    }
    // Remove scroll bar flash when autosize without maxRows
    if (!maxRows) {
        overflowY = 'hidden';
    }
    return { height, minHeight, maxHeight, overflowY };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class NzInputDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} ngModel
     * @param {?} ngControl
     */
    constructor(elementRef, renderer, ngModel, ngControl) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.ngModel = ngModel;
        this.ngControl = ngControl;
        this._size = 'default';
        this._disabled = false;
        this._autosize = false;
        this.isInit = false;
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this._size = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get disabled() {
        if (this.ngControl && this.ngControl.disabled !== null) {
            return this.ngControl.disabled;
        }
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAutosize(value) {
        if (typeof value === 'string') {
            this._autosize = true;
        }
        else {
            this._autosize = value;
        }
    }
    /**
     * @return {?}
     */
    get nzAutosize() {
        return this._autosize;
    }
    /**
     * @return {?}
     */
    get setLgClass() {
        return this.nzSize === 'large';
    }
    /**
     * @return {?}
     */
    get setSmClass() {
        return this.nzSize === 'small';
    }
    /**
     * @return {?}
     */
    textAreaOnChange() {
        if (this.nzAutosize) {
            this.resizeTextArea();
        }
    }
    /**
     * @return {?}
     */
    resizeTextArea() {
        const /** @type {?} */ textAreaRef = /** @type {?} */ (this.el);
        const /** @type {?} */ maxRows = this.nzAutosize ? (/** @type {?} */ (this.nzAutosize)).maxRows || null : null;
        const /** @type {?} */ minRows = this.nzAutosize ? (/** @type {?} */ (this.nzAutosize)).minRows || null : null;
        if ((this.previousValue === textAreaRef.value) && (this.previewsMaxRows === maxRows) && (this.previewsMinRows === minRows)) {
            return;
        }
        this.previousValue = textAreaRef.value;
        this.previewsMinRows = minRows;
        this.previewsMaxRows = maxRows;
        // eliminate jitter
        this.renderer.setStyle(textAreaRef, 'height', 'auto');
        const /** @type {?} */ textAreaStyles = calculateNodeHeight(textAreaRef, false, minRows, maxRows);
        this.renderer.setStyle(textAreaRef, 'height', `${textAreaStyles.height}px`);
        this.renderer.setStyle(textAreaRef, 'overflowY', textAreaStyles.overflowY);
        this.renderer.setStyle(textAreaRef, 'minHeight', `${textAreaStyles.minHeight}px`);
        this.renderer.setStyle(textAreaRef, 'maxHeight', `${textAreaStyles.maxHeight}px`);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.nzAutosize && this.isInit) {
            this.resizeTextArea();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.isInit = true;
        if (this.nzAutosize) {
            this.resizeTextArea();
        }
    }
}
NzInputDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-input]',
                host: {
                    '[class.ant-input]': 'true'
                }
            },] },
];
/** @nocollapse */
NzInputDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgModel, decorators: [{ type: Optional }] },
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }] }
];
NzInputDirective.propDecorators = {
    nzSize: [{ type: Input }],
    disabled: [{ type: Input }, { type: HostBinding, args: [`class.ant-input-disabled`,] }],
    nzAutosize: [{ type: Input }],
    setLgClass: [{ type: HostBinding, args: [`class.ant-input-lg`,] }],
    setSmClass: [{ type: HostBinding, args: [`class.ant-input-sm`,] }],
    textAreaOnChange: [{ type: HostListener, args: ['input',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzInputGroupComponent {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this._addOnBefore = '';
        this._addOnAfter = '';
        this._prefix = '';
        this._suffix = '';
        this._size = 'default';
        this._compact = false;
        this._search = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this._size = value;
        this.updateChildrenInputSize();
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCompact(value) {
        this._compact = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzCompact() {
        return this._compact;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAddOnBefore(value) {
        this.isAddOnBeforeString = !(value instanceof TemplateRef);
        this._addOnBefore = value;
    }
    /**
     * @return {?}
     */
    get nzAddOnBefore() {
        return this._addOnBefore;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAddOnAfter(value) {
        this.isAddOnAfterString = !(value instanceof TemplateRef);
        this._addOnAfter = value;
    }
    /**
     * @return {?}
     */
    get nzAddOnAfter() {
        return this._addOnAfter;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPrefix(value) {
        this.isPrefixString = !(value instanceof TemplateRef);
        this._prefix = value;
    }
    /**
     * @return {?}
     */
    get nzPrefix() {
        return this._prefix;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSuffix(value) {
        this.isSuffixString = !(value instanceof TemplateRef);
        this._suffix = value;
    }
    /**
     * @return {?}
     */
    get nzSuffix() {
        return this._suffix;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSearch(value) {
        this._search = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzSearch() {
        return this._search;
    }
    /**
     * @return {?}
     */
    get isLarge() {
        return this.nzSize === 'large';
    }
    /**
     * @return {?}
     */
    get isSmall() {
        return this.nzSize === 'small';
    }
    /**
     * @return {?}
     */
    get isAffix() {
        return !!(this.nzSuffix || this.nzPrefix || this.nzPrefixIcon || this.nzSuffixIcon);
    }
    /**
     * @return {?}
     */
    get isAddOn() {
        return !!(this.nzAddOnAfter || this.nzAddOnBefore || this.nzAddOnAfterIcon || this.nzAddOnBeforeIcon);
    }
    /**
     * @return {?}
     */
    get isGroup() {
        return (!this.isAffix) && (!this.isAddOn);
    }
    /**
     * @return {?}
     */
    get isLargeGroup() {
        return this.isGroup && this.isLarge;
    }
    /**
     * @return {?}
     */
    get isLargeGroupWrapper() {
        return this.isAddOn && this.isLarge;
    }
    /**
     * @return {?}
     */
    get isLargeAffix() {
        return this.isAffix && this.isLarge;
    }
    /**
     * @return {?}
     */
    get isLargeSearch() {
        return this.nzSearch && this.isLarge;
    }
    /**
     * @return {?}
     */
    get isSmallGroup() {
        return this.isGroup && this.isSmall;
    }
    /**
     * @return {?}
     */
    get isSmallAffix() {
        return this.isAffix && this.isSmall;
    }
    /**
     * @return {?}
     */
    get isSmallGroupWrapper() {
        return this.isAddOn && this.isSmall;
    }
    /**
     * @return {?}
     */
    get isSmallSearch() {
        return this.nzSearch && this.isSmall;
    }
    /**
     * @return {?}
     */
    updateChildrenInputSize() {
        if (this.nzInputDirectiveQueryList) {
            this.nzInputDirectiveQueryList.forEach(item => item.nzSize = this.nzSize);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.updateChildrenInputSize();
    }
}
NzInputGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-input-group',
                preserveWhitespaces: false,
                template: `<span class="ant-input-wrapper ant-input-group" *ngIf="isAddOn"> <span class="ant-input-group-addon" *ngIf="nzAddOnBefore || nzAddOnBeforeIcon"> <i [ngClass]="nzAddOnBeforeIcon" *ngIf="nzAddOnBeforeIcon"></i> <ng-container *ngIf="isAddOnBeforeString; else addOnBeforeTemplate">{{ nzAddOnBefore }}</ng-container> <ng-template #addOnBeforeTemplate> <ng-template [ngTemplateOutlet]="nzAddOnBefore"></ng-template> </ng-template> </span> <ng-template *ngTemplateOutlet="contentTemplate"></ng-template> <span class="ant-input-group-addon" *ngIf="nzAddOnAfter || nzAddOnAfterIcon"> <i [ngClass]="nzAddOnAfterIcon" *ngIf="nzAddOnAfterIcon"></i> <ng-container *ngIf="isAddOnAfterString; else addOnAfterTemplate">{{ nzAddOnAfter }}</ng-container> <ng-template #addOnAfterTemplate> <ng-template [ngTemplateOutlet]="nzAddOnAfter"></ng-template> </ng-template> </span> </span> <ng-template [ngIf]="isAffix"> <span class="ant-input-prefix" *ngIf="nzPrefix || nzPrefixIcon"> <i [ngClass]="nzPrefixIcon" *ngIf="nzPrefixIcon"></i> <ng-container *ngIf="isPrefixString; else prefixTemplate">{{ nzPrefix }}</ng-container> <ng-template #prefixTemplate> <ng-template [ngTemplateOutlet]="nzPrefix"></ng-template> </ng-template> </span> <ng-template *ngTemplateOutlet="contentTemplate"></ng-template> <span class="ant-input-suffix" *ngIf="nzSuffix || nzSuffixIcon"> <i [ngClass]="nzSuffixIcon" *ngIf="nzSuffixIcon"></i> <ng-container *ngIf="isSuffixString; else suffixTemplate">{{ nzSuffix }}</ng-container> <ng-template #suffixTemplate> <ng-template [ngTemplateOutlet]="nzSuffix"></ng-template> </ng-template> </span> </ng-template> <ng-template [ngIf]="isGroup" *ngTemplateOutlet="contentTemplate"></ng-template> <ng-template #contentTemplate> <ng-content></ng-content> </ng-template>`
            },] },
];
/** @nocollapse */
NzInputGroupComponent.ctorParameters = () => [
    { type: ElementRef }
];
NzInputGroupComponent.propDecorators = {
    nzInputDirectiveQueryList: [{ type: ContentChildren, args: [NzInputDirective,] }],
    nzAddOnBeforeIcon: [{ type: Input }],
    nzAddOnAfterIcon: [{ type: Input }],
    nzPrefixIcon: [{ type: Input }],
    nzSuffixIcon: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzCompact: [{ type: Input }, { type: HostBinding, args: [`class.ant-input-group-compact`,] }],
    nzAddOnBefore: [{ type: Input }],
    nzAddOnAfter: [{ type: Input }],
    nzPrefix: [{ type: Input }],
    nzSuffix: [{ type: Input }],
    nzSearch: [{ type: Input }, { type: HostBinding, args: [`class.ant-input-search-enter-button`,] }, { type: HostBinding, args: [`class.ant-input-search`,] }],
    isAffix: [{ type: HostBinding, args: ['class.ant-input-affix-wrapper',] }],
    isAddOn: [{ type: HostBinding, args: ['class.ant-input-group-wrapper',] }],
    isGroup: [{ type: HostBinding, args: ['class.ant-input-group',] }],
    isLargeGroup: [{ type: HostBinding, args: [`class.ant-input-group-lg`,] }],
    isLargeGroupWrapper: [{ type: HostBinding, args: [`class.ant-input-group-wrapper-lg`,] }],
    isLargeAffix: [{ type: HostBinding, args: [`class.ant-input-affix-wrapper-lg`,] }],
    isLargeSearch: [{ type: HostBinding, args: [`class.ant-input-search-lg`,] }],
    isSmallGroup: [{ type: HostBinding, args: [`class.ant-input-group-sm`,] }],
    isSmallAffix: [{ type: HostBinding, args: [`class.ant-input-affix-wrapper-sm`,] }],
    isSmallGroupWrapper: [{ type: HostBinding, args: [`class.ant-input-group-wrapper-sm`,] }],
    isSmallSearch: [{ type: HostBinding, args: [`class.ant-input-search-sm`,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzInputModule {
}
NzInputModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzInputDirective, NzInputGroupComponent],
                exports: [NzInputDirective, NzInputGroupComponent],
                imports: [CommonModule, FormsModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const POSITION_MAP = /** @type {?} */ (({
    'top': {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom'
    },
    'topCenter': {
        originX: 'center',
        originY: 'top',
        overlayX: 'center',
        overlayY: 'bottom'
    },
    'topLeft': {
        originX: 'start',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'bottom'
    },
    'topRight': {
        originX: 'end',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'bottom'
    },
    'right': {
        originX: 'end',
        originY: 'center',
        overlayX: 'start',
        overlayY: 'center',
    },
    'rightTop': {
        originX: 'end',
        originY: 'top',
        overlayX: 'start',
        overlayY: 'top',
    },
    'rightBottom': {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'bottom',
    },
    'bottom': {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
    },
    'bottomCenter': {
        originX: 'center',
        originY: 'bottom',
        overlayX: 'center',
        overlayY: 'top',
    },
    'bottomLeft': {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'top',
    },
    'bottomRight': {
        originX: 'end',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'top',
    },
    'left': {
        originX: 'start',
        originY: 'center',
        overlayX: 'end',
        overlayY: 'center',
    },
    'leftTop': {
        originX: 'start',
        originY: 'top',
        overlayX: 'end',
        overlayY: 'top',
    },
    'leftBottom': {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'end',
        overlayY: 'bottom',
    },
}));
// TODO: The whole logic does not make sense here, _objectValues just returns a copy of original array
const DEFAULT_4_POSITIONS = _objectValues([POSITION_MAP["top"], POSITION_MAP["right"], POSITION_MAP["bottom"], POSITION_MAP["left"]]);
const DEFAULT_DROPDOWN_POSITIONS = _objectValues([POSITION_MAP["bottomLeft"], POSITION_MAP["topLeft"]]);
// export const DEFAULT_DATEPICKER_POSITIONS = [
//   {
//     originX : 'start',
//     originY : 'top',
//     overlayX: 'start',
//     overlayY: 'top',
//   },
//   {
//     originX : 'start',
//     originY : 'bottom',
//     overlayX: 'start',
//     overlayY: 'bottom',
//   }
// ] as ConnectionPositionPair[];
const DEFAULT_MENTION_POSITIONS = /** @type {?} */ ([
    POSITION_MAP["bottomLeft"],
    {
        originX: 'start',
        originY: 'bottom',
        overlayX: 'start',
        overlayY: 'bottom'
    }
]);
/**
 * @template T, S
 * @param {?} array
 * @param {?} iteratee
 * @return {?}
 */
function arrayMap(array, iteratee) {
    let /** @type {?} */ index = -1;
    const /** @type {?} */ length = array == null ? 0 : array.length;
    const /** @type {?} */ result = Array(length);
    while (++index < length) {
        result[index] = iteratee(array[index], index, array);
    }
    return result;
}
/**
 * @template T
 * @param {?} object
 * @param {?} props
 * @return {?}
 */
function baseValues(object, props) {
    return arrayMap(props, (key) => {
        return object[key];
    });
}
/**
 * @template T
 * @param {?} object
 * @return {?}
 */
function _objectValues(object) {
    return object == null ? [] : baseValues(object, Object.keys(object));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @template T
 * @param {?} value
 * @return {?}
 */
function toArray(value) {
    let /** @type {?} */ ret;
    if (value == null) {
        ret = [];
    }
    else if (!Array.isArray(value)) {
        ret = [value];
    }
    else {
        ret = value;
    }
    return ret;
}
/**
 * @template T
 * @param {?} array1
 * @param {?} array2
 * @return {?}
 */
function arrayEquals(array1, array2) {
    if (!array1 || !array2 || array1.length !== array2.length) {
        return false;
    }
    const /** @type {?} */ len = array1.length;
    for (let /** @type {?} */ i = 0; i < len; i++) {
        if (array1[i] !== array2[i]) {
            return false;
        }
    }
    return true;
}
const defaultDisplayRender = label => label.join(' / ');
/**
 * @record
 */

class NzCascaderComponent {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} nzUpdateHostClassService
     */
    constructor(elementRef, cdr, nzUpdateHostClassService) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.nzUpdateHostClassService = nzUpdateHostClassService;
        this.allowClear = true;
        this.autoFocus = false;
        this.disabled = false;
        this.enableCache = true;
        this.showArrow = true;
        this.showInput = true;
        this.size = 'default';
        this.prefixCls = 'ant-cascader';
        this.inputPrefixCls = 'ant-input';
        this.changeOnSelect = false;
        this.dropDownPosition = 'bottom';
        this.menuVisible = false;
        this.isLoading = false;
        this.isOpening = false;
        this.isFocused = false;
        this.isLabelRenderTemplate = false;
        this.labelRenderContext = {};
        this.selectedOptions = [];
        this.activatedOptions = [];
        this.nzColumns = [];
        /**
         * 搜索相关的输入值
         */
        this._inputValue = '';
        // ngModel Access
        this.onChange = Function.prototype;
        this.onTouched = Function.prototype;
        this.positions = [...DEFAULT_DROPDOWN_POSITIONS];
        /**
         * Hover text for the clear icon
         */
        this.nzClearText = 'Clear';
        /**
         * Expand column item when click or hover, one of 'click' 'hover'
         */
        this.nzExpandTrigger = 'click';
        /**
         * Specify content to show when no result matches.
         */
        this.nzNotFoundContent = 'Not Found';
        /**
         * Input placeholder
         */
        this.nzPlaceHolder = 'Please select';
        /**
         * Delay time to show when mouse enter, when `nzExpandTrigger` is `hover`.
         */
        this.nzMouseEnterDelay = 150;
        /**
         * Delay time to hide when mouse enter, when `nzExpandTrigger` is `hover`.
         */
        this.nzMouseLeaveDelay = 150;
        /**
         * Triggering mode: can be Array<'click'|'hover'>
         */
        this.nzTriggerAction = ['click'];
        /**
         * Property name for getting `value` in the option
         */
        this.nzValueProperty = 'value';
        /**
         * Property name for getting `label` in the option
         */
        this.nzLabelProperty = 'label';
        /**
         * Event: emit on popup show or hide
         */
        this.nzVisibleChange = new EventEmitter();
        /**
         * Event: emit on values changed
         */
        this.nzChange = new EventEmitter();
        /**
         * Event: emit on values and selection changed
         */
        this.nzSelectionChange = new EventEmitter();
        /**
         * Event: emit on option selected, event data：{option: any, index: number}
         */
        this.nzSelect = new EventEmitter();
        /**
         * Event: emit on the clear button clicked
         */
        this.nzClear = new EventEmitter();
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    get inputValue() {
        return this._inputValue;
    }
    /**
     * @param {?} inputValue
     * @return {?}
     */
    set inputValue(inputValue) {
        this._inputValue = inputValue;
        this.setClassMap();
    }
    /**
     * Display Render ngTemplate
     * @param {?} value
     * @return {?}
     */
    set nzLabelRender(value) {
        this.labelRenderTpl = value;
        this.isLabelRenderTemplate = (value instanceof TemplateRef);
    }
    /**
     * @return {?}
     */
    get nzLabelRender() {
        return this.labelRenderTpl;
    }
    /**
     * prefixCls
     * @param {?} prefixCls
     * @return {?}
     */
    set nzPrefixCls(prefixCls) {
        this.prefixCls = prefixCls;
        this.setClassMap();
        this.setLabelClass();
        this.setArrowClass();
        this.setLoadingClass();
        this.setClearClass();
        this.setInputClass();
        this.setMenuClass();
        this.setMenuColumnClass();
    }
    /**
     * @return {?}
     */
    get nzPrefixCls() {
        return this.prefixCls;
    }
    /**
     * Whether is disabled
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this.disabled = toBoolean(value);
        this.setClassMap();
        this.setInputClass();
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this.disabled;
    }
    /**
     * Input size, one of `large` `default` `small`
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this.size = value;
        this.setClassMap();
        this.setInputClass();
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this.size;
    }
    /**
     * Whether show input box. Defaults to `true`.
     * @param {?} value
     * @return {?}
     */
    set nzShowInput(value) {
        this.showInput = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowInput() {
        return this.showInput;
    }
    /**
     * Whether allow clear. Defaults to `true`.
     * @param {?} value
     * @return {?}
     */
    set nzAllowClear(value) {
        this.allowClear = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzAllowClear() {
        return this.allowClear;
    }
    /**
     * Whether auto focus.
     * @param {?} value
     * @return {?}
     */
    set nzAutoFocus(value) {
        this.autoFocus = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzAutoFocus() {
        return this.autoFocus;
    }
    /**
     * Whether to show arrow
     * @param {?} value
     * @return {?}
     */
    set nzShowArrow(value) {
        this.showArrow = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowArrow() {
        return this.showArrow;
    }
    /**
     * Additional className of popup overlay
     * @param {?} value
     * @return {?}
     */
    set nzMenuClassName(value) {
        this.menuClassName = value;
        this.setMenuClass();
    }
    /**
     * @return {?}
     */
    get nzMenuClassName() {
        return this.menuClassName;
    }
    /**
     * Additional className of popup overlay column
     * @param {?} value
     * @return {?}
     */
    set nzColumnClassName(value) {
        this.columnClassName = value;
        this.setMenuColumnClass();
    }
    /**
     * @return {?}
     */
    get nzColumnClassName() {
        return this.columnClassName;
    }
    /**
     * Options for first column, sub column will be load async
     * @param {?} options
     * @return {?}
     */
    set nzOptions(options) {
        this.nzColumns = options && options.length ? [options] : [];
        if (this.defaultValue && this.nzColumns.length) {
            this.initOptions(0);
        }
    }
    /**
     * @return {?}
     */
    get nzOptions() {
        return this.nzColumns[0];
    }
    /**
     * Change value on each selection if set to true
     * @param {?} value
     * @return {?}
     */
    set nzChangeOnSelect(value) {
        this.changeOnSelect = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzChangeOnSelect() {
        return this.changeOnSelect;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    onPositionChange(position) {
        const /** @type {?} */ newValue = position.connectionPair.originY === 'bottom' ? 'bottom' : 'top';
        if (this.dropDownPosition !== newValue) {
            this.dropDownPosition = newValue;
            this.cdr.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    focus() {
        if (!this.isFocused) {
            const /** @type {?} */ input = /** @type {?} */ (this.el.querySelector(`.${this.prefixCls}-input`));
            if (input && input.focus) {
                input.focus();
            }
            else {
                this.el.focus();
            }
            this.isFocused = true;
            this.setClassMap();
        }
    }
    /**
     * @return {?}
     */
    blur() {
        if (this.isFocused) {
            const /** @type {?} */ input = /** @type {?} */ (this.el.querySelector(`.${this.prefixCls}-input`));
            if (input && input.blur) {
                input.blur();
            }
            else {
                this.el.blur();
            }
            this.isFocused = false;
            this.setClassMap();
        }
    }
    /**
     * @return {?}
     */
    setClassMap() {
        const /** @type {?} */ classMap = {
            [`${this.prefixCls}`]: 1,
            [`${this.prefixCls}-picker`]: 1,
            [`${this.prefixCls}-lg`]: this.nzSize === 'large',
            [`${this.prefixCls}-sm`]: this.nzSize === 'small',
            [`${this.prefixCls}-picker-disabled`]: this.disabled,
            [`${this.prefixCls}-focused`]: this.isFocused,
            [`${this.prefixCls}-picker-open`]: this.menuVisible,
            [`${this.prefixCls}-picker-with-value`]: this.inputValue && this.inputValue.length
        };
        this.nzUpdateHostClassService.updateHostClass(this.el, classMap);
    }
    /**
     * 标签 样式
     * @return {?}
     */
    get labelCls() {
        return this._labelCls;
    }
    /**
     * @return {?}
     */
    setLabelClass() {
        this._labelCls = {
            [`${this.prefixCls}-picker-label`]: true
        };
    }
    /**
     * 箭头 样式
     * @return {?}
     */
    get arrowCls() {
        return this._arrowCls;
    }
    /**
     * @return {?}
     */
    setArrowClass() {
        this._arrowCls = {
            [`${this.prefixCls}-picker-arrow`]: true,
            [`${this.prefixCls}-picker-arrow-expand`]: this.menuVisible
        };
    }
    /**
     * 加载中图标 样式
     * @return {?}
     */
    get loadingCls() {
        return this._loadingCls;
    }
    /**
     * @return {?}
     */
    setLoadingClass() {
        this._loadingCls = {
            [`${this.prefixCls}-picker-arrow`]: true
        };
    }
    /**
     * 清除图标 样式
     * @return {?}
     */
    get clearCls() {
        return this._clearCls;
    }
    /**
     * @return {?}
     */
    setClearClass() {
        this._clearCls = {
            [`${this.prefixCls}-picker-clear`]: true
        };
    }
    /**
     * 输入框 样式
     * @return {?}
     */
    get inputCls() {
        return this._inputCls;
    }
    /**
     * @return {?}
     */
    setInputClass() {
        this._inputCls = {
            [`${this.prefixCls}-input`]: 1,
            [`${this.inputPrefixCls}-disabled`]: this.nzDisabled,
            [`${this.inputPrefixCls}-lg`]: this.nzSize === 'large',
            [`${this.inputPrefixCls}-sm`]: this.nzSize === 'small'
        };
    }
    /**
     * 浮层 样式
     * @return {?}
     */
    get menuCls() {
        return this._menuCls;
    }
    /**
     * @return {?}
     */
    setMenuClass() {
        this._menuCls = {
            [`${this.prefixCls}-menus`]: true,
            [`${this.prefixCls}-menus-hidden`]: !this.menuVisible,
            [`${this.nzMenuClassName}`]: this.nzMenuClassName
        };
    }
    /**
     * 浮层列 样式
     * @return {?}
     */
    get menuColumnCls() {
        return this._menuColumnCls;
    }
    /**
     * @return {?}
     */
    setMenuColumnClass() {
        this._menuColumnCls = {
            [`${this.prefixCls}-menu`]: true,
            [`${this.nzColumnClassName}`]: this.nzColumnClassName
        };
    }
    /**
     * 获取列中Option的样式
     * @param {?} option
     * @param {?} index
     * @return {?}
     */
    getOptionCls(option, index) {
        return {
            [`${this.prefixCls}-menu-item`]: true,
            [`${this.prefixCls}-menu-item-expand`]: !option.isLeaf,
            [`${this.prefixCls}-menu-item-active`]: this.isActivedOption(option, index),
            [`${this.prefixCls}-menu-item-disabled`]: option.disabled,
            [`${this.prefixCls}-menu-item-loading`]: option.loading
        };
    }
    /**
     * prevent input change event
     * @param {?} event
     * @return {?}
     */
    handlerInputChange(event) {
        event.stopPropagation();
    }
    /**
     * input element blur
     * @param {?} event
     * @return {?}
     */
    handleInputBlur(event) {
        /*
            if (!this.nzShowSearch) {
              return;
            }
            */
        if (this.menuVisible) {
            this.focus(); // keep input has focus when menu opened
        }
        else {
            this.blur();
        }
    }
    /**
     * input element focus
     * @param {?} event
     * @return {?}
     */
    handleInputFocus(event) {
        /*
            if (!this.nzShowSearch) {
              return;
            }
            */
        this.focus();
    }
    /**
     * @return {?}
     */
    hasInput() {
        return this.inputValue.length > 0;
    }
    /**
     * @return {?}
     */
    hasValue() {
        return this.value && this.value.length > 0;
    }
    /**
     * Whether to show input element placeholder
     * @return {?}
     */
    get showPlaceholder() {
        return !(this.hasInput() || this.hasValue());
    }
    /**
     * Whether the clear button is visible
     * @return {?}
     */
    get showClearIcon() {
        const /** @type {?} */ isHasValue = this.hasValue();
        const /** @type {?} */ isHasInput = this.hasInput();
        return this.nzAllowClear && !this.nzDisabled && (isHasValue || isHasInput);
    }
    /**
     * clear the input box and selected options
     * @param {?=} event
     * @return {?}
     */
    clearSelection(event) {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        this.labelRenderText = '';
        // this.isLabelRenderTemplate = false;
        // clear custom context
        this.labelRenderContext = {};
        this.selectedOptions = [];
        this.activatedOptions = [];
        this.inputValue = '';
        this.setMenuVisible(false);
        // trigger change event
        this.onValueChange();
    }
    /**
     * @return {?}
     */
    buildDisplayLabel() {
        const /** @type {?} */ selectedOptions = this.selectedOptions;
        const /** @type {?} */ labels = selectedOptions.map(o => this.getOptionLabel(o));
        // 设置当前控件的显示值
        if (this.isLabelRenderTemplate) {
            this.labelRenderContext = { labels, selectedOptions };
        }
        else {
            this.labelRenderText = defaultDisplayRender.call(this, labels, selectedOptions);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        const /** @type {?} */ keyCode = event.keyCode;
        if (keyCode !== DOWN_ARROW &&
            keyCode !== UP_ARROW &&
            keyCode !== LEFT_ARROW &&
            keyCode !== RIGHT_ARROW &&
            keyCode !== ENTER &&
            keyCode !== BACKSPACE &&
            keyCode !== ESCAPE) {
            return;
        }
        // Press any keys above to reopen menu
        if (!this.isMenuVisible() &&
            keyCode !== BACKSPACE &&
            keyCode !== ESCAPE) {
            this.setMenuVisible(true);
            return;
        }
        // Press ESC to close menu
        if (keyCode === ESCAPE) {
            // this.setMenuVisible(false); // already call by cdk-overlay detach
            return;
        }
        if (this.isMenuVisible()) {
            event.preventDefault();
            if (keyCode === DOWN_ARROW) {
                this.moveDown();
            }
            else if (keyCode === UP_ARROW) {
                this.moveUp();
            }
            else if (keyCode === LEFT_ARROW) {
                this.moveLeft();
            }
            else if (keyCode === RIGHT_ARROW) {
                this.moveRight();
            }
            else if (keyCode === ENTER) {
                this.onEnter();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTriggerClick(event) {
        if (this.nzDisabled) {
            return;
        }
        this.onTouched(); // set your control to 'touched'
        if (this.isClickTiggerAction()) {
            this.delaySetMenuVisible(!this.menuVisible, 100);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTriggerMouseEnter(event) {
        if (this.nzDisabled) {
            return;
        }
        if (this.isPointerTiggerAction()) {
            this.delaySetMenuVisible(true, this.nzMouseEnterDelay, true);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTriggerMouseLeave(event) {
        if (this.nzDisabled) {
            return;
        }
        if (!this.isMenuVisible() || this.isOpening) {
            event.preventDefault();
            return;
        }
        if (this.isPointerTiggerAction()) {
            const /** @type {?} */ mouseTarget = /** @type {?} */ (event.relatedTarget);
            const /** @type {?} */ hostEl = this.el;
            const /** @type {?} */ menuEl = this.menu && /** @type {?} */ (this.menu.nativeElement);
            if (hostEl.contains(mouseTarget) || (menuEl && menuEl.contains(mouseTarget))) {
                // 因为浮层的backdrop出现，暂时没有办法自动消失
                return;
            }
            this.delaySetMenuVisible(false, this.nzMouseLeaveDelay);
        }
    }
    /**
     * @return {?}
     */
    isClickTiggerAction() {
        if (typeof this.nzTriggerAction === 'string') {
            return this.nzTriggerAction === 'click';
        }
        return this.nzTriggerAction.indexOf('click') !== -1;
    }
    /**
     * @return {?}
     */
    isPointerTiggerAction() {
        if (typeof this.nzTriggerAction === 'string') {
            return this.nzTriggerAction === 'hover';
        }
        return this.nzTriggerAction.indexOf('hover') !== -1;
    }
    /**
     * @return {?}
     */
    closeMenu() {
        this.clearDelayTimer();
        this.setMenuVisible(false);
    }
    /**
     * @return {?}
     */
    clearDelayTimer() {
        if (this.delayTimer) {
            clearTimeout(this.delayTimer);
            this.delayTimer = null;
        }
    }
    /**
     * 显示或者隐藏菜单
     *
     * @param {?} visible true-显示，false-隐藏
     * @param {?} delay 延迟时间
     * @param {?=} setOpening
     * @return {?}
     */
    delaySetMenuVisible(visible, delay$$1, setOpening = false) {
        this.clearDelayTimer();
        if (delay$$1) {
            if (visible && setOpening) {
                this.isOpening = true;
            }
            this.delayTimer = setTimeout(() => {
                this.setMenuVisible(visible);
                this.clearDelayTimer();
                if (visible) {
                    setTimeout(() => {
                        this.isOpening = false;
                    }, 100);
                }
            }, delay$$1);
        }
        else {
            this.setMenuVisible(visible);
        }
    }
    /**
     * @return {?}
     */
    isMenuVisible() {
        return this.menuVisible;
    }
    /**
     * @param {?} menuVisible
     * @return {?}
     */
    setMenuVisible(menuVisible) {
        if (this.nzDisabled) {
            return;
        }
        if (this.menuVisible !== menuVisible) {
            this.menuVisible = menuVisible;
            // update class
            this.setClassMap();
            this.setArrowClass();
            this.setMenuClass();
            if (menuVisible) {
                this.beforeVisible();
            }
            this.nzVisibleChange.emit(menuVisible);
        }
    }
    /**
     * load init data if necessary
     * @return {?}
     */
    beforeVisible() {
        this.loadRootOptions();
    }
    /**
     * @return {?}
     */
    loadRootOptions() {
        if (!this.nzColumns.length) {
            const /** @type {?} */ root = {};
            this.loadChildren(root, -1);
        }
    }
    /**
     * 获取Option的值，例如，可以指定labelProperty="name"来取Name
     * @param {?} option
     * @return {?}
     */
    getOptionLabel(option) {
        return option[this.nzLabelProperty || 'label'];
    }
    /**
     * 获取Option的值，例如，可以指定valueProperty="id"来取ID
     * @param {?} option
     * @return {?}
     */
    getOptionValue(option) {
        return option[this.nzValueProperty || 'value'];
    }
    /**
     * @param {?} option
     * @param {?} index
     * @return {?}
     */
    isActivedOption(option, index) {
        const /** @type {?} */ activeOpt = this.activatedOptions[index];
        return activeOpt === option;
    }
    /**
     * 设置某列的激活的菜单选项
     *
     * @param {?} option 菜单选项
     * @param {?} index  选项所在的列组的索引
     * @param {?=} select 是否触发选择结点
     * @param {?=} loadChildren
     * @return {?}
     */
    setActiveOption(option, index, select = false, loadChildren = true) {
        if (!option || option.disabled) {
            return;
        }
        this.activatedOptions[index] = option;
        // 当直接选择最后一级时，前面的选项要补全。例如，选择“城市”，则自动补全“国家”、“省份”
        for (let /** @type {?} */ i = index - 1; i >= 0; i--) {
            if (!this.activatedOptions[i]) {
                this.activatedOptions[i] = this.activatedOptions[i + 1].parent;
            }
        }
        // 截断多余的选项，如选择“省份”，则只会有“国家”、“省份”，去掉“城市”、“区县”
        if (index < this.activatedOptions.length - 1) {
            this.activatedOptions = this.activatedOptions.slice(0, index + 1);
        }
        // load children
        if (option.children && option.children.length) {
            option.isLeaf = false;
            option.children.forEach(child => child.parent = option);
            this.setColumnData(option.children, index + 1);
        }
        else if (!option.isLeaf && loadChildren) {
            this.loadChildren(option, index);
        }
        else {
            // clicking leaf node will remove any children columns
            if (index < this.nzColumns.length - 1) {
                this.nzColumns = this.nzColumns.slice(0, index + 1);
            }
        }
        // trigger select event, and display label
        if (select) {
            this.onSelectOption(option, index);
        }
    }
    /**
     * @param {?} option
     * @param {?} index
     * @param {?=} success
     * @param {?=} failure
     * @return {?}
     */
    loadChildren(option, index, success, failure) {
        if (this.nzLoadData) {
            this.isLoading = index < 0;
            option.loading = true;
            this.nzLoadData(option, index).then(() => {
                option.loading = this.isLoading = false;
                if (option.children) {
                    option.children.forEach(child => child.parent = index < 0 ? undefined : option);
                    this.setColumnData(option.children, index + 1);
                }
                if (success) {
                    success();
                }
            }, () => {
                option.loading = this.isLoading = false;
                option.isLeaf = true;
                if (failure) {
                    failure();
                }
            });
        }
    }
    /**
     * @param {?} option
     * @param {?} index
     * @return {?}
     */
    onSelectOption(option, index) {
        // trigger `nzSelect` event
        this.nzSelect.emit({ option, index });
        // 生成显示
        if (option.isLeaf || this.nzChangeOnSelect || this.isChangeOn(option, index)) {
            this.selectedOptions = this.activatedOptions;
            // 设置当前控件的显示值
            this.buildDisplayLabel();
            // 触发变更事件
            this.onValueChange();
        }
        // close menu if click on leaf
        if (option.isLeaf) {
            this.delaySetMenuVisible(false, this.nzMouseLeaveDelay);
        }
    }
    /**
     * 由用户来定义点击后是否变更
     * @param {?} option
     * @param {?} index
     * @return {?}
     */
    isChangeOn(option, index) {
        if (typeof this.nzChangeOn === 'function') {
            return this.nzChangeOn(option, index) === true;
        }
        return false;
    }
    /**
     * @param {?} options
     * @param {?} index
     * @return {?}
     */
    setColumnData(options, index) {
        if (!arrayEquals(this.nzColumns[index], options)) {
            this.nzColumns[index] = options;
            if (index < this.nzColumns.length - 1) {
                this.nzColumns = this.nzColumns.slice(0, index + 1);
            }
        }
    }
    /**
     * 鼠标点击选项
     *
     * @param {?} option 菜单选项
     * @param {?} index 选项所在的列组的索引
     * @param {?} event 鼠标事件
     * @return {?}
     */
    onOptionClick(option, index, event) {
        event.preventDefault();
        // Keep focused state for keyboard support
        this.el.focus();
        if (option && option.disabled) {
            return;
        }
        this.setActiveOption(option, index, true);
    }
    /**
     * 按下回车键时选择
     * @return {?}
     */
    onEnter() {
        const /** @type {?} */ columnIndex = Math.max(this.activatedOptions.length - 1, 0);
        const /** @type {?} */ activeOption = this.activatedOptions[columnIndex];
        if (activeOption && !activeOption.disabled) {
            this.onSelectOption(activeOption, columnIndex);
        }
    }
    /**
     * press `up` or `down` arrow to activate the sibling option.
     * @param {?} isUp
     * @return {?}
     */
    moveUpOrDown(isUp) {
        const /** @type {?} */ columnIndex = Math.max(this.activatedOptions.length - 1, 0);
        // 该组中已经被激活的选项
        const /** @type {?} */ activeOption = this.activatedOptions[columnIndex];
        // 该组所有的选项，用于遍历获取下一个被激活的选项
        const /** @type {?} */ options = this.nzColumns[columnIndex] || [];
        const /** @type {?} */ length = options.length;
        let /** @type {?} */ nextIndex = -1;
        if (!activeOption) {
            // 该列还没有选中的选项
            nextIndex = isUp ? length : -1;
        }
        else {
            nextIndex = options.indexOf(activeOption);
        }
        while (true) {
            nextIndex = isUp ? nextIndex - 1 : nextIndex + 1;
            if (nextIndex < 0 || nextIndex >= length) {
                break;
            }
            const /** @type {?} */ nextOption = options[nextIndex];
            if (!nextOption || nextOption.disabled) {
                continue;
            }
            this.setActiveOption(nextOption, columnIndex);
            break;
        }
    }
    /**
     * @return {?}
     */
    moveUp() {
        this.moveUpOrDown(true);
    }
    /**
     * @return {?}
     */
    moveDown() {
        this.moveUpOrDown(false);
    }
    /**
     * press `left` arrow to remove the last selected option.
     * @return {?}
     */
    moveLeft() {
        const /** @type {?} */ options = this.activatedOptions;
        if (options.length) {
            options.pop(); // Remove the last one
        }
    }
    /**
     * press `right` arrow to select the next column option.
     * @return {?}
     */
    moveRight() {
        const /** @type {?} */ length = this.activatedOptions.length;
        const /** @type {?} */ options = this.nzColumns[length];
        if (options && options.length) {
            const /** @type {?} */ nextOpt = options.find(o => !o.disabled);
            if (nextOpt) {
                this.setActiveOption(nextOpt, length);
            }
        }
    }
    /**
     * 鼠标划入选项
     *
     * @param {?} option 菜单选项
     * @param {?} index 选项所在的列组的索引
     * @param {?} event 鼠标事件
     * @return {?}
     */
    onOptionMouseEnter(option, index, event) {
        event.preventDefault();
        if (this.nzExpandTrigger === 'hover' && !option.isLeaf) {
            this.delaySelect(option, index, true);
        }
    }
    /**
     * 鼠标划出选项
     *
     * @param {?} option 菜单选项
     * @param {?} index 选项所在的列组的索引
     * @param {?} event 鼠标事件
     * @return {?}
     */
    onOptionMouseLeave(option, index, event) {
        event.preventDefault();
        if (this.nzExpandTrigger === 'hover' && !option.isLeaf) {
            this.delaySelect(option, index, false);
        }
    }
    /**
     * @return {?}
     */
    clearDelaySelectTimer() {
        if (this.delaySelectTimer) {
            clearTimeout(this.delaySelectTimer);
            this.delaySelectTimer = null;
        }
    }
    /**
     * @param {?} option
     * @param {?} index
     * @param {?} doSelect
     * @return {?}
     */
    delaySelect(option, index, doSelect) {
        this.clearDelaySelectTimer();
        if (doSelect) {
            this.delaySelectTimer = setTimeout(() => {
                this.setActiveOption(option, index, true);
                this.delaySelectTimer = null;
            }, 150);
        }
    }
    /**
     * @return {?}
     */
    getSubmitValue() {
        const /** @type {?} */ values = [];
        this.selectedOptions.forEach(option => {
            values.push(this.getOptionValue(option));
        });
        return values;
    }
    /**
     * @return {?}
     */
    onValueChange() {
        const /** @type {?} */ value = this.getSubmitValue();
        if (!arrayEquals(this.value, value)) {
            this.defaultValue = null; // clear the init-value
            this.value = value;
            this.onChange(value); // Angular need this
            if (value.length === 0) {
                this.nzClear.emit(); // first trigger `clear` and then `change`
            }
            this.nzSelectionChange.emit(this.selectedOptions);
            this.nzChange.emit(value);
        }
    }
    /**
     * @param {?} option
     * @param {?} index
     * @return {?}
     */
    findOption(option, index) {
        const /** @type {?} */ options = this.nzColumns[index];
        if (options) {
            const /** @type {?} */ value = typeof option === 'object' ? this.getOptionValue(option) : option;
            return options.find(o => value === this.getOptionValue(o));
        }
        return null;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    isLoaded(index) {
        return this.nzColumns[index] && this.nzColumns[index].length > 0;
    }
    /**
     * @param {?} index
     * @param {?} value
     * @return {?}
     */
    activateOnInit(index, value) {
        let /** @type {?} */ option = this.findOption(value, index);
        if (!option) {
            option = typeof value === 'object' ? value : {
                [`${this.nzValueProperty || 'value'}`]: value,
                [`${this.nzLabelProperty || 'label'}`]: value
            };
        }
        this.setActiveOption(option, index, false, false);
    }
    /**
     * @param {?} index
     * @return {?}
     */
    initOptions(index) {
        const /** @type {?} */ vs = this.defaultValue;
        const /** @type {?} */ load = () => {
            this.activateOnInit(index, vs[index]);
            if (index < vs.length - 1) {
                this.initOptions(index + 1);
            }
            if (index === vs.length - 1) {
                this.afterWriteValue();
            }
        };
        if (this.isLoaded(index) || !this.nzLoadData) {
            load();
        }
        else {
            const /** @type {?} */ node = this.activatedOptions[index - 1] || {};
            this.loadChildren(node, index - 1, load, this.afterWriteValue);
        }
    }
    /**
     * @return {?}
     */
    afterWriteValue() {
        this.selectedOptions = this.activatedOptions;
        this.value = this.getSubmitValue();
        this.buildDisplayLabel();
    }
    /**
     * Write a new value to the element.
     *
     * \@Override (From ControlValueAccessor interface)
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        const /** @type {?} */ vs = this.defaultValue = toArray(value);
        if (vs.length) {
            this.initOptions(0);
        }
        else {
            this.value = vs;
            this.activatedOptions = [];
            this.afterWriteValue();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        if (isDisabled) {
            this.closeMenu();
        }
        this.nzDisabled = isDisabled;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // 设置样式
        this.setClassMap();
        this.setLabelClass();
        this.setArrowClass();
        this.setLoadingClass();
        this.setClearClass();
        this.setInputClass();
        this.setMenuClass();
        this.setMenuColumnClass();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.clearDelayTimer();
        this.clearDelaySelectTimer();
    }
}
NzCascaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-cascader,[nz-cascader]',
                preserveWhitespaces: false,
                animations: [
                    dropDownAnimation
                ],
                template: `<div cdkOverlayOrigin #origin="cdkOverlayOrigin" #trigger> <div *ngIf="nzShowInput"> <input #input nz-input [attr.autoComplete]="'off'" [attr.placeholder]="showPlaceholder ? nzPlaceHolder : null" [attr.autofocus]="nzAutoFocus ? 'autofocus' : null" [readonly]="!nzShowSearch" [disabled]="nzDisabled" [nzSize]="nzSize" [ngClass]="inputCls" [(ngModel)]="inputValue" (blur)="handleInputBlur($event)" (focus)="handleInputFocus($event)" (change)="handlerInputChange($event)"> <i *ngIf="showClearIcon" [class]="'anticon anticon-cross-circle'" [ngClass]="clearCls" [attr.title]="nzClearText" (click)="clearSelection($event)"></i> <i *ngIf="nzShowArrow && !isLoading" class="anticon anticon-down" [ngClass]="arrowCls"></i> <i *ngIf="isLoading" class="anticon anticon-loading anticon-spin" [ngClass]="loadingCls"></i> <span [ngClass]="labelCls"> <ng-container *ngIf="!isLabelRenderTemplate; else labelTemplate">{{ labelRenderText }}</ng-container> <ng-template #labelTemplate> <ng-template [ngTemplateOutlet]="nzLabelRender" [ngTemplateOutletContext]="labelRenderContext"></ng-template> </ng-template> </span> </div> <ng-content></ng-content> </div> <ng-template cdkConnectedOverlay cdkConnectedOverlayHasBackdrop [cdkConnectedOverlayOrigin]="origin" [cdkConnectedOverlayPositions]="positions" (backdropClick)="closeMenu()" (detach)="closeMenu()" (positionChange)="onPositionChange($event)" [cdkConnectedOverlayOpen]="menuVisible"> <div #menu [ngClass]="menuCls" [ngStyle]="nzMenuStyle" [@dropDownAnimation]="dropDownPosition" (mouseleave)="onTriggerMouseLeave($event)"> <ul *ngFor="let options of nzColumns; let i = index;" [ngClass]="menuColumnCls"> <li *ngFor="let option of options" [attr.title]="option.title || getOptionLabel(option)" [ngClass]="getOptionCls(option, i)" (mouseenter)="onOptionMouseEnter(option, i, $event)" (mouseleave)="onOptionMouseLeave(option, i, $event)" (click)="onOptionClick(option, i, $event)"> {{ getOptionLabel(option) }} </li> </ul> </div> </ng-template>`,
                providers: [
                    NzUpdateHostClassService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzCascaderComponent),
                        multi: true
                    }
                ],
                host: {
                    '[attr.tabIndex]': '"0"'
                },
                styles: [
                    `.ant-cascader-menus {
      margin-top: 4px;
      margin-bottom: 4px;
      top: 100%;
      left: 0;
      position: relative;
      width: 100%;
    }`
                ]
            },] },
];
/** @nocollapse */
NzCascaderComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NzUpdateHostClassService }
];
NzCascaderComponent.propDecorators = {
    nzLabelRender: [{ type: Input }],
    nzPrefixCls: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzShowInput: [{ type: Input }],
    nzAllowClear: [{ type: Input }],
    nzAutoFocus: [{ type: Input }],
    nzShowArrow: [{ type: Input }],
    nzMenuClassName: [{ type: Input }],
    nzColumnClassName: [{ type: Input }],
    nzOptions: [{ type: Input }],
    nzChangeOnSelect: [{ type: Input }],
    nzClearText: [{ type: Input }],
    nzExpandTrigger: [{ type: Input }],
    nzNotFoundContent: [{ type: Input }],
    nzPlaceHolder: [{ type: Input }],
    nzMenuStyle: [{ type: Input }],
    nzChangeOn: [{ type: Input }],
    nzMouseEnterDelay: [{ type: Input }],
    nzMouseLeaveDelay: [{ type: Input }],
    nzTriggerAction: [{ type: Input }],
    nzValueProperty: [{ type: Input }],
    nzLabelProperty: [{ type: Input }],
    nzLoadData: [{ type: Input }],
    nzVisibleChange: [{ type: Output }],
    nzChange: [{ type: Output }],
    nzSelectionChange: [{ type: Output }],
    nzSelect: [{ type: Output }],
    nzClear: [{ type: Output }],
    menu: [{ type: ViewChild, args: ['menu',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onTriggerClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onTriggerMouseEnter: [{ type: HostListener, args: ['mouseenter', ['$event'],] }],
    onTriggerMouseLeave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCascaderModule {
}
NzCascaderModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, OverlayModule, NzInputModule],
                declarations: [
                    NzCascaderComponent
                ],
                exports: [
                    NzCascaderComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class NzCheckboxGroupComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._disabled = false;
        this.prefixCls = 'ant-checkbox-group';
        this.onChange = Function.prototype;
        this.onTouched = Function.prototype;
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @return {?}
     */
    onOptionChange() {
        this.onChange(this.options);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.options = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.renderer.addClass(this.el, `${this.prefixCls}`);
    }
}
NzCheckboxGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-checkbox-group',
                preserveWhitespaces: false,
                template: `<label nz-checkbox *ngFor="let option of options" [nzDisabled]="option.disabled||nzDisabled" [(nzChecked)]="option.checked" (nzCheckedChange)="onOptionChange()"> <span>{{ option.label }}</span> </label>`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzCheckboxGroupComponent),
                        multi: true
                    }
                ]
            },] },
];
/** @nocollapse */
NzCheckboxGroupComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NzCheckboxGroupComponent.propDecorators = {
    nzDisabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCheckboxWrapperComponent {
    constructor() {
        this.nzOnChange = new EventEmitter();
        this.checkboxList = [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    addCheckbox(value) {
        this.checkboxList.push(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    removeCheckbox(value) {
        this.checkboxList.splice(this.checkboxList.indexOf(value), 1);
    }
    /**
     * @return {?}
     */
    outputValue() {
        const /** @type {?} */ checkedList = this.checkboxList.filter(item => item.nzChecked);
        return checkedList.map(item => item.nzValue);
    }
    /**
     * @return {?}
     */
    onChange() {
        this.nzOnChange.emit(this.outputValue());
    }
}
NzCheckboxWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-checkbox-wrapper',
                preserveWhitespaces: false,
                template: `<ng-content></ng-content>`,
                host: {
                    '[class.ant-checkbox-group]': 'true'
                }
            },] },
];
NzCheckboxWrapperComponent.propDecorators = {
    nzOnChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCheckboxComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} nzCheckboxWrapperComponent
     */
    constructor(elementRef, renderer, nzCheckboxWrapperComponent) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.nzCheckboxWrapperComponent = nzCheckboxWrapperComponent;
        this._disabled = false;
        this._indeterminate = false;
        this._autoFocus = false;
        this._checked = false;
        this.isInit = false;
        this.prefixCls = 'ant-checkbox';
        this.onChange = Function.prototype;
        this.onTouched = Function.prototype;
        this.classMap = {};
        this.nzCheckedChange = new EventEmitter();
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAutoFocus(value) {
        this._autoFocus = toBoolean(value);
        this.updateAutoFocus();
    }
    /**
     * @return {?}
     */
    get nzAutoFocus() {
        return this._autoFocus;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzIndeterminate(value) {
        this._indeterminate = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzIndeterminate() {
        return this._indeterminate;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzChecked(value) {
        this._checked = value;
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    get nzChecked() {
        return this._checked;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        e.preventDefault();
        this.inputElement.nativeElement.focus();
        if (!this.nzDisabled) {
            this.updateValue(!this.nzChecked);
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.onTouched();
    }
    /**
     * @return {?}
     */
    updateAutoFocus() {
        if (this.isInit) {
            if (this.nzAutoFocus) {
                this.renderer.setAttribute(this.inputElement.nativeElement, 'autofocus', 'autofocus');
            }
            else {
                this.renderer.removeAttribute(this.inputElement.nativeElement, 'autofocus');
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this.onChange(value);
        this.nzCheckedChange.emit(value);
        this.nzChecked = value;
        if (this.nzCheckboxWrapperComponent) {
            this.nzCheckboxWrapperComponent.onChange();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.nzChecked = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
    }
    /**
     * @return {?}
     */
    updateClassMap() {
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-checked`]: this.nzChecked && (!this.nzIndeterminate),
            [`${this.prefixCls}-disabled`]: this.nzDisabled,
            [`${this.prefixCls}-indeterminate`]: this.nzIndeterminate
        };
    }
    /**
     * @return {?}
     */
    focus() {
        this.inputElement.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    blur() {
        this.inputElement.nativeElement.blur();
    }
    /**
     * @return {?}
     */
    checkContent() {
        if (isEmpty(this.contentElement.nativeElement)) {
            this.renderer.setStyle(this.contentElement.nativeElement, 'display', 'none');
        }
        else {
            this.renderer.removeStyle(this.contentElement.nativeElement, 'display');
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.renderer.addClass(this.el, `${this.prefixCls}-wrapper`);
        this.updateClassMap();
        if (this.nzCheckboxWrapperComponent) {
            this.nzCheckboxWrapperComponent.addCheckbox(this);
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.isInit = true;
        this.updateAutoFocus();
        this.checkContent();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.nzCheckboxWrapperComponent) {
            this.nzCheckboxWrapperComponent.removeCheckbox(this);
        }
    }
}
NzCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-checkbox]',
                preserveWhitespaces: false,
                template: `<span [ngClass]="classMap"> <input #inputElement [checked]="nzChecked" type="checkbox" class="ant-checkbox-input" (blur)="onBlur()"> <span class="ant-checkbox-inner"></span> </span> <span #contentElement (cdkObserveContent)="checkContent()"><ng-content></ng-content></span>`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzCheckboxComponent),
                        multi: true
                    }
                ]
            },] },
];
/** @nocollapse */
NzCheckboxComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NzCheckboxWrapperComponent, decorators: [{ type: Optional }] }
];
NzCheckboxComponent.propDecorators = {
    inputElement: [{ type: ViewChild, args: ['inputElement',] }],
    contentElement: [{ type: ViewChild, args: ['contentElement',] }],
    nzCheckedChange: [{ type: Output }],
    nzValue: [{ type: Input }],
    nzAutoFocus: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzIndeterminate: [{ type: Input }],
    nzChecked: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCheckboxModule {
}
NzCheckboxModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ObserversModule],
                declarations: [
                    NzCheckboxComponent,
                    NzCheckboxGroupComponent,
                    NzCheckboxWrapperComponent
                ],
                exports: [
                    NzCheckboxComponent,
                    NzCheckboxGroupComponent,
                    NzCheckboxWrapperComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCollapseComponent {
    constructor() {
        this._accordion = false;
        this._bordered = true;
        this.listOfPanel = [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAccordion(value) {
        this._accordion = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzAccordion() {
        return this._accordion;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzBordered(value) {
        this._bordered = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzBordered() {
        return this._bordered;
    }
    /**
     * @param {?} collapse
     * @return {?}
     */
    click(collapse) {
        if (this.nzAccordion) {
            this.listOfPanel.forEach(item => {
                const /** @type {?} */ active = collapse === item;
                if (item.nzActive !== active) {
                    item.nzActive = active;
                    item.nzActiveChange.emit(item.nzActive);
                }
            });
        }
        else {
            collapse.nzActive = !collapse.nzActive;
            collapse.nzActiveChange.emit(collapse.nzActive);
        }
    }
    /**
     * @param {?} collapse
     * @return {?}
     */
    addCollapse(collapse) {
        this.listOfPanel.push(collapse);
    }
    /**
     * @param {?} collapse
     * @return {?}
     */
    removeCollapse(collapse) {
        this.listOfPanel.splice(this.listOfPanel.indexOf(collapse), 1);
    }
}
NzCollapseComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-collapse',
                template: `<div class="ant-collapse" [class.ant-collapse-borderless]="!nzBordered"> <ng-content></ng-content> </div>`,
                styles: [
                    `:host {
      display: block;
    }`
                ]
            },] },
];
NzCollapseComponent.propDecorators = {
    nzAccordion: [{ type: Input }],
    nzBordered: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCollapsePanelComponent {
    /**
     * @param {?} nzCollapseComponent
     * @param {?} elementRef
     */
    constructor(nzCollapseComponent, elementRef) {
        this.nzCollapseComponent = nzCollapseComponent;
        this.elementRef = elementRef;
        this._disabled = false;
        this._showArrow = true;
        this._active = false;
        this.nzActiveChange = new EventEmitter();
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowArrow(value) {
        this._showArrow = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowArrow() {
        return this._showArrow;
    }
    /**
     * @return {?}
     */
    get isNoArrow() {
        return !this.nzShowArrow;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzHeader(value) {
        this.isHeaderString = !(value instanceof TemplateRef);
        this._header = value;
    }
    /**
     * @return {?}
     */
    get nzHeader() {
        return this._header;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzActive(value) {
        this._active = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzActive() {
        return this._active;
    }
    /**
     * @return {?}
     */
    clickHeader() {
        if (!this.nzDisabled) {
            this.nzCollapseComponent.click(this);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.nzCollapseComponent.addCollapse(this);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.nzCollapseComponent.removeCollapse(this);
    }
}
NzCollapsePanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-collapse-panel',
                template: `<div role="tab" [attr.aria-expanded]="nzActive" class="ant-collapse-header" (click)="clickHeader()"> <i class="arrow" *ngIf="nzShowArrow"></i> <ng-container *ngIf="isHeaderString; else headerTemplate">{{ nzHeader }}</ng-container> <ng-template #headerTemplate> <ng-template [ngTemplateOutlet]="nzHeader"></ng-template> </ng-template> </div> <div class="ant-collapse-content" [class.ant-collapse-content-active]="nzActive" [@collapseState]="nzActive?'active':'inactive'"> <div class="ant-collapse-content-box"> <ng-content></ng-content> </div> </div>`,
                animations: [
                    trigger('collapseState', [
                        state('inactive', style({
                            opacity: '0',
                            height: 0
                        })),
                        state('active', style({
                            opacity: '1',
                            height: '*'
                        })),
                        transition('inactive => active', animate('150ms ease-in')),
                        transition('active => inactive', animate('150ms ease-out'))
                    ])
                ],
                styles: [
                    `
      :host {
        display: block
      }`
                ],
                host: {
                    '[class.ant-collapse-item]': 'true',
                    '[attr.role]': '"tablist"'
                }
            },] },
];
/** @nocollapse */
NzCollapsePanelComponent.ctorParameters = () => [
    { type: NzCollapseComponent, decorators: [{ type: Host }] },
    { type: ElementRef }
];
NzCollapsePanelComponent.propDecorators = {
    nzActiveChange: [{ type: Output }],
    nzShowArrow: [{ type: Input }],
    isNoArrow: [{ type: HostBinding, args: ['class.ant-collapse-no-arrow',] }],
    nzHeader: [{ type: Input }],
    nzDisabled: [{ type: Input }, { type: HostBinding, args: ['class.ant-collapse-item-disabled',] }],
    nzActive: [{ type: Input }, { type: HostBinding, args: ['class.ant-collapse-item-active',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzCollapseModule {
}
NzCollapseModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzCollapsePanelComponent, NzCollapseComponent],
                exports: [NzCollapsePanelComponent, NzCollapseComponent],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTimeValueAccessorDirective {
    /**
     * @param {?} i18n
     * @param {?} elementRef
     */
    constructor(i18n, elementRef) {
        this.i18n = i18n;
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    keyup() {
        this.changed();
    }
    /**
     * @return {?}
     */
    blur() {
        this.touched();
    }
    /**
     * @return {?}
     */
    changed() {
        if (this._onChange) {
            const /** @type {?} */ value = this.i18n.parseTime(this.elementRef.nativeElement.value);
            this._onChange(value);
        }
    }
    /**
     * @return {?}
     */
    touched() {
        if (this._onTouch) {
            this._onTouch();
        }
    }
    /**
     * @return {?}
     */
    setRange() {
        this.elementRef.nativeElement.focus();
        this.elementRef.nativeElement.setSelectionRange(0, this.elementRef.nativeElement.value.length);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.elementRef.nativeElement.value = this.i18n.formatDate(value, this.format);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouch = fn;
    }
}
NzTimeValueAccessorDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[nzTime]',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: NzTimeValueAccessorDirective, multi: true }
                ]
            },] },
];
/** @nocollapse */
NzTimeValueAccessorDirective.ctorParameters = () => [
    { type: NzI18nService },
    { type: ElementRef }
];
NzTimeValueAccessorDirective.propDecorators = {
    format: [{ type: Input, args: ['nzTime',] }],
    keyup: [{ type: HostListener, args: ['keyup',] }],
    blur: [{ type: HostListener, args: ['blur',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TimeHolder {
    constructor() {
        this._seconds = undefined;
        this._hours = undefined;
        this._minutes = undefined;
        this._defaultOpenValue = new Date();
        this._changes = new Subject();
    }
    /**
     * @return {?}
     */
    setDefaultValueIfNil() {
        if (!isNotNil(this._value)) {
            this._value = new Date(this.defaultOpenValue);
        }
    }
    /**
     * @param {?} value
     * @param {?} disabled
     * @return {?}
     */
    setMinutes(value, disabled) {
        if (disabled) {
            return this;
        }
        this.setDefaultValueIfNil();
        this.minutes = value;
        return this;
    }
    /**
     * @param {?} value
     * @param {?} disabled
     * @return {?}
     */
    setHours(value, disabled) {
        if (disabled) {
            return this;
        }
        this.setDefaultValueIfNil();
        this.hours = value;
        return this;
    }
    /**
     * @param {?} value
     * @param {?} disabled
     * @return {?}
     */
    setSeconds(value, disabled) {
        if (disabled) {
            return this;
        }
        this.setDefaultValueIfNil();
        this.seconds = value;
        return this;
    }
    /**
     * @return {?}
     */
    get changes() {
        return this._changes.asObservable();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (value !== this._value) {
            this._value = value;
            if (isNotNil(this._value)) {
                this._hours = this._value.getHours();
                this._minutes = this._value.getMinutes();
                this._seconds = this._value.getSeconds();
            }
            else {
                this._clear();
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setValue(value) {
        this.value = value;
        return this;
    }
    /**
     * @return {?}
     */
    clear() {
        this._clear();
        this.update();
    }
    /**
     * @return {?}
     */
    get isEmpty() {
        return !(isNotNil(this._hours) || isNotNil(this._minutes) || isNotNil(this._seconds));
    }
    /**
     * @return {?}
     */
    _clear() {
        this._hours = undefined;
        this._minutes = undefined;
        this._seconds = undefined;
    }
    /**
     * @return {?}
     */
    update() {
        if (this.isEmpty) {
            this._value = undefined;
        }
        else {
            if (!isNotNil(this._hours)) {
                this._hours = this.defaultHours;
            }
            else {
                this._value.setHours(this.hours);
            }
            if (!isNotNil(this._minutes)) {
                this._minutes = this.defaultMinutes;
            }
            else {
                this._value.setMinutes(this.minutes);
            }
            if (!isNotNil(this._seconds)) {
                this._seconds = this.defaultSeconds;
            }
            else {
                this._value.setSeconds(this.seconds);
            }
            this._value = new Date(this._value);
        }
        this.changed();
    }
    /**
     * @return {?}
     */
    changed() {
        this._changes.next(this._value);
    }
    /**
     * @return {?}
     */
    get hours() {
        return this._hours;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set hours(value) {
        if (value !== this._hours) {
            this._hours = value;
            this.update();
        }
    }
    /**
     * @return {?}
     */
    get minutes() {
        return this._minutes;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set minutes(value) {
        if (value !== this._minutes) {
            this._minutes = value;
            this.update();
        }
    }
    /**
     * @return {?}
     */
    get seconds() {
        return this._seconds;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set seconds(value) {
        if (value !== this._seconds) {
            this._seconds = value;
            this.update();
        }
    }
    /**
     * @return {?}
     */
    get defaultOpenValue() {
        return this._defaultOpenValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultOpenValue(value) {
        if (this._defaultOpenValue !== value) {
            this._defaultOpenValue = value;
            this.update();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setDefaultOpenValue(value) {
        this.defaultOpenValue = value;
        return this;
    }
    /**
     * @return {?}
     */
    get defaultHours() {
        return this._defaultOpenValue.getHours();
    }
    /**
     * @return {?}
     */
    get defaultMinutes() {
        return this._defaultOpenValue.getMinutes();
    }
    /**
     * @return {?}
     */
    get defaultSeconds() {
        return this._defaultOpenValue.getSeconds();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} length
 * @param {?=} step
 * @return {?}
 */
function makeRange(length, step = 1) {
    return new Array(Math.ceil(length / step)).fill(0).map((_, i) => i * step);
}
class NzTimePickerPanelComponent {
    /**
     * @param {?} element
     * @param {?} updateCls
     */
    constructor(element, updateCls) {
        this.element = element;
        this.updateCls = updateCls;
        this._nzHourStep = 1;
        this._nzMinuteStep = 1;
        this._nzSecondStep = 1;
        this.unsubscribe$ = new Subject();
        this._format = 'HH:mm:ss';
        this._defaultOpenValue = new Date();
        this._opened = false;
        this._allowEmpty = true;
        this.prefixCls = 'ant-time-picker-panel';
        this.time = new TimeHolder();
        this.hourEnabled = true;
        this.minuteEnabled = true;
        this.secondEnabled = true;
        this.enabledColumns = 3;
        this.nzInDatePicker = false;
        this.nzHideDisabledOptions = false;
        this.timeClear = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAllowEmpty(value) {
        if (isNotNil(value)) {
            this._allowEmpty = value;
        }
    }
    /**
     * @return {?}
     */
    get nzAllowEmpty() {
        return this._allowEmpty;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set opened(value) {
        this._opened = value;
        if (this.opened) {
            this.initPosition();
            this.selectInputRange();
        }
    }
    /**
     * @return {?}
     */
    get opened() {
        return this._opened;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDefaultOpenValue(value) {
        if (isNotNil(value)) {
            this._defaultOpenValue = value;
            this.time.setDefaultOpenValue(this.nzDefaultOpenValue);
        }
    }
    /**
     * @return {?}
     */
    get nzDefaultOpenValue() {
        return this._defaultOpenValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabledHours(value) {
        this._disabledHours = value;
        if (this._disabledHours) {
            this.buildHours();
        }
    }
    /**
     * @return {?}
     */
    get nzDisabledHours() {
        return this._disabledHours;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabledMinutes(value) {
        if (isNotNil(value)) {
            this._disabledMinutes = value;
            this.buildMinutes();
        }
    }
    /**
     * @return {?}
     */
    get nzDisabledMinutes() {
        return this._disabledMinutes;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabledSeconds(value) {
        if (isNotNil(value)) {
            this._disabledSeconds = value;
            this.buildSeconds();
        }
    }
    /**
     * @return {?}
     */
    get nzDisabledSeconds() {
        return this._disabledSeconds;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set format(value) {
        if (isNotNil(value)) {
            this._format = value;
            this.enabledColumns = 0;
            const /** @type {?} */ charSet = new Set(value);
            this.hourEnabled = charSet.has('H') || charSet.has('h');
            this.minuteEnabled = charSet.has('m');
            this.secondEnabled = charSet.has('s');
            if (this.hourEnabled) {
                this.enabledColumns++;
            }
            if (this.minuteEnabled) {
                this.enabledColumns++;
            }
            if (this.secondEnabled) {
                this.enabledColumns++;
            }
        }
    }
    /**
     * @return {?}
     */
    get format() {
        return this._format;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzHourStep(value) {
        if (isNotNil(value)) {
            this._nzHourStep = value;
            this.buildHours();
        }
    }
    /**
     * @return {?}
     */
    get nzHourStep() {
        return this._nzHourStep;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzMinuteStep(value) {
        if (isNotNil(value)) {
            this._nzMinuteStep = value;
            this.buildMinutes();
        }
    }
    /**
     * @return {?}
     */
    get nzMinuteStep() {
        return this._nzMinuteStep;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSecondStep(value) {
        if (isNotNil(value)) {
            this._nzSecondStep = value;
            this.buildSeconds();
        }
    }
    /**
     * @return {?}
     */
    get nzSecondStep() {
        return this._nzSecondStep;
    }
    /**
     * @return {?}
     */
    selectInputRange() {
        setTimeout(() => {
            if (this.nzTimeValueAccessorDirective) {
                this.nzTimeValueAccessorDirective.setRange();
            }
        });
    }
    /**
     * @return {?}
     */
    buildHours() {
        this.hourRange = makeRange(24, this.nzHourStep).map(r => {
            return {
                index: r,
                disabled: this.nzDisabledHours && (this.nzDisabledHours().indexOf(r) !== -1)
            };
        });
    }
    /**
     * @return {?}
     */
    buildMinutes() {
        this.minuteRange = makeRange(60, this.nzMinuteStep).map(r => {
            return {
                index: r,
                disabled: this.nzDisabledMinutes && (this.nzDisabledMinutes(this.time.hours).indexOf(r) !== -1)
            };
        });
    }
    /**
     * @return {?}
     */
    buildSeconds() {
        this.secondRange = makeRange(60, this.nzSecondStep).map(r => {
            return {
                index: r,
                disabled: this.nzDisabledSeconds && (this.nzDisabledSeconds(this.time.hours, this.time.minutes).indexOf(r) !== -1)
            };
        });
    }
    /**
     * @return {?}
     */
    buildTimes() {
        this.buildHours();
        this.buildMinutes();
        this.buildSeconds();
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    selectHour(hour) {
        this.time.setHours(hour.index, hour.disabled);
        this.scrollToSelected(this.hourListElement.nativeElement, hour.index, 120, 'hour');
        if (this._disabledMinutes) {
            this.buildMinutes();
        }
        if (this._disabledSeconds || this._disabledMinutes) {
            this.buildSeconds();
        }
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    selectMinute(minute) {
        this.time.setMinutes(minute.index, minute.disabled);
        this.scrollToSelected(this.minuteListElement.nativeElement, minute.index, 120, 'minute');
        if (this._disabledSeconds) {
            this.buildSeconds();
        }
    }
    /**
     * @param {?} second
     * @return {?}
     */
    selectSecond(second) {
        this.time.setSeconds(second.index, second.disabled);
        this.scrollToSelected(this.secondListElement.nativeElement, second.index, 120, 'second');
    }
    /**
     * @param {?} instance
     * @param {?} index
     * @param {?=} duration
     * @param {?=} unit
     * @return {?}
     */
    scrollToSelected(instance, index, duration = 0, unit) {
        const /** @type {?} */ transIndex = this.translateIndex(index, unit);
        const /** @type {?} */ currentOption = /** @type {?} */ ((instance.children[0].children[transIndex] || instance.children[0].children[0]));
        this.scrollTo(instance, currentOption.offsetTop, duration);
    }
    /**
     * @param {?} index
     * @param {?} unit
     * @return {?}
     */
    translateIndex(index, unit) {
        if (unit === 'hour') {
            const /** @type {?} */ disabledHours = this.nzDisabledHours && this.nzDisabledHours();
            return this.calcIndex(disabledHours, this.hourRange.map(item => item.index).indexOf(index));
        }
        else if (unit === 'minute') {
            const /** @type {?} */ disabledMinutes = this.nzDisabledMinutes && this.nzDisabledMinutes(this.time.hours);
            return this.calcIndex(disabledMinutes, this.minuteRange.map(item => item.index).indexOf(index));
        }
        else if (unit === 'second') {
            const /** @type {?} */ disabledSeconds = this.nzDisabledSeconds && this.nzDisabledSeconds(this.time.hours, this.time.minutes);
            return this.calcIndex(disabledSeconds, this.secondRange.map(item => item.index).indexOf(index));
        }
    }
    /**
     * @param {?} element
     * @param {?} to
     * @param {?} duration
     * @return {?}
     */
    scrollTo(element, to, duration) {
        if (duration <= 0) {
            element.scrollTop = to;
            return;
        }
        const /** @type {?} */ difference = to - element.scrollTop;
        const /** @type {?} */ perTick = difference / duration * 10;
        reqAnimFrame(() => {
            element.scrollTop = element.scrollTop + perTick;
            if (element.scrollTop === to) {
                return;
            }
            this.scrollTo(element, to, duration - 10);
        });
    }
    /**
     * @param {?} array
     * @param {?} index
     * @return {?}
     */
    calcIndex(array, index) {
        if (array && array.length && this.nzHideDisabledOptions) {
            return index - array.reduce((pre, value) => {
                return pre + (value < index ? 1 : 0);
            }, 0);
        }
        else {
            return index;
        }
    }
    /**
     * @return {?}
     */
    clear() {
        this.time.clear();
        this.timeClear.emit();
    }
    /**
     * @return {?}
     */
    changed() {
        if (this.onChange) {
            this.onChange(this.time.value);
        }
    }
    /**
     * @return {?}
     */
    touched() {
        if (this.onTouch) {
            this.onTouch();
        }
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.updateCls.updateHostClass(this.element.nativeElement, {
            [`${this.prefixCls}`]: true,
            [`${this.prefixCls}-column-${this.enabledColumns}`]: this.nzInDatePicker ? false : true,
            [`${this.prefixCls}-narrow`]: this.enabledColumns < 3,
            [`${this.prefixCls}-placement-bottomLeft`]: this.nzInDatePicker ? false : true
        });
    }
    /**
     * @param {?} hour
     * @return {?}
     */
    isSelectedHour(hour) {
        return (hour.index === this.time.hours) || (!isNotNil(this.time.hours) && (hour.index === this.time.defaultHours));
    }
    /**
     * @param {?} minute
     * @return {?}
     */
    isSelectedMinute(minute) {
        return (minute.index === this.time.minutes) || (!isNotNil(this.time.minutes) && (minute.index === this.time.defaultMinutes));
    }
    /**
     * @param {?} second
     * @return {?}
     */
    isSelectedSecond(second) {
        return (second.index === this.time.seconds) || (!isNotNil(this.time.seconds) && (second.index === this.time.defaultSeconds));
    }
    /**
     * @return {?}
     */
    initPosition() {
        setTimeout(() => {
            if (this.hourEnabled && this.hourListElement) {
                if (isNotNil(this.time.hours)) {
                    this.scrollToSelected(this.hourListElement.nativeElement, this.time.hours, 0, 'hour');
                }
                else {
                    this.scrollToSelected(this.hourListElement.nativeElement, this.time.defaultHours, 0, 'hour');
                }
            }
            if (this.minuteEnabled && this.minuteListElement) {
                if (isNotNil(this.time.minutes)) {
                    this.scrollToSelected(this.minuteListElement.nativeElement, this.time.minutes, 0, 'minute');
                }
                else {
                    this.scrollToSelected(this.minuteListElement.nativeElement, this.time.defaultMinutes, 0, 'minute');
                }
            }
            if (this.secondEnabled && this.secondListElement) {
                if (isNotNil(this.time.seconds)) {
                    this.scrollToSelected(this.secondListElement.nativeElement, this.time.seconds, 0, 'second');
                }
                else {
                    this.scrollToSelected(this.secondListElement.nativeElement, this.time.defaultSeconds, 0, 'second');
                }
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.nzInDatePicker) {
            this.prefixCls = 'ant-calendar-time-picker';
        }
        this.time.changes.pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
            this.changed();
            this.touched();
        });
        this.buildTimes();
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.time.value = value;
        this.buildTimes();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouch = fn;
    }
}
NzTimePickerPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-time-picker-panel',
                template: `<div class="{{ nzInDatePicker ? prefixCls + '-panel' : '' }}"> <div class="{{ prefixCls }}-inner {{ nzInDatePicker ? prefixCls + '-column-' + enabledColumns : '' }}" [style.width.px]="nzInDatePicker ? null : enabledColumns * 56"> <div class="{{ prefixCls }}-input-wrap"> <input type="text" class="{{ prefixCls }}-input" [placeholder]="nzPlaceHolder" [nzTime]="format" [(ngModel)]="time.value" (blur)="time.changed()"> <a *ngIf="nzAllowEmpty" class="{{ prefixCls }}-clear-btn" [attr.title]="nzClearText" (click)="clear()"> </a> </div> <div class="{{ prefixCls }}-combobox"> <div *ngIf="hourEnabled" #hourListElement class="{{ prefixCls }}-select"> <ul> <ng-container *ngFor="let hour of hourRange"> <li *ngIf="!(nzHideDisabledOptions && hour.disabled)" (click)="selectHour(hour)" class=" {{ isSelectedHour(hour) ? prefixCls + '-select-option-selected' : '' }} {{ hour.disabled ? prefixCls + '-select-option-disabled' : '' }} " > {{ hour.index | number:'2.0-0' }} </li> </ng-container> </ul> </div> <div *ngIf="minuteEnabled" #minuteListElement class="{{ prefixCls }}-select"> <ul> <ng-container *ngFor="let minute of minuteRange"> <li *ngIf="!(nzHideDisabledOptions && minute.disabled)" (click)="selectMinute(minute)" class=" {{ isSelectedMinute(minute) ? prefixCls + '-select-option-selected' : '' }} {{ minute.disabled ? prefixCls + '-select-option-disabled' : '' }} " > {{ minute.index | number:'2.0-0' }} </li> </ng-container> </ul> </div> <div *ngIf="secondEnabled" #secondListElement class="{{ prefixCls }}-select"> <ul> <ng-container *ngFor="let second of secondRange"> <li *ngIf="!(nzHideDisabledOptions && second.disabled)" (click)="selectSecond(second)" class=" {{ isSelectedSecond(second) ? prefixCls + '-select-option-selected' : '' }} {{ second.disabled ? prefixCls + '-select-option-disabled' : '' }} " > {{ second.index | number:'2.0-0' }} </li> </ng-container> </ul> </div> </div> <div class="{{ prefixCls }}-addon" *ngIf="nzAddOn"> <ng-template [ngTemplateOutlet]="nzAddOn"></ng-template> </div> </div> </div>`,
                providers: [
                    NzUpdateHostClassService,
                    { provide: NG_VALUE_ACCESSOR, useExisting: NzTimePickerPanelComponent, multi: true }
                ]
            },] },
];
/** @nocollapse */
NzTimePickerPanelComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NzUpdateHostClassService }
];
NzTimePickerPanelComponent.propDecorators = {
    nzTimeValueAccessorDirective: [{ type: ViewChild, args: [NzTimeValueAccessorDirective,] }],
    hourListElement: [{ type: ViewChild, args: ['hourListElement',] }],
    minuteListElement: [{ type: ViewChild, args: ['minuteListElement',] }],
    secondListElement: [{ type: ViewChild, args: ['secondListElement',] }],
    nzInDatePicker: [{ type: Input }],
    nzAddOn: [{ type: Input }],
    nzHideDisabledOptions: [{ type: Input }],
    nzClearText: [{ type: Input }],
    nzPlaceHolder: [{ type: Input }],
    timeClear: [{ type: Output }],
    nzAllowEmpty: [{ type: Input }],
    opened: [{ type: Input }],
    nzDefaultOpenValue: [{ type: Input }],
    nzDisabledHours: [{ type: Input }],
    nzDisabledMinutes: [{ type: Input }],
    nzDisabledSeconds: [{ type: Input }],
    format: [{ type: Input }],
    nzHourStep: [{ type: Input }],
    nzMinuteStep: [{ type: Input }],
    nzSecondStep: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTimePickerComponent {
    /**
     * @param {?} element
     * @param {?} renderer
     * @param {?} overlay
     * @param {?} positionBuilder
     * @param {?} i18n
     * @param {?} updateCls
     */
    constructor(element, renderer, overlay, positionBuilder, i18n, updateCls) {
        this.element = element;
        this.renderer = renderer;
        this.overlay = overlay;
        this.positionBuilder = positionBuilder;
        this.i18n = i18n;
        this.updateCls = updateCls;
        this._disabled = false;
        this._value = null;
        this._allowEmpty = true;
        this._autoFocus = false;
        this._hideDisabledOptions = false;
        this.isInit = false;
        this.overlayPositions = [{
                originX: 'start',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'top',
                offsetX: 0,
                offsetY: 0
            }];
        this.nzSize = null;
        this.nzHourStep = 1;
        this.nzMinuteStep = 1;
        this.nzSecondStep = 1;
        this.nzClearText = 'clear';
        this.nzPopupClassName = '';
        this.nzPlaceHolder = '';
        this.nzDefaultOpenValue = new Date();
        this.nzFormat = 'HH:mm:ss';
        this.nzOpen = false;
        this.nzOpenChange = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzHideDisabledOptions(value) {
        this._hideDisabledOptions = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzHideDisabledOptions() {
        return this._hideDisabledOptions;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAllowEmpty(value) {
        this._allowEmpty = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzAllowEmpty() {
        return this._allowEmpty;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAutoFocus(value) {
        this._autoFocus = toBoolean(value);
        this.updateAutoFocus();
    }
    /**
     * @return {?}
     */
    get nzAutoFocus() {
        return this._autoFocus;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
        const /** @type {?} */ input = /** @type {?} */ (this.inputRef.nativeElement);
        if (this._disabled) {
            this.renderer.setAttribute(input, 'disabled', '');
        }
        else {
            this.renderer.removeAttribute(input, 'disabled');
        }
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value;
        if (this._onChange) {
            this._onChange(this.value);
        }
        if (this._onTouched) {
            this._onTouched();
        }
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @return {?}
     */
    open() {
        if (this.nzDisabled) {
            return;
        }
        this.nzOpen = true;
        this.nzOpenChange.emit(this.nzOpen);
    }
    /**
     * @return {?}
     */
    close() {
        this.nzOpen = false;
        this.nzOpenChange.emit(this.nzOpen);
    }
    /**
     * @return {?}
     */
    updateAutoFocus() {
        if (this.isInit && !this.nzDisabled) {
            if (this.nzAutoFocus) {
                this.renderer.setAttribute(this.inputRef.nativeElement, 'autofocus', 'autofocus');
            }
            else {
                this.renderer.removeAttribute(this.inputRef.nativeElement, 'autofocus');
            }
        }
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.updateCls.updateHostClass(this.element.nativeElement, {
            [`ant-time-picker`]: true,
            [`ant-time-picker-${this.nzSize}`]: isNotNil(this.nzSize)
        });
    }
    /**
     * @return {?}
     */
    focus() {
        if (this.inputRef.nativeElement) {
            this.inputRef.nativeElement.focus();
        }
    }
    /**
     * @return {?}
     */
    blur() {
        if (this.inputRef.nativeElement) {
            this.inputRef.nativeElement.blur();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
        this.origin = new CdkOverlayOrigin(this.element);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.isInit = true;
        this.updateAutoFocus();
    }
    /**
     * @param {?} time
     * @return {?}
     */
    writeValue(time) {
        this._value = time;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
    }
}
NzTimePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-time-picker',
                template: `<input type="text" [nzTime]="nzFormat" class="ant-time-picker-input" [placeholder]="nzPlaceHolder || ('TimePicker.placeholder' | nzI18n)" [(ngModel)]="value" readonly="readonly" (click)="open()" #inputElement> <span class="ant-time-picker-icon"></span> <ng-template cdkConnectedOverlay cdkConnectedOverlayHasBackdrop [cdkConnectedOverlayPositions]="overlayPositions" [cdkConnectedOverlayOrigin]="origin" [cdkConnectedOverlayOpen]="nzOpen" [cdkConnectedOverlayOffsetY]="-2" (detach)="close()" (backdropClick)="close()"> <nz-time-picker-panel [ngClass]="nzPopupClassName" [@dropDownAnimation]="'bottom'" [format]="nzFormat" [nzHourStep]="nzHourStep" [nzMinuteStep]="nzMinuteStep" [nzSecondStep]="nzSecondStep" [nzDisabledHours]="nzDisabledHours" [nzDisabledMinutes]="nzDisabledMinutes" [nzDisabledSeconds]="nzDisabledSeconds" [nzPlaceHolder]="nzPlaceHolder || ('TimePicker.placeholder' | nzI18n)" [nzHideDisabledOptions]="nzHideDisabledOptions" [nzDefaultOpenValue]="nzDefaultOpenValue" [nzAddOn]="nzAddOn" [opened]="nzOpen" [nzClearText]="nzClearText" [nzAllowEmpty]="nzAllowEmpty" (timeClear)="close()" [(ngModel)]="value"> </nz-time-picker-panel> </ng-template> `,
                animations: [
                    trigger('dropDownAnimation', [
                        state('void', style({
                            opacity: 0,
                            display: 'none'
                        })),
                        state('*', style({
                            opacity: 1,
                            transform: 'scaleY(1)',
                            transformOrigin: '0% 0%'
                        })),
                        transition('void => *', [
                            style({
                                opacity: 0,
                                transform: 'scaleY(0.8)',
                                transformOrigin: '0% 0%'
                            }),
                            animate('100ms cubic-bezier(0.755, 0.05, 0.855, 0.06)')
                        ]),
                        transition('* => void', [
                            animate('100ms cubic-bezier(0.755, 0.05, 0.855, 0.06)', style({
                                opacity: 0,
                                transform: 'scaleY(0.8)',
                                transformOrigin: '0% 0%'
                            }))
                        ])
                    ])
                ],
                providers: [
                    NzUpdateHostClassService,
                    { provide: NG_VALUE_ACCESSOR, useExisting: NzTimePickerComponent, multi: true }
                ]
            },] },
];
/** @nocollapse */
NzTimePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Overlay },
    { type: OverlayPositionBuilder },
    { type: NzI18nService },
    { type: NzUpdateHostClassService }
];
NzTimePickerComponent.propDecorators = {
    inputRef: [{ type: ViewChild, args: ['inputElement',] }],
    nzSize: [{ type: Input }],
    nzHourStep: [{ type: Input }],
    nzMinuteStep: [{ type: Input }],
    nzSecondStep: [{ type: Input }],
    nzClearText: [{ type: Input }],
    nzPopupClassName: [{ type: Input }],
    nzPlaceHolder: [{ type: Input }],
    nzAddOn: [{ type: Input }],
    nzDefaultOpenValue: [{ type: Input }],
    nzDisabledHours: [{ type: Input }],
    nzDisabledMinutes: [{ type: Input }],
    nzDisabledSeconds: [{ type: Input }],
    nzFormat: [{ type: Input }],
    nzOpen: [{ type: Input }],
    nzOpenChange: [{ type: Output }],
    nzHideDisabledOptions: [{ type: Input }],
    nzAllowEmpty: [{ type: Input }],
    nzAutoFocus: [{ type: Input }],
    nzDisabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTimePickerModule {
}
NzTimePickerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NzTimePickerComponent,
                    NzTimePickerPanelComponent,
                    NzTimeValueAccessorDirective
                ],
                exports: [
                    NzTimePickerPanelComponent,
                    NzTimePickerComponent
                ],
                imports: [CommonModule, FormsModule, NzI18nModule, OverlayModule],
                entryComponents: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CalendarFooterComponent {
    constructor() {
        this.showToday = false;
        this.hasTimePicker = false;
        this.isRange = false;
        this.showTimePicker = false;
        this.showTimePickerChange = new EventEmitter();
        // @Input() disabled: boolean = false;
        this.timePickerDisabled = false;
        this.okDisabled = false;
        this.clickOk = new EventEmitter();
        this.clickToday = new EventEmitter();
        this.prefixCls = 'ant-calendar';
        this.isTemplateRef = isTemplateRef;
        this.isNonEmptyString = isNonEmptyString;
    }
}
CalendarFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'calendar-footer',
                template: `<div class="{{ prefixCls }}-footer {{ isRange ? prefixCls + '-range-bottom' : '' }} {{ hasTimePicker ? prefixCls + '-footer-show-ok' : '' }}"> <div *ngIf="rangeQuickSelector" class="{{ prefixCls }}-footer-extra {{ prefixCls }}-range-quick-selector"> <ng-container *ngTemplateOutlet="rangeQuickSelector"></ng-container> </div> <div *ngIf="extraFooter" class="{{ prefixCls }}-footer-extra {{ isRange ? prefixCls + '-range-quick-selector' : '' }}"> <ng-container [ngSwitch]="true"> <ng-container *ngSwitchCase="isTemplateRef(extraFooter)"> <ng-container *ngTemplateOutlet="extraFooter"></ng-container> </ng-container> <ng-container *ngSwitchCase="isNonEmptyString(extraFooter)"> <span [innerHTML]="extraFooter"></span> </ng-container> </ng-container> </div> <span *ngIf="showToday || hasTimePicker" class="{{ prefixCls }}-footer-btn"> <today-button *ngIf="showToday" [locale]="locale" [disabledDate]="disabledDate" [hasTimePicker]="hasTimePicker" (clickToday)="clickToday.emit($event)" ></today-button> <time-picker-button *ngIf="hasTimePicker" [locale]="locale" [timePickerDisabled]="timePickerDisabled" [showTimePicker]="showTimePicker" (showTimePickerChange)="showTimePickerChange.emit($event)" ></time-picker-button> <ok-button *ngIf="hasTimePicker" [okDisabled]="okDisabled" [locale]="locale" (clickOk)="clickOk.emit()" ></ok-button> </span> </div>`
            },] },
];
CalendarFooterComponent.propDecorators = {
    locale: [{ type: Input }],
    showToday: [{ type: Input }],
    hasTimePicker: [{ type: Input }],
    isRange: [{ type: Input }],
    showTimePicker: [{ type: Input }],
    showTimePickerChange: [{ type: Output }],
    timePickerDisabled: [{ type: Input }],
    okDisabled: [{ type: Input }],
    disabledDate: [{ type: Input }],
    extraFooter: [{ type: Input }],
    rangeQuickSelector: [{ type: Input }],
    clickOk: [{ type: Output }],
    clickToday: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * [Temporary] Get the first day of week depend on locale (0-6 represent as Sunday-Saturday)
 * @param {?=} locale Locale code
 * @return {?}
 */
function firstDayOfWeek(locale) {
    return locale && ['zh-cn', 'zh-tw'].indexOf(locale.toLowerCase()) > -1 ? 1 : 0;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Wrapping kind APIs for date operating and unify
 * NOTE: every new API return new CandyDate object without side effects to the former Date object
 * NOTE: most APIs are based on local time other than customized locale id (this needs tobe support in future)
 * TODO: support format() against to angular's core API
 */
class CandyDate {
    /**
     * @param {?=} date
     */
    constructor(date) {
        // if (!(this instanceof CandyDate)) {
        //   return new CandyDate(date);
        // }
        if (date) {
            if (date instanceof Date) {
                this.nativeDate = date;
            }
            else if (typeof date === 'string') {
                this.nativeDate = new Date(date);
            }
            else {
                throw new Error('The input date type is not supported ("Date" and "string" is now recommended)');
            }
        }
        else {
            this.nativeDate = new Date();
        }
    }
    /**
     * @return {?}
     */
    getYear() {
        return this.nativeDate.getFullYear();
    }
    /**
     * @return {?}
     */
    getMonth() {
        return this.nativeDate.getMonth();
    }
    /**
     * @return {?}
     */
    getDay() {
        return this.nativeDate.getDay();
    }
    /**
     * @return {?}
     */
    getTime() {
        return this.nativeDate.getTime();
    }
    /**
     * @return {?}
     */
    getDate() {
        return this.nativeDate.getDate();
    }
    /**
     * @return {?}
     */
    getHours() {
        return this.nativeDate.getHours();
    }
    /**
     * @return {?}
     */
    getMinutes() {
        return this.nativeDate.getMinutes();
    }
    /**
     * @return {?}
     */
    getSeconds() {
        return this.nativeDate.getSeconds();
    }
    /**
     * @return {?}
     */
    getMilliseconds() {
        return this.nativeDate.getMilliseconds();
    }
    /**
     * @return {?}
     */
    clone() {
        return new CandyDate(new Date(this.nativeDate));
    }
    /**
     * @param {?} hour
     * @param {?} minute
     * @param {?} second
     * @return {?}
     */
    setHms(hour, minute, second) {
        const /** @type {?} */ date = new Date(this.nativeDate);
        date.setHours(hour, minute, second);
        return new CandyDate(date);
    }
    /**
     * @param {?} year
     * @return {?}
     */
    setYear(year) {
        // return new CandyDate(setYear(this.date, year));
        const /** @type {?} */ date = new Date(this.nativeDate);
        date.setFullYear(year);
        return new CandyDate(date);
    }
    /**
     * @param {?} amount
     * @return {?}
     */
    addYears(amount) {
        return new CandyDate(addYears(this.nativeDate, amount));
    }
    /**
     * @param {?} month
     * @return {?}
     */
    setMonth(month) {
        const /** @type {?} */ date = new Date(this.nativeDate);
        date.setMonth(month);
        return new CandyDate(date);
    }
    /**
     * @param {?} amount
     * @return {?}
     */
    addMonths(amount) {
        return new CandyDate(addMonths(this.nativeDate, amount));
    }
    /**
     * @param {?} day
     * @param {?=} options
     * @return {?}
     */
    setDay(day, options) {
        return new CandyDate(setDay(this.nativeDate, day, options));
    }
    /**
     * @param {?} amount
     * @return {?}
     */
    setDate(amount) {
        const /** @type {?} */ date = new Date(this.nativeDate);
        date.setDate(amount);
        return new CandyDate(date);
    }
    /**
     * @param {?} amount
     * @return {?}
     */
    addDays(amount) {
        return this.setDate(this.getDate() + amount);
    }
    /**
     * @param {?} grain
     * @return {?}
     */
    endOf(grain) {
        switch (grain) {
            case 'month': return new CandyDate(endOfMonth(this.nativeDate));
        }
        return null;
    }
    /**
     * @param {?} date
     * @param {?} grain
     * @return {?}
     */
    isSame(date, grain) {
        // TODO: Precipitate into a function "compare()"
        if (date) {
            const /** @type {?} */ left = this.toNativeDate();
            const /** @type {?} */ right = this.toNativeDate(date);
            switch (grain) {
                case 'year':
                    return left.getFullYear() === right.getFullYear();
                case 'month':
                    return left.getFullYear() === right.getFullYear()
                        && left.getMonth() === right.getMonth();
                case 'day':
                    return left.getFullYear() === right.getFullYear()
                        && left.getMonth() === right.getMonth()
                        && left.getDate() === right.getDate();
                case 'hour':
                    return left.getFullYear() === right.getFullYear()
                        && left.getMonth() === right.getMonth()
                        && left.getDate() === right.getDate()
                        && left.getHours() === right.getHours();
                case 'minute':
                    return left.getFullYear() === right.getFullYear()
                        && left.getMonth() === right.getMonth()
                        && left.getDate() === right.getDate()
                        && left.getHours() === right.getHours()
                        && left.getMinutes() === right.getMinutes();
                case 'second':
                    return left.getFullYear() === right.getFullYear()
                        && left.getMonth() === right.getMonth()
                        && left.getDate() === right.getDate()
                        && left.getHours() === right.getHours()
                        && left.getMinutes() === right.getMinutes()
                        && left.getSeconds() === right.getSeconds();
            }
        }
        return false;
    }
    /**
     * @param {?} date
     * @param {?} grain
     * @return {?}
     */
    isAfter(date, grain) {
        // TODO: Precipitate into a function "compare()"
        if (date) {
            const /** @type {?} */ left = this.toNativeDate();
            const /** @type {?} */ right = this.toNativeDate(date);
            switch (grain) {
                case 'year':
                    return left.getFullYear() > right.getFullYear();
                case 'month':
                    return (left.getFullYear() > right.getFullYear())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() > right.getMonth());
                case 'day':
                    return (left.getFullYear() > right.getFullYear())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() > right.getMonth())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() > right.getDate());
                case 'hour':
                    return (left.getFullYear() > right.getFullYear())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() > right.getMonth())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() > right.getDate())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() > right.getHours());
                case 'minute':
                    return (left.getFullYear() > right.getFullYear())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() > right.getMonth())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() > right.getDate())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() > right.getHours())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() === right.getHours() && left.getMinutes() > right.getMinutes());
                case 'second':
                    return (left.getFullYear() > right.getFullYear())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() > right.getMonth())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() > right.getDate())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() > right.getHours())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() === right.getHours() && left.getMinutes() > right.getMinutes())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() === right.getHours() && left.getMinutes() === right.getMinutes() && left.getSeconds() > right.getSeconds());
            }
        }
        return false;
    }
    /**
     * @param {?} date
     * @param {?} grain
     * @return {?}
     */
    isBefore(date, grain) {
        // TODO: Precipitate into a function "compare()"
        if (date) {
            const /** @type {?} */ left = this.toNativeDate();
            const /** @type {?} */ right = this.toNativeDate(date);
            switch (grain) {
                case 'year':
                    return left.getFullYear() < right.getFullYear();
                case 'month':
                    return (left.getFullYear() < right.getFullYear())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() < right.getMonth());
                case 'day':
                    return (left.getFullYear() < right.getFullYear())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() < right.getMonth())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() < right.getDate());
                case 'hour':
                    return (left.getFullYear() < right.getFullYear())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() < right.getMonth())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() < right.getDate())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() < right.getHours());
                case 'minute':
                    return (left.getFullYear() < right.getFullYear())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() < right.getMonth())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() < right.getDate())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() < right.getHours())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() === right.getHours() && left.getMinutes() < right.getMinutes());
                case 'second':
                    return (left.getFullYear() < right.getFullYear())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() < right.getMonth())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() < right.getDate())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() < right.getHours())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() === right.getHours() && left.getMinutes() < right.getMinutes())
                        || (left.getFullYear() === right.getFullYear() && left.getMonth() === right.getMonth() && left.getDate() === right.getDate() && left.getHours() === right.getHours() && left.getMinutes() === right.getMinutes() && left.getSeconds() < right.getSeconds());
            }
        }
        return false;
    }
    /**
     * @return {?}
     */
    isToday() {
        return this.isSame(new Date(), 'day');
    }
    /**
     * @return {?}
     */
    isInvalid() {
        return isNaN(this.nativeDate.valueOf());
    }
    /**
     * 0-6 (Sunday to Saturday)
     * @param {?=} locale
     * @return {?}
     */
    firstDayOfWeek(locale) {
        return firstDayOfWeek(locale);
    }
    /**
     * @param {?=} date
     * @return {?}
     */
    toNativeDate(date = this) {
        return date instanceof CandyDate ? date.nativeDate : date;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CalendarHeaderComponent {
    /**
     * @param {?} i18n
     */
    constructor(i18n) {
        this.i18n = i18n;
        this.enablePrev = true;
        this.enableNext = true;
        this.showTimePicker = false;
        this.forceToMonth = false;
        this.valueChange = new EventEmitter();
        this.panelModeChange = new EventEmitter();
        this.prefixCls = 'ant-calendar';
        this.yearToMonth = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.value) {
            this.value = new CandyDate(); // Show today by default
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["value"] || changes["showTimePicker"] || changes["panelMode"]) {
            this.render();
        }
    }
    /**
     * @return {?}
     */
    previousYear() {
        this.gotoYear(-1);
    }
    /**
     * @return {?}
     */
    nextYear() {
        this.gotoYear(1);
    }
    /**
     * @return {?}
     */
    previousMonth() {
        this.gotoMonth(-1);
    }
    /**
     * @return {?}
     */
    nextMonth() {
        this.gotoMonth(1);
    }
    /**
     * @param {?} mode
     * @param {?=} value
     * @return {?}
     */
    changePanel(mode, value) {
        // this.panelMode = mode;
        // this.panelModeChange.emit(this.panelMode);
        this.panelModeChange.emit(mode);
        if (value) {
            this.changeValueFromInside(value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onChooseDecade(value) {
        if (this.forceToMonth) {
            this.value = value; // Change internal value only
            this.changePanel('year');
        }
        else {
            this.changePanel('year', value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onChooseYear(value) {
        if (this.forceToMonth) {
            this.value = value; // Change internal value only
            this.changePanel('month');
        }
        else {
            this.changePanel(this.yearToMonth ? 'month' : 'date', value);
            this.yearToMonth = false; // Clear
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onChooseMonth(value) {
        this.changePanel('date', value);
        this.yearToMonth = false; // Clear
    }
    /**
     * @return {?}
     */
    changeToMonthPanel() {
        this.changePanel('month');
        this.yearToMonth = true;
    }
    /**
     * @return {?}
     */
    render() {
        if (this.value) {
            this.yearMonthDaySelectors = this.createYearMonthDaySelectors();
        }
    }
    /**
     * @param {?} amount
     * @return {?}
     */
    gotoMonth(amount) {
        this.changeValueFromInside(this.value.addMonths(amount));
    }
    /**
     * @param {?} amount
     * @return {?}
     */
    gotoYear(amount) {
        this.changeValueFromInside(this.value.addYears(amount));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    changeValueFromInside(value) {
        if (this.value !== value) {
            this.value = value;
            this.valueChange.emit(this.value);
            this.render();
        }
    }
    /**
     * @param {?} localeFormat
     * @return {?}
     */
    formatDateTime(localeFormat) {
        return this.i18n.formatDateCompatible(this.value.nativeDate, localeFormat);
    }
    /**
     * @return {?}
     */
    createYearMonthDaySelectors() {
        let /** @type {?} */ year;
        let /** @type {?} */ month;
        let /** @type {?} */ day;
        year = {
            className: `${this.prefixCls}-year-select`,
            title: this.locale.yearSelect,
            onClick: () => this.showTimePicker ? null : this.changePanel('year'),
            label: this.formatDateTime(this.locale.yearFormat)
        };
        month = {
            className: `${this.prefixCls}-month-select`,
            title: this.locale.monthSelect,
            onClick: () => this.showTimePicker ? null : this.changeToMonthPanel(),
            label: this.locale.monthFormat ? this.formatDateTime(this.locale.monthFormat) : this.i18n.formatDate(this.value.nativeDate, 'MMM')
        };
        if (this.showTimePicker) {
            day = {
                className: `${this.prefixCls}-day-select`,
                label: this.formatDateTime(this.locale.dayFormat)
            };
        }
        let /** @type {?} */ result;
        if (this.locale.monthBeforeYear) {
            result = [month, day, year];
        }
        else {
            result = [year, month, day];
        }
        return result.filter(selector => !!selector);
    }
}
CalendarHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'calendar-header',
                template: `<div class="{{ prefixCls }}-header"> <div style="position: relative;"> <a *ngIf="enablePrev && !showTimePicker" class="{{ prefixCls }}-prev-year-btn" role="button" (click)="previousYear()" title="{{ locale.previousYear }}" ></a> <a *ngIf="enablePrev && !showTimePicker" class="{{ prefixCls }}-prev-month-btn" role="button" (click)="previousMonth()" title="{{ locale.previousMonth }}" ></a> <span class="{{ prefixCls }}-{{ locale.monthBeforeYear ? 'my-select' : 'ym-select' }}"> <ng-container *ngFor="let selector of yearMonthDaySelectors"> <a class="{{ selector.className }}" role="button" (click)="selector.onClick ? selector.onClick() : null" title="{{ selector.title || null }}" > {{ selector.label }} </a> </ng-container> </span> <a *ngIf="enableNext && !showTimePicker" class="{{ prefixCls }}-next-month-btn" role="button" (click)="nextMonth()" title="{{ locale.nextMonth }}" ></a> <a *ngIf="enableNext && !showTimePicker" class="{{ prefixCls }}-next-year-btn" role="button" (click)="nextYear()" title="{{ locale.nextYear }}" ></a> </div> <ng-container [ngSwitch]="panelMode"> <ng-container *ngSwitchCase="'decade'"> <decade-panel [locale]="locale" [value]="value" (valueChange)="onChooseDecade($event)" ></decade-panel> </ng-container> <ng-container *ngSwitchCase="'year'"> <year-panel [locale]="locale" [value]="value" (valueChange)="onChooseYear($event)" (decadePanelShow)="changePanel('decade')" ></year-panel> </ng-container> <ng-container *ngSwitchCase="'month'"> <month-panel [locale]="locale" [value]="value" [disabledDate]="disabledMonth" (valueChange)="onChooseMonth($event)" (yearPanelShow)="changePanel('year')" ></month-panel> </ng-container> </ng-container> </div>`
            },] },
];
/** @nocollapse */
CalendarHeaderComponent.ctorParameters = () => [
    { type: NzI18nService }
];
CalendarHeaderComponent.propDecorators = {
    locale: [{ type: Input }],
    enablePrev: [{ type: Input }],
    enableNext: [{ type: Input }],
    disabledMonth: [{ type: Input }],
    showTimePicker: [{ type: Input }],
    forceToMonth: [{ type: Input }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    panelMode: [{ type: Input }],
    panelModeChange: [{ type: Output }]
};
/**
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CalendarInputComponent {
    /**
     * @param {?} i18n
     */
    constructor(i18n) {
        this.i18n = i18n;
        this.valueChange = new EventEmitter();
        this.prefixCls = 'ant-calendar';
        this.invalidInputClass = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} event
     * @return {?}
     */
    onInputKeyup(event) {
        const /** @type {?} */ date = this.checkValidInputDate(event);
        if (!date || (this.disabledDate && this.disabledDate(date.nativeDate))) {
            return;
        }
        if (!date.isSame(this.value, 'second')) {
            // Not same with original value
            this.value = date;
            this.valueChange.emit(this.value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    toReadableInput(value) {
        return value ? this.i18n.formatDateCompatible(value.nativeDate, this.format) : '';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    checkValidInputDate(event) {
        const /** @type {?} */ input = (/** @type {?} */ (event.target)).value;
        const /** @type {?} */ date = new CandyDate(input);
        this.invalidInputClass = '';
        if (date.isInvalid() || input !== this.toReadableInput(date)) {
            // Should also match the input format exactly
            this.invalidInputClass = `${this.prefixCls}-input-invalid`;
            return null;
        }
        return date;
    }
}
CalendarInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'calendar-input',
                template: `<div class="{{ prefixCls }}-input-wrap"> <div class="{{ prefixCls }}-date-input-wrap"> <input class="{{ prefixCls }}-input {{ invalidInputClass }}" placeholder="{{ placeholder || locale.dateSelect }}" value="{{ toReadableInput(value) }}" (keyup)="onInputKeyup($event)" /> </div> <a class="{{ prefixCls }}-clear-btn" role="button" title="{{ locale.clear }}"></a> </div>`
            },] },
];
/** @nocollapse */
CalendarInputComponent.ctorParameters = () => [
    { type: NzI18nService }
];
CalendarInputComponent.propDecorators = {
    locale: [{ type: Input }],
    format: [{ type: Input }],
    placeholder: [{ type: Input }],
    disabledDate: [{ type: Input }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class OkButtonComponent {
    constructor() {
        this.okDisabled = false;
        this.clickOk = new EventEmitter();
        this.prefixCls = 'ant-calendar';
    }
}
OkButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'ok-button',
                template: `<a class="{{ prefixCls }}-ok-btn {{ okDisabled ? prefixCls + '-ok-btn-disabled' : '' }}" role="button" (click)="okDisabled ? null : clickOk.emit()" > {{ locale.ok }} </a>`
            },] },
];
OkButtonComponent.propDecorators = {
    locale: [{ type: Input }],
    okDisabled: [{ type: Input }],
    clickOk: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TimePickerButtonComponent {
    constructor() {
        this.timePickerDisabled = false;
        this.showTimePicker = false;
        this.showTimePickerChange = new EventEmitter();
        this.prefixCls = 'ant-calendar';
    }
    /**
     * @return {?}
     */
    onClick() {
        this.showTimePicker = !this.showTimePicker;
        this.showTimePickerChange.emit(this.showTimePicker);
    }
}
TimePickerButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'time-picker-button',
                template: `<a class="{{ prefixCls }}-time-picker-btn {{ timePickerDisabled ? prefixCls + '-time-picker-btn-disabled' : '' }}" role="button" (click)="timePickerDisabled ? null : onClick()" > {{ showTimePicker ? locale.dateSelect : locale.timeSelect }} </a>`
            },] },
];
TimePickerButtonComponent.propDecorators = {
    locale: [{ type: Input }],
    timePickerDisabled: [{ type: Input }],
    showTimePicker: [{ type: Input }],
    showTimePickerChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TodayButtonComponent {
    /**
     * @param {?} i18n
     */
    constructor(i18n) {
        this.i18n = i18n;
        this.hasTimePicker = false;
        this.clickToday = new EventEmitter();
        this.prefixCls = 'ant-calendar';
        this.isDisabled = false;
        this.now = new CandyDate();
    }
    /**
     * @return {?}
     */
    get title() {
        return this.i18n.formatDate(this.now.nativeDate, 'longDate');
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["disabledDate"]) {
            this.isDisabled = this.disabledDate && this.disabledDate(this.now.nativeDate);
        }
    }
    /**
     * @return {?}
     */
    onClickToday() {
        this.clickToday.emit(this.now.clone()); // To prevent the "now" being modified from outside, we use clone
    }
}
TodayButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'today-button',
                template: `<a class="{{ prefixCls }}-today-btn {{ isDisabled ? prefixCls + '-today-btn-disabled' : '' }}" role="button" (click)="isDisabled ? null : onClickToday()" title="{{ title }}" > {{ hasTimePicker ? locale.now : locale.today }} </a>`
            },] },
];
/** @nocollapse */
TodayButtonComponent.ctorParameters = () => [
    { type: NzI18nService }
];
TodayButtonComponent.propDecorators = {
    locale: [{ type: Input }],
    hasTimePicker: [{ type: Input }],
    disabledDate: [{ type: Input }],
    clickToday: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DATE_ROW_NUM = 6;
const DATE_COL_NUM = 7;
class DateTableComponent {
    /**
     * @param {?} i18n
     */
    constructor(i18n) {
        this.i18n = i18n;
        this.valueChange = new EventEmitter();
        this.dayHover = new EventEmitter();
        this.prefixCls = 'ant-calendar';
        this.isTemplateRef = isTemplateRef;
        this.isNonEmptyString = isNonEmptyString;
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.isDateRealChange(changes["value"]) ||
            this.isDateRealChange(changes["selectedValue"]) ||
            this.isDateRealChange(changes["hoverValue"])) {
            this.render();
        }
    }
    /**
     * @param {?} change
     * @return {?}
     */
    isDateRealChange(change) {
        if (change) {
            const /** @type {?} */ previousValue = change.previousValue;
            const /** @type {?} */ currentValue = change.currentValue;
            if (Array.isArray(currentValue)) {
                return !Array.isArray(previousValue) ||
                    currentValue.length !== previousValue.length ||
                    currentValue.some((value, index) => !this.isSameDate(previousValue[index], value));
            }
            else {
                return !this.isSameDate(/** @type {?} */ (previousValue), currentValue);
            }
        }
        return false;
    }
    /**
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    isSameDate(left, right) {
        return (!left && !right) || (left && right && right.isSame(left, 'day'));
    }
    /**
     * @return {?}
     */
    render() {
        if (this.value) {
            this.headWeekDays = this.makeHeadWeekDays();
            this.weekRows = this.makeWeekRows();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    changeValueFromInside(value) {
        if (this.value !== value) {
            // this.value = value;
            // this.valueChange.emit(this.value);
            // this.render();
            this.valueChange.emit(value);
        }
    }
    /**
     * @return {?}
     */
    makeHeadWeekDays() {
        const /** @type {?} */ weekDays = [];
        const /** @type {?} */ firstDayOfWeek = this.getFirstDayOfWeek();
        for (let /** @type {?} */ colIndex = 0; colIndex < DATE_COL_NUM; colIndex++) {
            const /** @type {?} */ day = (firstDayOfWeek + colIndex) % DATE_COL_NUM;
            const /** @type {?} */ tempDate = this.value.setDay(day);
            weekDays[colIndex] = {
                short: this.i18n.formatDate(tempDate.nativeDate, 'E'),
                // eg. Tue
                veryShort: this.i18n.formatDate(tempDate.nativeDate, this.getVeryShortWeekFormat()) // eg. Tu
            };
        }
        return weekDays;
    }
    /**
     * @return {?}
     */
    getVeryShortWeekFormat() {
        return this.i18n.getLocaleId().toLowerCase().indexOf('zh') === 0 ? 'EEEEE' : 'EEEEEE'; // Use extreme short for chinese
    }
    /**
     * @return {?}
     */
    makeWeekRows() {
        // let justRendered = true;
        const /** @type {?} */ weekRows = [];
        const /** @type {?} */ firstDayOfWeek = this.getFirstDayOfWeek();
        const /** @type {?} */ firstDateOfMonth = this.value.setDate(1);
        // const firstDateToShow = firstDateOfMonth.setDay(firstDayOfWeek, { weekStartsOn: firstDayOfWeek });
        const /** @type {?} */ firstDateOffset = (firstDateOfMonth.getDay() + 7 - firstDayOfWeek) % 7;
        const /** @type {?} */ firstDateToShow = firstDateOfMonth.addDays(0 - firstDateOffset);
        let /** @type {?} */ increased = 0;
        for (let /** @type {?} */ rowIndex = 0; rowIndex < DATE_ROW_NUM; rowIndex++) {
            const /** @type {?} */ week = weekRows[rowIndex] = {
                isActive: false,
                isCurrent: false,
                dateCells: []
            };
            for (let /** @type {?} */ colIndex = 0; colIndex < DATE_COL_NUM; colIndex++) {
                const /** @type {?} */ current = firstDateToShow.addDays(increased++);
                const /** @type {?} */ isBeforeMonthYear = this.isBeforeMonthYear(current, this.value);
                const /** @type {?} */ isAfterMonthYear = this.isAfterMonthYear(current, this.value);
                const /** @type {?} */ cell = {
                    value: current,
                    isSelected: false,
                    isDisabled: false,
                    isToday: false,
                    title: this.getDateTitle(current),
                    customContent: valueFunctionProp(this.dateRender, current),
                    // Customized content
                    content: `${current.getDate()}`,
                    onClick: () => this.changeValueFromInside(current),
                    onMouseEnter: () => this.dayHover.emit(cell.value)
                };
                if (this.showWeek && !week.weekNum) {
                    week.weekNum = this.getWeekNum(current);
                }
                if (current.isToday()) {
                    cell.isToday = true;
                    week.isCurrent = true;
                }
                if (Array.isArray(this.selectedValue) && !isBeforeMonthYear && !isAfterMonthYear) {
                    // Range selections
                    const /** @type {?} */ rangeValue = this.hoverValue && this.hoverValue.length ? this.hoverValue : this.selectedValue;
                    const /** @type {?} */ start = rangeValue[0];
                    const /** @type {?} */ end = rangeValue[1];
                    if (start) {
                        if (current.isSame(start, 'day')) {
                            cell.isSelectedStartDate = true;
                            cell.isSelected = true;
                            week.isActive = true;
                        }
                        if (end) {
                            if (current.isSame(end, 'day')) {
                                cell.isSelectedEndDate = true;
                                cell.isSelected = true;
                                week.isActive = true;
                            }
                            else if (current.isAfter(start, 'day') && current.isBefore(end, 'day')) {
                                cell.isInRange = true;
                            }
                        }
                    }
                }
                else if (current.isSame(this.value, 'day')) {
                    cell.isSelected = true;
                    week.isActive = true;
                }
                if (this.disabledDate && this.disabledDate(current.nativeDate)) {
                    cell.isDisabled = true;
                }
                cell.classMap = {
                    [`${this.prefixCls}-cell`]: true,
                    // [`${this.prefixCls}-selected-date`]: false,
                    [`${this.prefixCls}-today`]: cell.isToday,
                    [`${this.prefixCls}-last-month-cell`]: isBeforeMonthYear,
                    [`${this.prefixCls}-next-month-btn-day`]: isAfterMonthYear,
                    [`${this.prefixCls}-selected-day`]: cell.isSelected,
                    [`${this.prefixCls}-disabled-cell`]: cell.isDisabled,
                    [`${this.prefixCls}-selected-start-date`]: !!cell.isSelectedStartDate,
                    [`${this.prefixCls}-selected-end-date`]: !!cell.isSelectedEndDate,
                    [`${this.prefixCls}-in-range-cell`]: !!cell.isInRange
                };
                week.dateCells.push(cell);
            }
            week.classMap = {
                [`${this.prefixCls}-current-week`]: week.isCurrent,
                [`${this.prefixCls}-active-week`]: week.isActive
            };
        }
        return weekRows;
    }
    /**
     * @return {?}
     */
    getFirstDayOfWeek() {
        return this.value.firstDayOfWeek(this.i18n.getLocaleId());
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDateTitle(date) {
        return this.i18n.formatDate(date.nativeDate, 'longDate');
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getWeekNum(date) {
        return +this.i18n.formatDate(date.nativeDate, 'w');
    }
    /**
     * @param {?} current
     * @param {?} target
     * @return {?}
     */
    isBeforeMonthYear(current, target) {
        if (current.getYear() < target.getYear()) {
            return true;
        }
        return current.getYear() === target.getYear() && current.getMonth() < target.getMonth();
    }
    /**
     * @param {?} current
     * @param {?} target
     * @return {?}
     */
    isAfterMonthYear(current, target) {
        if (current.getYear() > target.getYear()) {
            return true;
        }
        return current.getYear() === target.getYear() && current.getMonth() > target.getMonth();
    }
}
DateTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'date-table',
                template: `<table class="{{ prefixCls }}-table" cellSpacing="0" role="grid"> <thead> <tr role="row"> <th *ngIf="showWeek" role="columnheader" class="{{ prefixCls }}-column-header {{ prefixCls }}-week-number-header"> <span class="{{ prefixCls }}-column-header-inner">x</span> </th> <th *ngFor="let cell of headWeekDays" role="columnheader" title="{{ cell.short }}" class="{{ prefixCls }}-column-header" > <span class="{{ prefixCls }}-column-header-inner">{{ cell.veryShort }}</span> </th> </tr> </thead> <tbody class="{{ prefixCls }}-tbody"> <tr *ngFor="let row of weekRows" [ngClass]="row.classMap" role="row"> <td *ngIf="row.weekNum" role="gridcell" class="{{ prefixCls }}-week-number-cell"> {{ row.weekNum }} </td> <td *ngFor="let cell of row.dateCells" (click)="cell.isDisabled ? null : cell.onClick()" (mouseenter)="cell.isDisabled ? null : cell.onMouseEnter()" title="{{ cell.title }}" [ngClass]="cell.classMap" role="gridcell" > <ng-container [ngSwitch]="true"> <ng-container *ngSwitchCase="isTemplateRef(cell.customContent)"> <ng-container *ngTemplateOutlet="cell.customContent; context: { $implicit: cell.value }"></ng-container> </ng-container> <ng-container *ngSwitchCase="isNonEmptyString(cell.customContent)"> <span [innerHTML]="cell.customContent"></span> </ng-container> <ng-container *ngSwitchDefault> <div class="{{ prefixCls }}-date" [attr.aria-selected]="cell.isSelected" [attr.aria-disabled]="cell.isDisabled" > {{ cell.content }} </div> </ng-container> </ng-container> </td> </tr> </tbody> </table>`
            },] },
];
/** @nocollapse */
DateTableComponent.ctorParameters = () => [
    { type: NzI18nService }
];
DateTableComponent.propDecorators = {
    selectedValue: [{ type: Input }],
    hoverValue: [{ type: Input }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    showWeek: [{ type: Input }],
    disabledDate: [{ type: Input }],
    dateRender: [{ type: Input }],
    dayHover: [{ type: Output }]
};
/**
 * @record
 */

/**
 * @record
 */

/**
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MAX_ROW = 4;
const MAX_COL = 3;
class DecadePanelComponent {
    constructor() {
        this.valueChange = new EventEmitter();
        this.prefixCls = 'ant-calendar-decade-panel';
    }
    /**
     * @return {?}
     */
    get startYear() {
        return parseInt(`${this.value.getYear() / 100}`, 10) * 100;
    }
    /**
     * @return {?}
     */
    get endYear() {
        return this.startYear + 99;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["value"]) {
            this.render();
        }
    }
    /**
     * @return {?}
     */
    previousCentury() {
        this.gotoYear(-100);
    }
    /**
     * @return {?}
     */
    nextCentury() {
        this.gotoYear(100);
    }
    /**
     * @param {?} index
     * @param {?} decadeData
     * @return {?}
     */
    trackPanelDecade(index, decadeData) {
        return decadeData.content;
    }
    /**
     * @return {?}
     */
    render() {
        if (this.value) {
            this.panelDecades = this.makePanelDecades();
        }
    }
    /**
     * @param {?} amount
     * @return {?}
     */
    gotoYear(amount) {
        this.value = this.value.addYears(amount);
        // this.valueChange.emit(this.value); // Do not try to trigger final value change
        this.render();
    }
    /**
     * @param {?} startYear
     * @return {?}
     */
    chooseDecade(startYear) {
        this.value = this.value.setYear(startYear);
        this.valueChange.emit(this.value);
    }
    /**
     * @return {?}
     */
    makePanelDecades() {
        const /** @type {?} */ decades = [];
        const /** @type {?} */ currentYear = this.value.getYear();
        const /** @type {?} */ startYear = this.startYear;
        const /** @type {?} */ endYear = this.endYear;
        const /** @type {?} */ previousYear = startYear - 10;
        let /** @type {?} */ index = 0;
        for (let /** @type {?} */ rowIndex = 0; rowIndex < MAX_ROW; rowIndex++) {
            decades[rowIndex] = [];
            for (let /** @type {?} */ colIndex = 0; colIndex < MAX_COL; colIndex++) {
                const /** @type {?} */ start = previousYear + index * 10;
                const /** @type {?} */ end = previousYear + index * 10 + 9;
                const /** @type {?} */ content = `${start}-${end}`;
                const /** @type {?} */ cell = decades[rowIndex][colIndex] = {
                    content,
                    title: content,
                    isCurrent: currentYear >= start && currentYear <= end,
                    isLowerThanStart: end < startYear,
                    isBiggerThanEnd: start > endYear,
                    classMap: null,
                    onClick: null
                };
                cell.classMap = {
                    [`${this.prefixCls}-cell`]: true,
                    [`${this.prefixCls}-selected-cell`]: cell.isCurrent,
                    [`${this.prefixCls}-last-century-cell`]: cell.isLowerThanStart,
                    [`${this.prefixCls}-next-century-cell`]: cell.isBiggerThanEnd
                };
                if (cell.isLowerThanStart) {
                    cell.onClick = () => this.previousCentury();
                }
                else if (cell.isBiggerThanEnd) {
                    cell.onClick = () => this.nextCentury();
                }
                else {
                    cell.onClick = () => this.chooseDecade(start);
                }
                index++;
            }
        }
        return decades;
    }
}
DecadePanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'decade-panel',
                template: `<div class="{{ prefixCls }}"> <div class="{{ prefixCls }}-header"> <a class="{{ prefixCls }}-prev-century-btn" role="button" (click)="previousCentury()" title="{{ locale.previousCentury }}" ></a> <div class="{{ prefixCls }}-century"> {{ startYear }}-{{ endYear }} </div> <a class="{{ prefixCls }}-next-century-btn" role="button" (click)="nextCentury()" title="{{ locale.nextCentury }}" ></a> </div> <div class="{{ prefixCls }}-body"> <table class="{{ prefixCls }}-table" cellSpacing="0" role="grid"> <tbody class="{{ prefixCls }}-tbody"> <tr *ngFor="let row of panelDecades" role="row"> <td *ngFor="let cell of row; trackBy: trackPanelDecade" role="gridcell" title="{{ cell.title }}" (click)="cell.onClick()" [ngClass]="cell.classMap" > <a class="{{ prefixCls }}-decade">{{ cell.content }}</a> </td> </tr> </tbody> </table> </div> </div>`
            },] },
];
/** @nocollapse */
DecadePanelComponent.ctorParameters = () => [];
DecadePanelComponent.propDecorators = {
    locale: [{ type: Input }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }]
};
/**
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class MonthPanelComponent {
    constructor() {
        this.valueChange = new EventEmitter();
        this.yearPanelShow = new EventEmitter();
        this.prefixCls = 'ant-calendar-month-panel';
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    previousYear() {
        this.gotoYear(-1);
    }
    /**
     * @return {?}
     */
    nextYear() {
        this.gotoYear(1);
    }
    /**
     * @param {?} amount
     * @return {?}
     */
    gotoYear(amount) {
        this.value = this.value.addYears(amount);
        // this.valueChange.emit(this.value); // Do not try to trigger final value change
    }
}
MonthPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'month-panel',
                template: `<div class="{{ prefixCls }}"> <div> <div class="{{ prefixCls }}-header"> <a class="{{ prefixCls }}-prev-year-btn" role="button" (click)="previousYear()" title="{{ locale.previousYear }}" ></a> <a class="{{ prefixCls }}-year-select" role="button" (click)="yearPanelShow.emit()" title="{{ locale.yearSelect }}" > <span class="{{ prefixCls }}-year-select-content">{{ value.getYear() }}</span> <span class="{{ prefixCls }}-year-select-arrow">x</span> </a> <a class="{{ prefixCls }}-next-year-btn" role="button" (click)="nextYear()" title="{{ locale.nextYear }}" ></a> </div> <div class="{{ prefixCls }}-body"> <month-table [disabledDate]="disabledDate" [value]="value" (valueChange)="valueChange.emit($event)"></month-table> </div> </div> </div>`
            },] },
];
/** @nocollapse */
MonthPanelComponent.ctorParameters = () => [];
MonthPanelComponent.propDecorators = {
    locale: [{ type: Input }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    disabledDate: [{ type: Input }],
    yearPanelShow: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MAX_ROW$1 = 4;
const MAX_COL$1 = 3;
class MonthTableComponent {
    /**
     * @param {?} i18n
     */
    constructor(i18n) {
        this.i18n = i18n;
        this.valueChange = new EventEmitter();
        this.prefixCls = 'ant-calendar-month-panel';
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["value"] || changes["disabledDate"]) {
            this.render();
        }
    }
    /**
     * @param {?} index
     * @param {?} monthData
     * @return {?}
     */
    trackPanelMonth(index, monthData) {
        return monthData.month;
    }
    /**
     * @return {?}
     */
    render() {
        if (this.value) {
            this.panelMonths = this.makePanelMonths();
        }
    }
    /**
     * @return {?}
     */
    makePanelMonths() {
        const /** @type {?} */ months = [];
        const /** @type {?} */ currentMonth = this.value.getMonth();
        const /** @type {?} */ today = new CandyDate();
        let /** @type {?} */ monthValue = 0;
        for (let /** @type {?} */ rowIndex = 0; rowIndex < MAX_ROW$1; rowIndex++) {
            months[rowIndex] = [];
            for (let /** @type {?} */ colIndex = 0; colIndex < MAX_COL$1; colIndex++) {
                const /** @type {?} */ month = this.value.setMonth(monthValue);
                const /** @type {?} */ disabled = this.disabledDate ? this.disabledDate(this.value.setMonth(monthValue).nativeDate) : false;
                const /** @type {?} */ content = this.i18n.formatDateCompatible(month.nativeDate, 'MMM');
                const /** @type {?} */ cell = months[rowIndex][colIndex] = {
                    disabled,
                    content,
                    month: monthValue,
                    title: content,
                    classMap: null,
                    onClick: () => this.chooseMonth(cell.month)
                };
                cell.classMap = {
                    [`${this.prefixCls}-cell`]: true,
                    [`${this.prefixCls}-cell-disabled`]: disabled,
                    [`${this.prefixCls}-selected-cell`]: cell.month === currentMonth,
                    [`${this.prefixCls}-current-cell`]: today.getYear() === this.value.getYear() && cell.month === today.getMonth()
                };
                monthValue++;
            }
        }
        return months;
    }
    /**
     * @param {?} month
     * @return {?}
     */
    chooseMonth(month) {
        this.value = this.value.setMonth(month);
        this.valueChange.emit(this.value);
        this.render();
    }
}
MonthTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'month-table',
                template: `<table class="{{ prefixCls }}-table" cellSpacing="0" role="grid"> <tbody class="{{ prefixCls }}-tbody"> <tr *ngFor="let row of panelMonths" role="row"> <td *ngFor="let monthCell of row; trackBy: trackPanelMonth" role="gridcell" title="{{ monthCell.title }}" (click)="monthCell.disabled ? null : monthCell.onClick()" [ngClass]="monthCell.classMap" > <a class="{{ prefixCls }}-month">{{ monthCell.content }}</a> </td> </tr> </tbody> </table>`
            },] },
];
/** @nocollapse */
MonthTableComponent.ctorParameters = () => [
    { type: NzI18nService }
];
MonthTableComponent.propDecorators = {
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    disabledDate: [{ type: Input }]
};
/**
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const defaultDisabledTime = {
    /**
     * @return {?}
     */
    nzDisabledHours() {
        return [];
    },
    /**
     * @return {?}
     */
    nzDisabledMinutes() {
        return [];
    },
    /**
     * @return {?}
     */
    nzDisabledSeconds() {
        return [];
    }
};
/**
 * @param {?} value
 * @param {?} disabledTime
 * @return {?}
 */
function getTimeConfig(value, disabledTime) {
    let /** @type {?} */ disabledTimeConfig = disabledTime ? disabledTime(value && value.nativeDate) : /** @type {?} */ ({});
    disabledTimeConfig = Object.assign({}, defaultDisabledTime, disabledTimeConfig);
    return disabledTimeConfig;
}
/**
 * @param {?} value
 * @param {?} disabledTimeConfig
 * @return {?}
 */
function isTimeValidByConfig(value, disabledTimeConfig) {
    let /** @type {?} */ invalidTime = false;
    if (value) {
        const /** @type {?} */ hour = value.getHours();
        const /** @type {?} */ minutes = value.getMinutes();
        const /** @type {?} */ seconds = value.getSeconds();
        const /** @type {?} */ disabledHours = disabledTimeConfig.nzDisabledHours();
        if (disabledHours.indexOf(hour) === -1) {
            const /** @type {?} */ disabledMinutes = disabledTimeConfig.nzDisabledMinutes(hour);
            if (disabledMinutes.indexOf(minutes) === -1) {
                const /** @type {?} */ disabledSeconds = disabledTimeConfig.nzDisabledSeconds(hour, minutes);
                invalidTime = disabledSeconds.indexOf(seconds) !== -1;
            }
            else {
                invalidTime = true;
            }
        }
        else {
            invalidTime = true;
        }
    }
    return !invalidTime;
}
/**
 * @param {?} value
 * @param {?} disabledTime
 * @return {?}
 */
function isTimeValid(value, disabledTime) {
    const /** @type {?} */ disabledTimeConfig = getTimeConfig(value, disabledTime);
    return isTimeValidByConfig(value, disabledTimeConfig);
}
/**
 * @param {?} value
 * @param {?=} disabledDate
 * @param {?=} disabledTime
 * @return {?}
 */
function isAllowedDate(value, disabledDate, disabledTime) {
    if (disabledDate) {
        if (disabledDate(value.nativeDate)) {
            return false;
        }
    }
    if (disabledTime) {
        if (!isTimeValid(value, disabledTime)) {
            return false;
        }
    }
    return true;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DateRangePopupComponent {
    constructor() {
        this.panelModeChange = new EventEmitter();
        this.valueChange = new EventEmitter();
        this.resultOk = new EventEmitter();
        this.closePicker = new EventEmitter();
        // @Output() selectDate = new EventEmitter<CandyDate>(); // Emitted when the date is selected by click the date panel (if isRange, the returned date is from one of the range parts)
        this.prefixCls = 'ant-calendar';
        this.showTimePicker = false;
        this.partTypeMap = { 'left': 0, 'right': 1 };
        this.disabledStartTime = (value) => {
            return this.disabledTime && this.disabledTime(value, 'start');
        };
        this.disabledEndTime = (value) => {
            return this.disabledTime && this.disabledTime(value, 'end');
        };
    }
    /**
     * @return {?}
     */
    get hasTimePicker() {
        return !!this.showTime;
    }
    /**
     * @return {?}
     */
    get hasFooter() {
        return this.showToday || this.hasTimePicker || !!this.extraFooter || !!this.ranges;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Initialization for range properties to prevent errors while later assignment
        if (this.isRange) {
            ['placeholder', 'panelMode', 'selectedValue', 'hoverValue'].forEach((prop) => this.initialArray(prop));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.isRange) {
            if (changes["value"]) {
                // Re-initialize all related values
                this.clearHoverValue();
                this.selectedValue = /** @type {?} */ (this.value);
                this.valueForRangeShow = this.normalizeRangeValue(/** @type {?} */ (this.value));
            }
        }
        // Parse showTime options
        if (changes["showTime"] || changes["disabledTime"]) {
            if (this.showTime) {
                this.buildTimeOptions();
            }
        }
        // Show time picker when assigned panel mode as "time"
        if (changes["panelMode"] && this.hasTimePicker) {
            this.showTimePicker = this.panelMode === 'time';
        }
    }
    /**
     * @param {?} show
     * @return {?}
     */
    onShowTimePickerChange(show) {
        // this.panelMode = show ? 'time' : 'date';
        // this.panelModeChange.emit(this.panelMode);
        this.panelModeChange.emit(show ? 'time' : 'date');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onClickToday(value) {
        // if (this.isRange) { // Show today is not support by range
        //   throw new Error('"nzShowToday" is not support for "RangePicker"!');
        // } else {
        if (!this.isRange) {
            this.value = null; // Clear current value to not sync time by next step
            this.changeValue(value);
        }
        this.closePickerPanel();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onDayHover(value) {
        if (this.isRange && this.selectedValue[0] && !this.selectedValue[1]) {
            // When right value is selected, don't do hover
            const /** @type {?} */ base = this.selectedValue[0]; // Use the left of selected value as the base to decide later hoverValue
            if (base.isBefore(value, 'day')) {
                this.hoverValue = [base, value];
            }
            else {
                this.hoverValue = [value, base];
            }
        }
    }
    /**
     * @param {?} mode
     * @param {?=} partType
     * @return {?}
     */
    onPanelModeChange(mode, partType) {
        if (this.isRange) {
            (/** @type {?} */ (this.panelMode))[this.getPartTypeIndex(partType)] = mode;
        }
        else {
            this.panelMode = mode;
        }
        this.panelModeChange.emit(this.panelMode);
    }
    /**
     * @param {?} value
     * @param {?=} partType
     * @return {?}
     */
    onHeaderChange(value, partType) {
        if (this.isRange) {
            this.valueForRangeShow[this.getPartTypeIndex(partType)] = value;
            this.valueForRangeShow = this.normalizeRangeValue(this.valueForRangeShow); // Should always take care of start/end
        }
    }
    /**
     * @param {?} value
     * @param {?=} partType
     * @return {?}
     */
    onSelectTime(value, partType) {
        if (this.isRange) {
            const /** @type {?} */ newValue = this.cloneRangeDate(/** @type {?} */ (this.value));
            const /** @type {?} */ index = this.getPartTypeIndex(partType);
            newValue[index] = this.overrideHms(value, newValue[index]);
            this.setValue(newValue);
        }
        else {
            this.setValue(this.overrideHms(value, (/** @type {?} */ (this.value)) || new CandyDate())); // If not select a date currently, use today
        }
    }
    /**
     * @param {?} value
     * @param {?=} partType
     * @return {?}
     */
    changeValue(value, partType) {
        if (this.isRange) {
            const /** @type {?} */ index = this.getPartTypeIndex(partType);
            this.selectedValue[index] = value;
            if (this.isValidRange(this.selectedValue)) {
                this.valueForRangeShow = this.normalizeRangeValue(this.selectedValue);
                this.setValue(this.cloneRangeDate(this.selectedValue));
            }
        }
        else {
            this.setValue(value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    changeValueFromSelect(value) {
        if (this.isRange) {
            const [left, right] = /** @type {?} */ (this.selectedValue); // NOTE: the left/right maybe not the sequence it select at the date panels
            if ((!left && !right) || (left && right)) {
                // If totally full or empty, clean up && re-assign left first
                this.hoverValue = this.selectedValue = [value];
            }
            else if (left && !right) {
                // If one of them is empty, assign the other one and sort, then set the final values
                this.clearHoverValue(); // Clean up
                this.setRangeValue('selectedValue', 'right', value);
                this.sortRangeValue('selectedValue'); // Sort
                this.valueForRangeShow = this.normalizeRangeValue(this.selectedValue);
                this.setValue(this.cloneRangeDate(this.selectedValue));
            }
        }
        else {
            this.setValue(value);
        }
        // this.selectDate.emit(value);
    }
    /**
     * @param {?} direction
     * @param {?=} partType
     * @return {?}
     */
    enablePrevNext(direction, partType) {
        if (this.isRange) {
            const [start, end] = this.valueForRangeShow;
            const /** @type {?} */ showMiddle = !start.addMonths(1).isSame(end, 'month'); // One month diff then don't show middle prev/next
            if ((partType === 'left' && direction === 'next') || (partType === 'right' && direction === 'prev')) {
                return showMiddle;
            }
            return true;
        }
        else {
            return true;
        }
    }
    /**
     * @param {?=} partType
     * @return {?}
     */
    getPanelMode(partType) {
        if (this.isRange) {
            return /** @type {?} */ (this.panelMode[this.getPartTypeIndex(partType)]);
        }
        else {
            return /** @type {?} */ (this.panelMode);
        }
    }
    /**
     * @param {?=} partType
     * @return {?}
     */
    getValue(partType) {
        if (this.isRange) {
            return this.value[this.getPartTypeIndex(partType)];
        }
        else {
            return /** @type {?} */ (this.value);
        }
    }
    /**
     * @param {?=} partType
     * @return {?}
     */
    getValueBySelector(partType) {
        if (this.isRange) {
            const /** @type {?} */ valueShow = this.showTimePicker ? this.value : this.valueForRangeShow; // Use the real time value that without decorations when timepicker is shown up
            return valueShow[this.getPartTypeIndex(partType)];
        }
        else {
            return /** @type {?} */ (this.value);
        }
    }
    /**
     * @param {?} partType
     * @return {?}
     */
    getPartTypeIndex(partType) {
        return this.partTypeMap[partType];
    }
    /**
     * @param {?=} partType
     * @return {?}
     */
    getPlaceholder(partType) {
        return this.isRange ? this.placeholder[this.getPartTypeIndex(partType)] : /** @type {?} */ (this.placeholder);
    }
    /**
     * @return {?}
     */
    hasSelectedValue() {
        return this.selectedValue && !!this.selectedValue[1] && !!this.selectedValue[0];
    }
    /**
     * @return {?}
     */
    isAllowedSelectedValue() {
        const /** @type {?} */ selectedValue = this.selectedValue;
        if (selectedValue && selectedValue[0] && selectedValue[1]) {
            return isAllowedDate(selectedValue[0], this.disabledDate, this.disabledStartTime) &&
                isAllowedDate(selectedValue[1], this.disabledDate, this.disabledEndTime);
        }
        return false;
    }
    /**
     * @return {?}
     */
    timePickerDisabled() {
        if (!this.hasTimePicker) {
            return true;
        }
        if (this.isRange) {
            return !this.hasSelectedValue() || !!this.hoverValue.length;
        }
        else {
            return false;
        }
    }
    /**
     * @return {?}
     */
    okDisabled() {
        if (!this.hasTimePicker) {
            return true;
        }
        if (this.isRange) {
            return !this.isAllowedSelectedValue() || !this.hasSelectedValue() || !!this.hoverValue.length;
        }
        else {
            return this.value ? !isAllowedDate(/** @type {?} */ (this.value), this.disabledDate, this.disabledTime) : false;
        }
    }
    /**
     * @param {?=} partType
     * @return {?}
     */
    getTimeOptions(partType) {
        if (this.showTime && this.timeOptions) {
            return this.isRange ? this.timeOptions[this.getPartTypeIndex(partType)] : this.timeOptions;
        }
        return null;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    onClickPresetRange(val) {
        const /** @type {?} */ value = valueFunctionProp(val);
        this.setValue([new CandyDate(value[0]), new CandyDate(value[1])]);
        this.resultOk.emit();
    }
    /**
     * @return {?}
     */
    onPresetRangeMouseLeave() {
        this.clearHoverValue();
    }
    /**
     * @param {?} val
     * @return {?}
     */
    onHoverPresetRange(val) {
        this.hoverValue = ([new CandyDate(val[0]), new CandyDate(val[1])]);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    getObjectKeys(obj) {
        return obj ? Object.keys(obj) : [];
    }
    /**
     * @return {?}
     */
    closePickerPanel() {
        this.closePicker.emit();
    }
    /**
     * @return {?}
     */
    clearHoverValue() {
        this.hoverValue = [];
    }
    /**
     * @return {?}
     */
    buildTimeOptions() {
        if (this.showTime) {
            const /** @type {?} */ showTime = typeof this.showTime === 'object' ? this.showTime : {};
            if (this.isRange) {
                this.timeOptions = [this.overrideTimeOptions(showTime, this.value[0], 'start'), this.overrideTimeOptions(showTime, this.value[1], 'end')];
            }
            else {
                this.timeOptions = this.overrideTimeOptions(showTime, /** @type {?} */ (this.value));
            }
        }
        else {
            this.timeOptions = null;
        }
    }
    /**
     * @param {?} origin
     * @param {?} value
     * @param {?=} partial
     * @return {?}
     */
    overrideTimeOptions(origin, value, partial) {
        let /** @type {?} */ disabledTimeFn;
        if (partial) {
            disabledTimeFn = partial === 'start' ? this.disabledStartTime : this.disabledEndTime;
        }
        else {
            disabledTimeFn = this.disabledTime;
        }
        return Object.assign({}, origin, getTimeConfig(value, disabledTimeFn));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setValue(value) {
        const /** @type {?} */ newValue = value;
        // TODO: Sync original time (NOTE: this should take more care of beacuse it may depend on many change sources)
        // if (this.isRange) {
        //   // TODO: Sync time
        // } else {
        //   if (this.value) { // Sync time from the original one if it's available
        //     newValue = this.overrideHms(this.value as CandyDate, newValue as CandyDate);
        //   }
        // }
        this.value = newValue;
        this.valueChange.emit(this.value);
        this.buildTimeOptions();
    }
    /**
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    overrideHms(from, to) {
        if (!from || !to) {
            return null;
        }
        return to.setHms(from.getHours(), from.getMinutes(), from.getSeconds());
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isValidRange(value) {
        if (Array.isArray(value)) {
            const [start, end] = value;
            const /** @type {?} */ grain = this.hasTimePicker ? 'second' : 'day';
            return start && end && (start.isBefore(end, grain) || start.isSame(end, grain));
        }
        return false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    normalizeRangeValue(value) {
        const [start, end] = value;
        const /** @type {?} */ newStart = start || new CandyDate();
        const /** @type {?} */ newEnd = end && end.isSame(newStart, 'month') ? end.addMonths(1) : end || newStart.addMonths(1);
        return [newStart, newEnd];
    }
    /**
     * @param {?} key
     * @return {?}
     */
    sortRangeValue(key) {
        if (Array.isArray(this[key])) {
            const [start, end] = this[key];
            if (start && end && start.isAfter(end, 'day')) {
                this[key] = [end, start];
            }
        }
    }
    /**
     * @param {?} key
     * @param {?} partType
     * @param {?} value
     * @return {?}
     */
    setRangeValue(key, partType, value) {
        const /** @type {?} */ ref = this[key] = this.cloneRangeDate(/** @type {?} */ (this[key]));
        ref[this.getPartTypeIndex(partType)] = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    cloneRangeDate(value) {
        return /** @type {?} */ ([value[0] && value[0].clone(), value[1] && value[1].clone()]);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    initialArray(key) {
        if (!this[key] || !Array.isArray(this[key])) {
            this[key] = [];
        }
    }
}
DateRangePopupComponent.decorators = [
    { type: Component, args: [{
                selector: 'date-range-popup',
                template: `<div class="{{ prefixCls }}-picker-container {{ dropdownClassName }} {{ prefixCls }}-picker-container-placement-bottomLeft" [ngStyle]="popupStyle"> <div class="{{ prefixCls }} {{ showWeek ? prefixCls + '-week-number': '' }} {{ hasTimePicker ? prefixCls + '-time' : '' }} {{ isRange ? prefixCls + '-range' : '' }}" tabindex="0"> <div class="{{ prefixCls }}-panel"> <ng-container *ngIf="!isRange"> <!-- Single ONLY --> <ng-container *ngTemplateOutlet="tplCalendarInput"></ng-container> </ng-container> <div class="{{ prefixCls }}-date-panel"> <ng-container *ngIf="isRange; else tplSinglePart"> <!-- Range Selectors --> <ng-container *ngTemplateOutlet="tplRangePart; context: { partType: 'left' }"></ng-container> <div class="ant-calendar-range-middle">~</div> <ng-container *ngTemplateOutlet="tplRangePart; context: { partType: 'right' }"></ng-container> </ng-container> <ng-container *ngIf="!isRange"> <!-- Single ONLY --> <ng-container *ngTemplateOutlet="tplFooter"></ng-container> </ng-container> </div> <ng-container *ngIf="isRange"> <!-- Range ONLY --> <ng-container *ngTemplateOutlet="tplFooter"></ng-container> </ng-container> </div> </div> </div> <ng-template #tplCalendarInput let-partType="partType"> <calendar-input [value]="getValue(partType)" (valueChange)="changeValue($event, partType)" [locale]="locale" [disabledDate]="disabledDate" [format]="format" [placeholder]="getPlaceholder(partType)" ></calendar-input> </ng-template> <ng-template #tplInnerPopup let-partType="partType"> <inner-popup [showWeek]="showWeek" [locale]="locale" [showTimePicker]="hasTimePicker && showTimePicker" [timeOptions]="getTimeOptions(partType)" [panelMode]="getPanelMode(partType)" (panelModeChange)="onPanelModeChange($event, partType)" [value]="getValueBySelector(partType)" [disabledDate]="disabledDate" [dateRender]="dateRender" [selectedValue]="selectedValue" [hoverValue]="hoverValue" [enablePrev]="enablePrevNext('prev', partType)" [enableNext]="enablePrevNext('next', partType)" (dayHover)="onDayHover($event)" (selectDate)="changeValueFromSelect($event)" (selectTime)="onSelectTime($event, partType)" (headerChange)="onHeaderChange($event, partType)" ></inner-popup> </ng-template> <ng-template #tplFooter> <calendar-footer *ngIf="hasFooter" [locale]="locale" [showToday]="showToday" [hasTimePicker]="hasTimePicker" [timePickerDisabled]="timePickerDisabled()" [okDisabled]="okDisabled()" [extraFooter]="extraFooter" [rangeQuickSelector]="ranges ? tplRangeQuickSelector : null" [(showTimePicker)]="showTimePicker" (showTimePickerChange)="onShowTimePickerChange($event)" (clickOk)="resultOk.emit()" (clickToday)="onClickToday($event)" ></calendar-footer> </ng-template> <!-- Single ONLY --> <ng-template #tplSinglePart> <ng-container *ngTemplateOutlet="tplInnerPopup"></ng-container> </ng-template> <!-- Range ONLY --> <ng-template #tplRangePart let-partType="partType"> <div class="{{ prefixCls }}-range-part {{ prefixCls }}-range-{{ partType }}"> <ng-container *ngTemplateOutlet="tplCalendarInput; context: { partType: partType }"></ng-container> <div style="outline: none;"> <ng-container *ngTemplateOutlet="tplInnerPopup; context: { partType: partType }"></ng-container> </div> </div> </ng-template> <!-- Range ONLY: Range Quick Selector --> <ng-template #tplRangeQuickSelector> <a *ngFor="let name of getObjectKeys(ranges)" (click)="onClickPresetRange(ranges[name])" (mouseenter)="onHoverPresetRange(ranges[name])" (mouseleave)="onPresetRangeMouseLeave()" >{{ name }}</a> </ng-template>`
            },] },
];
DateRangePopupComponent.propDecorators = {
    isRange: [{ type: Input }],
    showWeek: [{ type: Input }],
    locale: [{ type: Input }],
    format: [{ type: Input }],
    placeholder: [{ type: Input }],
    disabledDate: [{ type: Input }],
    disabledTime: [{ type: Input }],
    showToday: [{ type: Input }],
    showTime: [{ type: Input }],
    extraFooter: [{ type: Input }],
    ranges: [{ type: Input }],
    dateRender: [{ type: Input }],
    popupStyle: [{ type: Input }],
    dropdownClassName: [{ type: Input }],
    panelMode: [{ type: Input }],
    panelModeChange: [{ type: Output }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    resultOk: [{ type: Output }],
    closePicker: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class InnerPopupComponent {
    constructor() {
        this.panelModeChange = new EventEmitter();
        this.headerChange = new EventEmitter();
        this.selectDate = new EventEmitter();
        this.selectTime = new EventEmitter();
        this.dayHover = new EventEmitter();
        this.prefixCls = 'ant-calendar';
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["value"] && !this.value) {
            this.value = new CandyDate();
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    onSelectTime(date) {
        this.selectTime.emit(new CandyDate(date));
    }
    /**
     * @param {?} date
     * @return {?}
     */
    onSelectDate(date) {
        // this.value = date instanceof CandyDate ? date : new CandyDate(date);
        const /** @type {?} */ value = date instanceof CandyDate ? date : new CandyDate(date);
        this.selectDate.emit(value);
    }
}
InnerPopupComponent.decorators = [
    { type: Component, args: [{
                selector: 'inner-popup',
                template: `<calendar-header [(panelMode)]="panelMode" (panelModeChange)="panelModeChange.emit($event)" [(value)]="value" (valueChange)="headerChange.emit($event)" [locale]="locale" [showTimePicker]="showTimePicker" [enablePrev]="enablePrev" [enableNext]="enableNext" ></calendar-header> <ng-container *ngIf="showTimePicker && timeOptions"> <nz-time-picker-panel [nzInDatePicker]="true" [ngModel]="value.nativeDate" (ngModelChange)="onSelectTime($event)" [format]="timeOptions.nzFormat" [nzHourStep]="timeOptions.nzHourStep" [nzMinuteStep]="timeOptions.nzMinuteStep" [nzSecondStep]="timeOptions.nzSecondStep" [nzDisabledHours]="timeOptions.nzDisabledHours" [nzDisabledMinutes]="timeOptions.nzDisabledMinutes" [nzDisabledSeconds]="timeOptions.nzDisabledSeconds" [nzHideDisabledOptions]="timeOptions.nzHideDisabledOptions" [nzDefaultOpenValue]="timeOptions.nzDefaultOpenValue" [nzAddOn]="timeOptions.nzAddOn" ></nz-time-picker-panel> </ng-container> <div class="{{ prefixCls }}-body"> <date-table [showWeek]="showWeek" [value]="value" (valueChange)="onSelectDate($event)" showWeekNumber="false" [disabledDate]="disabledDate" [dateRender]="dateRender" [selectedValue]="selectedValue" [hoverValue]="hoverValue" (dayHover)="dayHover.emit($event)" ></date-table> </div>`
            },] },
];
/** @nocollapse */
InnerPopupComponent.ctorParameters = () => [];
InnerPopupComponent.propDecorators = {
    showWeek: [{ type: Input }],
    locale: [{ type: Input }],
    showTimePicker: [{ type: Input }],
    timeOptions: [{ type: Input }],
    enablePrev: [{ type: Input }],
    enableNext: [{ type: Input }],
    disabledDate: [{ type: Input }],
    dateRender: [{ type: Input }],
    selectedValue: [{ type: Input }],
    hoverValue: [{ type: Input }],
    panelMode: [{ type: Input }],
    panelModeChange: [{ type: Output }],
    value: [{ type: Input }],
    headerChange: [{ type: Output }],
    selectDate: [{ type: Output }],
    selectTime: [{ type: Output }],
    dayHover: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MAX_ROW$2 = 4;
const MAX_COL$2 = 3;
class YearPanelComponent {
    constructor() {
        this.valueChange = new EventEmitter();
        this.decadePanelShow = new EventEmitter();
        this.prefixCls = 'ant-calendar-year-panel';
    }
    /**
     * @return {?}
     */
    get currentYear() {
        return this.value.getYear();
    }
    /**
     * @return {?}
     */
    get startYear() {
        return parseInt(`${this.currentYear / 10}`, 10) * 10;
    }
    /**
     * @return {?}
     */
    get endYear() {
        return this.startYear + 9;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["value"]) {
            this.render();
        }
    }
    /**
     * @return {?}
     */
    previousDecade() {
        this.gotoYear(-10);
    }
    /**
     * @return {?}
     */
    nextDecade() {
        this.gotoYear(10);
    }
    /**
     * @param {?} index
     * @param {?} yearData
     * @return {?}
     */
    trackPanelYear(index, yearData) {
        return yearData.content;
    }
    /**
     * @return {?}
     */
    render() {
        if (this.value) {
            this.panelYears = this.makePanelYears();
        }
    }
    /**
     * @param {?} amount
     * @return {?}
     */
    gotoYear(amount) {
        this.value = this.value.addYears(amount);
        // this.valueChange.emit(this.value); // Do not trigger final value change
        this.render();
    }
    /**
     * @param {?} year
     * @return {?}
     */
    chooseYear(year) {
        this.value = this.value.setYear(year);
        this.valueChange.emit(this.value);
        this.render();
    }
    /**
     * @return {?}
     */
    makePanelYears() {
        const /** @type {?} */ years = [];
        const /** @type {?} */ currentYear = this.currentYear;
        const /** @type {?} */ startYear = this.startYear;
        const /** @type {?} */ endYear = this.endYear;
        const /** @type {?} */ previousYear = startYear - 1;
        let /** @type {?} */ index = 0;
        for (let /** @type {?} */ rowIndex = 0; rowIndex < MAX_ROW$2; rowIndex++) {
            years[rowIndex] = [];
            for (let /** @type {?} */ colIndex = 0; colIndex < MAX_COL$2; colIndex++) {
                const /** @type {?} */ year = previousYear + index;
                const /** @type {?} */ content = String(year);
                const /** @type {?} */ cell = years[rowIndex][colIndex] = {
                    content,
                    year,
                    title: content,
                    isCurrent: year === currentYear,
                    isLowerThanStart: year < startYear,
                    isBiggerThanEnd: year > endYear,
                    classMap: null,
                    onClick: null
                };
                cell.classMap = {
                    [`${this.prefixCls}-cell`]: true,
                    [`${this.prefixCls}-selected-cell`]: cell.isCurrent,
                    [`${this.prefixCls}-last-decade-cell`]: cell.isLowerThanStart,
                    [`${this.prefixCls}-next-decade-cell`]: cell.isBiggerThanEnd
                };
                if (cell.isLowerThanStart) {
                    cell.onClick = () => this.previousDecade();
                }
                else if (cell.isBiggerThanEnd) {
                    cell.onClick = () => this.nextDecade();
                }
                else {
                    cell.onClick = () => this.chooseYear(cell.year);
                }
                index++;
            }
        }
        return years;
    }
}
YearPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'year-panel',
                template: `<div class="{{ prefixCls }}"> <div> <div class="{{ prefixCls }}-header"> <a class="{{ prefixCls }}-prev-decade-btn" role="button" (click)="previousDecade()" title="{{ locale.previousDecade }}" ></a> <a class="{{ prefixCls }}-decade-select" role="button" (click)="decadePanelShow.emit()" title="{{ locale.decadeSelect }}" > <span class="{{ prefixCls }}-decade-select-content"> {{ startYear }}-{{ endYear }} </span> <span class="{{ prefixCls }}-decade-select-arrow">x</span> </a> <a class="{{ prefixCls }}-next-decade-btn" (click)="nextDecade()" title="{{ locale.nextDecade }}" role="button"></a> </div> <div class="{{ prefixCls }}-body"> <table class="{{ prefixCls }}-table" cellSpacing="0" role="grid"> <tbody class="{{ prefixCls }}-tbody"> <tr *ngFor="let row of panelYears" role="row"> <td *ngFor="let yearCell of row; trackBy: trackPanelYear" role="gridcell" title="{{ yearCell.title }}" (click)="yearCell.onClick()" [ngClass]="yearCell.classMap" > <a class="{{ prefixCls }}-year">{{ yearCell.content }}</a> </td> </tr> </tbody> </table> </div> </div> </div>`
            },] },
];
/** @nocollapse */
YearPanelComponent.ctorParameters = () => [];
YearPanelComponent.propDecorators = {
    locale: [{ type: Input }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    decadePanelShow: [{ type: Output }]
};
/**
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A collection module of standard output for all lib components
 */
class LibPackerModule {
}
LibPackerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    NzI18nModule,
                    NzTimePickerModule
                ],
                exports: [
                    CalendarHeaderComponent,
                    CalendarInputComponent,
                    CalendarFooterComponent,
                    OkButtonComponent,
                    TimePickerButtonComponent,
                    TodayButtonComponent,
                    DateTableComponent,
                    YearPanelComponent,
                    MonthPanelComponent,
                    MonthTableComponent,
                    DecadePanelComponent,
                    InnerPopupComponent,
                    DateRangePopupComponent
                ],
                declarations: [
                    CalendarHeaderComponent,
                    CalendarInputComponent,
                    CalendarFooterComponent,
                    OkButtonComponent,
                    TimePickerButtonComponent,
                    TodayButtonComponent,
                    DateTableComponent,
                    YearPanelComponent,
                    MonthPanelComponent,
                    MonthTableComponent,
                    DecadePanelComponent,
                    InnerPopupComponent,
                    DateRangePopupComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzPickerComponent {
    /**
     * @param {?} i18n
     * @param {?} changeDetector
     */
    constructor(i18n, changeDetector) {
        this.i18n = i18n;
        this.changeDetector = changeDetector;
        this.isRange = false;
        this.open = undefined;
        this.valueChange = new EventEmitter();
        this.openChange = new EventEmitter();
        this.prefixCls = 'ant-calendar';
        this.animationOpenState = false;
        this.overlayOpen = false;
        this.overlayOffsetY = 0;
        this.overlayOffsetX = -2;
        this.overlayPositions = /** @type {?} */ ([
            {
                // offsetX: -10, // TODO: What a pity, cdk/overlay current not support offset configs even though it already provide these properties
                // offsetY: -10,
                originX: 'start',
                originY: 'top',
                overlayX: 'start',
                overlayY: 'top'
            },
            {
                originX: 'start',
                originY: 'bottom',
                overlayX: 'start',
                overlayY: 'bottom'
            },
            {
                originX: 'end',
                originY: 'top',
                overlayX: 'end',
                overlayY: 'top'
            },
            {
                originX: 'end',
                originY: 'bottom',
                overlayX: 'end',
                overlayY: 'bottom'
            }
        ]);
        this.dropdownAnimation = 'bottom';
        this.currentPositionX = 'start';
        this.currentPositionY = 'top';
    }
    /**
     * @return {?}
     */
    get realOpenState() {
        // The value that really decide the open state of overlay
        return this.isOpenHandledByUser() ? this.open : this.overlayOpen;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.autoFocus) {
            if (this.isRange) {
                const /** @type {?} */ firstInput = /** @type {?} */ ((/** @type {?} */ (this.pickerInput.nativeElement)).querySelector('input:first-child'));
                firstInput.focus(); // Focus on the first input
            }
            else {
                this.pickerInput.nativeElement.focus();
            }
        }
    }
    /**
     * @return {?}
     */
    showOverlay() {
        if (!this.realOpenState) {
            this.overlayOpen = true;
            this.openChange.emit(this.overlayOpen);
            setTimeout(() => {
                if (this.cdkConnectedOverlay && this.cdkConnectedOverlay.overlayRef) {
                    this.cdkConnectedOverlay.overlayRef.updatePosition();
                }
            });
        }
    }
    /**
     * @return {?}
     */
    hideOverlay() {
        if (this.realOpenState) {
            this.overlayOpen = false;
            this.openChange.emit(this.overlayOpen);
        }
    }
    /**
     * @return {?}
     */
    onClickInputBox() {
        if (!this.disabled && !this.isOpenHandledByUser()) {
            this.showOverlay();
        }
    }
    /**
     * @return {?}
     */
    onClickBackdrop() {
        this.hideOverlay();
    }
    /**
     * @return {?}
     */
    onOverlayDetach() {
        this.hideOverlay();
    }
    /**
     * @param {?} position
     * @return {?}
     */
    onPositionChange(position) {
        this.dropdownAnimation = position.connectionPair.originY === 'top' ? 'bottom' : 'top';
        this.currentPositionX = /** @type {?} */ (position.connectionPair.originX);
        this.currentPositionY = /** @type {?} */ (position.connectionPair.originY);
        this.changeDetector.detectChanges(); // Take side-effects to position styles
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClickClear(event) {
        event.preventDefault();
        event.stopPropagation();
        this.value = this.isRange ? [] : null;
        this.valueChange.emit(this.value);
    }
    /**
     * @param {?=} partType
     * @return {?}
     */
    getReadableValue(partType) {
        let /** @type {?} */ value;
        if (this.isRange) {
            value = this.value[this.getPartTypeIndex(partType)];
        }
        else {
            value = /** @type {?} */ (this.value);
        }
        return value ? this.i18n.formatDateCompatible(value.nativeDate, this.format) : null;
    }
    /**
     * @param {?} partType
     * @return {?}
     */
    getPartTypeIndex(partType) {
        return { 'left': 0, 'right': 1 }[partType];
    }
    /**
     * @param {?=} partType
     * @return {?}
     */
    getPlaceholder(partType) {
        return this.isRange ? this.placeholder[this.getPartTypeIndex(partType)] : /** @type {?} */ (this.placeholder);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isEmptyValue(value) {
        if (this.isRange) {
            return !value || !Array.isArray(value) || value.every((val) => !val);
        }
        else {
            return !value;
        }
    }
    /**
     * @return {?}
     */
    isOpenHandledByUser() {
        return this.open !== undefined;
    }
    /**
     * @return {?}
     */
    animationStart() {
        if (this.realOpenState) {
            this.animationOpenState = true;
        }
    }
    /**
     * @return {?}
     */
    animationDone() {
        this.animationOpenState = this.realOpenState;
    }
}
NzPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-picker',
                template: `<span cdkOverlayOrigin #origin="cdkOverlayOrigin" class="{{ prefixCls }}-picker {{ size ? prefixCls + '-picker-' + size : '' }} {{ className }}" [ngStyle]="style" tabindex="0"> <!-- Content of single picker --> <ng-container *ngIf="!isRange"> <input #pickerInput class="{{ prefixCls }}-picker-input ant-input" [class.ant-input-lg]="size === 'large'" [class.ant-input-sm]="size === 'small'" [class.ant-input-disabled]="disabled" (click)="onClickInputBox()" [disabled]="disabled" readonly value="{{ getReadableValue() }}" placeholder="{{ getPlaceholder() }}" /> <ng-container *ngTemplateOutlet="tplRightRest"></ng-container> </ng-container> <!-- Content of range picker --> <ng-container *ngIf="isRange"> <span #pickerInput class="{{ prefixCls }}-picker-input ant-input" [class.ant-input-lg]="size === 'large'" [class.ant-input-sm]="size === 'small'" [class.ant-input-disabled]="disabled" (click)="onClickInputBox()" > <ng-container *ngTemplateOutlet="tplRangeInput; context: { partType: 'left' }"></ng-container> <span class="{{ prefixCls }}-range-picker-separator"> ~ </span> <ng-container *ngTemplateOutlet="tplRangeInput; context: { partType: 'right' }"></ng-container> <ng-container *ngTemplateOutlet="tplRightRest"></ng-container> </span> </ng-container> </span> <!-- Input for Range ONLY --> <ng-template #tplRangeInput let-partType="partType"> <input class="{{ prefixCls }}-range-picker-input" [disabled]="disabled" readonly value="{{ getReadableValue(partType) }}" placeholder="{{ getPlaceholder(partType) }}" /> </ng-template> <!-- Right operator icons --> <ng-template #tplRightRest> <i *ngIf="!disabled && !isEmptyValue(value) && allowClear" class="anticon anticon-cross-circle {{ prefixCls }}-picker-clear" (click)="onClickClear($event)" ></i> <span class="{{ prefixCls }}-picker-icon"></span> </ng-template> <!-- Overlay --> <ng-template cdkConnectedOverlay [cdkConnectedOverlayOrigin]="origin" [cdkConnectedOverlayOpen]="realOpenState" [cdkConnectedOverlayHasBackdrop]="!isOpenHandledByUser()" [cdkConnectedOverlayPositions]="overlayPositions" (positionChange)="onPositionChange($event)" (backdropClick)="onClickBackdrop()" (detach)="onOverlayDetach()" > <div [@dropDownAnimation]="dropdownAnimation" (@dropDownAnimation.start)="animationStart()" (@dropDownAnimation.done)="animationDone()" style="position: relative;" [style.left]="currentPositionX === 'start' ? '-2px' : '2px'" [style.top]="currentPositionY === 'top' ? '-2px' : '2px'" > <!-- Compatible for overlay that not support offset dynamically and immediately --> <ng-content></ng-content> </div> </ng-template>`,
                animations: [
                    dropDownAnimation
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
NzPickerComponent.ctorParameters = () => [
    { type: NzI18nService },
    { type: ChangeDetectorRef }
];
NzPickerComponent.propDecorators = {
    isRange: [{ type: Input }],
    open: [{ type: Input }],
    disabled: [{ type: Input }],
    placeholder: [{ type: Input }],
    allowClear: [{ type: Input }],
    autoFocus: [{ type: Input }],
    className: [{ type: Input }],
    format: [{ type: Input }],
    size: [{ type: Input }],
    style: [{ type: Input }],
    value: [{ type: Input }],
    valueChange: [{ type: Output }],
    openChange: [{ type: Output }],
    origin: [{ type: ViewChild, args: ['origin',] }],
    cdkConnectedOverlay: [{ type: ViewChild, args: [CdkConnectedOverlay,] }],
    pickerInput: [{ type: ViewChild, args: ['pickerInput',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const POPUP_STYLE_PATCH = { 'position': 'relative' };
/**
 * The base picker for all common APIs
 * @abstract
 */
class AbstractPickerComponent {
    /**
     * @param {?} i18n
     */
    constructor(i18n) {
        this.i18n = i18n;
        // --- Common API
        this.nzAllowClear = true;
        this.nzAutoFocus = false;
        this.nzDisabled = false;
        this.nzPopupStyle = POPUP_STYLE_PATCH;
        this.nzOnOpenChange = new EventEmitter();
        this.isRange = false;
        this.destroyed$ = new Subject();
        this.isCustomPlaceHolder = false;
        // ------------------------------------------------------------------------
        // | Control value accessor implements
        // ------------------------------------------------------------------------
        // NOTE: onChangeFn/onTouchedFn will not be assigned if user not use as ngModel
        this.onChangeFn = () => void 0;
        this.onTouchedFn = () => void 0;
    }
    /**
     * @return {?}
     */
    get realOpenState() {
        return this.picker.animationOpenState;
    }
    /**
     * @return {?}
     */
    initValue() {
        this.nzValue = this.isRange ? [] : null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Subscribe the every locale change if the nzLocale is not handled by user
        if (!this.nzLocale) {
            this.i18n.localeChange
                .pipe(takeUntil(this.destroyed$))
                .subscribe(() => this.setLocale());
        }
        // Default value
        this.initValue();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["nzPopupStyle"]) {
            // Always assign the popup style patch
            this.nzPopupStyle = this.nzPopupStyle ? Object.assign({}, this.nzPopupStyle, POPUP_STYLE_PATCH) : POPUP_STYLE_PATCH;
        }
        // Mark as customized placeholder by user once nzPlaceHolder assigned at the first time
        if (changes["nzPlaceHolder"] && changes["nzPlaceHolder"].firstChange && typeof this.nzPlaceHolder !== 'undefined') {
            this.isCustomPlaceHolder = true;
        }
        if (changes["nzLocale"]) {
            // The nzLocale is currently handled by user
            this.setDefaultPlaceHolder();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyed$.next();
        this.destroyed$.complete();
    }
    /**
     * @return {?}
     */
    closeOverlay() {
        this.picker.hideOverlay();
    }
    /**
     * Common handle for value changes
     * @param {?} value changed value
     * @return {?}
     */
    onValueChange(value) {
        this.nzValue = value;
        if (this.isRange) {
            if ((/** @type {?} */ (this.nzValue)).length) {
                this.onChangeFn([this.nzValue[0].nativeDate, this.nzValue[1].nativeDate]);
            }
            else {
                this.onChangeFn([]);
            }
        }
        else {
            if (this.nzValue) {
                this.onChangeFn((/** @type {?} */ (this.nzValue)).nativeDate);
            }
            else {
                this.onChangeFn(null);
            }
        }
        this.onTouchedFn();
    }
    /**
     * Triggered when overlayOpen changes (different with realOpenState)
     * @param {?} open The overlayOpen in picker component
     * @return {?}
     */
    onOpenChange(open) {
        this.nzOnOpenChange.emit(open);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.setValue(value);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        // tslint:disable-line:no-any
        this.onChangeFn = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        // tslint:disable-line:no-any
        this.onTouchedFn = fn;
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    setDisabledState(disabled) {
        this.nzDisabled = disabled;
    }
    /**
     * @return {?}
     */
    setLocale() {
        this.nzLocale = this.i18n.getLocaleData('DatePicker', {});
        this.setDefaultPlaceHolder();
    }
    /**
     * @return {?}
     */
    setDefaultPlaceHolder() {
        if (!this.isCustomPlaceHolder && this.nzLocale) {
            this.nzPlaceHolder = this.isRange ? this.nzLocale.lang.rangePlaceholder : this.nzLocale.lang.placeholder;
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    formatDate(date) {
        return date ? this.i18n.formatDateCompatible(date.nativeDate, this.nzFormat) : '';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setValue(value) {
        if (this.isRange) {
            this.nzValue = value ? (/** @type {?} */ (value)).map(val => new CandyDate(val)) : [];
        }
        else {
            this.nzValue = value ? new CandyDate(/** @type {?} */ (value)) : null;
        }
    }
}
AbstractPickerComponent.propDecorators = {
    nzAllowClear: [{ type: Input }],
    nzAutoFocus: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzOpen: [{ type: Input }],
    nzClassName: [{ type: Input }],
    nzDisabledDate: [{ type: Input }],
    nzLocale: [{ type: Input }],
    nzPlaceHolder: [{ type: Input }],
    nzPopupStyle: [{ type: Input }],
    nzDropdownClassName: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzStyle: [{ type: Input }],
    nzOnOpenChange: [{ type: Output }],
    nzFormat: [{ type: Input }],
    nzValue: [{ type: Input }],
    picker: [{ type: ViewChild, args: [NzPickerComponent,] }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], AbstractPickerComponent.prototype, "nzAllowClear", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], AbstractPickerComponent.prototype, "nzAutoFocus", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], AbstractPickerComponent.prototype, "nzDisabled", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], AbstractPickerComponent.prototype, "nzOpen", void 0);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DateRangePickerComponent extends AbstractPickerComponent {
    /**
     * @param {?} i18n
     * @param {?} logger
     */
    constructor(i18n, logger) {
        super(i18n);
        this.logger = logger;
        this.showWeek = false;
        this.nzShowToday = true;
        this.nzOnPanelChange = new EventEmitter();
        this.nzOnOk = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get nzShowTime() { return this._showTime; }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowTime(value) {
        this._showTime = typeof value === 'object' ? value : toBoolean(value);
    }
    /**
     * @return {?}
     */
    get realShowToday() {
        // Range not support nzShowToday currently
        return !this.isRange && this.nzShowToday;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // Default format when it's empty
        if (!this.nzFormat) {
            if (this.showWeek) {
                this.nzFormat = 'yyyy-ww'; // Format for week
            }
            else {
                this.nzFormat = this.nzShowTime ? 'yyyy-MM-dd HH:mm:ss' : 'yyyy-MM-dd';
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes["nzRenderExtraFooter"]) {
            this.extraFooter = valueFunctionProp(this.nzRenderExtraFooter);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onValueChange(value) {
        super.onValueChange(value);
        if (!this.nzShowTime) {
            this.closeOverlay();
        }
    }
    /**
     * @return {?}
     */
    onResultOk() {
        if (this.isRange) {
            if ((/** @type {?} */ (this.nzValue)).length) {
                this.nzOnOk.emit([this.nzValue[0].nativeDate, this.nzValue[1].nativeDate]);
            }
            else {
                this.nzOnOk.emit([]);
            }
        }
        else {
            if (this.nzValue) {
                this.nzOnOk.emit((/** @type {?} */ (this.nzValue)).nativeDate);
            }
            else {
                this.nzOnOk.emit(null);
            }
        }
        this.closeOverlay();
    }
    /**
     * @param {?} open
     * @return {?}
     */
    onOpenChange(open) {
        this.nzOnOpenChange.emit(open);
    }
}
DateRangePickerComponent.decorators = [
    { type: Component, args: [{
                template: `` // Just for rollup
            },] },
];
/** @nocollapse */
DateRangePickerComponent.ctorParameters = () => [
    { type: NzI18nService },
    { type: LoggerService }
];
DateRangePickerComponent.propDecorators = {
    nzDateRender: [{ type: Input }],
    nzDisabledTime: [{ type: Input }],
    nzRenderExtraFooter: [{ type: Input }],
    nzShowToday: [{ type: Input }],
    nzMode: [{ type: Input }],
    nzRanges: [{ type: Input }],
    nzOnPanelChange: [{ type: Output }],
    nzShowTime: [{ type: Input }],
    nzOnOk: [{ type: Output }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], DateRangePickerComponent.prototype, "nzShowToday", void 0);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDatePickerComponent extends DateRangePickerComponent {
    constructor() {
        super(...arguments);
        this.isRange = false;
    }
}
NzDatePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-date-picker',
                template: `<nz-picker [isRange]="isRange" [value]="nzValue" (valueChange)="onValueChange($event)" [open]="nzOpen" [disabled]="nzDisabled" [format]="nzFormat" [allowClear]="nzAllowClear" [autoFocus]="nzAutoFocus" [className]="nzClassName" [placeholder]="nzPlaceHolder" [size]="nzSize" [style]="nzStyle" (openChange)="onOpenChange($event)" > <date-range-popup *ngIf="realOpenState" [isRange]="isRange" [showWeek]="showWeek" [panelMode]="nzMode" (panelModeChange)="nzOnPanelChange.emit($event)" [value]="nzValue" (valueChange)="onValueChange($event)" [locale]="nzLocale?.lang" [showToday]="realShowToday" [showTime]="nzShowTime" [format]="nzFormat" [dateRender]="nzDateRender" [disabledDate]="nzDisabledDate" [disabledTime]="nzDisabledTime" [placeholder]="nzPlaceHolder" [dropdownClassName]="nzDropdownClassName" [popupStyle]="nzPopupStyle" [extraFooter]="extraFooter" [ranges]="nzRanges" (resultOk)="onResultOk()" (closePicker)="closeOverlay()" ></date-range-popup> </nz-picker>`,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => NzDatePickerComponent)
                    }],
                host: {
                    '[class.ant-calendar-picker]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMonthPickerComponent extends AbstractPickerComponent {
    /**
     * @param {?} i18n
     */
    constructor(i18n) {
        super(i18n);
        this.nzFormat = 'yyyy-MM';
        this.panelMode = 'month';
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes["nzRenderExtraFooter"]) {
            this.extraFooter = valueFunctionProp(this.nzRenderExtraFooter);
        }
    }
    /**
     * @param {?} mode
     * @return {?}
     */
    onPanelModeChange(mode) {
        if (mode !== 'date') {
            this.panelMode = mode;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onValueChange(value) {
        super.onValueChange(value);
        this.closeOverlay();
    }
    /**
     * @param {?} open
     * @return {?}
     */
    onOpenChange(open) {
        if (!open) {
            this.cleanUp();
        }
        this.nzOnOpenChange.emit(open);
    }
    /**
     * @return {?}
     */
    cleanUp() {
        this.panelMode = 'month';
    }
}
NzMonthPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-month-picker',
                template: `<nz-picker [isRange]="false" [value]="nzValue" (valueChange)="onValueChange($event)" [open]="nzOpen" [disabled]="nzDisabled" [format]="nzFormat" [allowClear]="nzAllowClear" [autoFocus]="nzAutoFocus" [className]="nzClassName" [placeholder]="nzPlaceHolder" [size]="nzSize" [style]="nzStyle" (openChange)="onOpenChange($event)" > <div *ngIf="realOpenState"> <div class="ant-calendar-picker-container {{ nzDropdownClassName }} ant-calendar-picker-container-placement-bottomLeft" [ngStyle]="nzPopupStyle"> <div class="ant-calendar ant-calendar-month ant-calendar-month-calendar" tabindex="0"> <div class="ant-calendar-month-calendar-content"> <div class="ant-calendar-month-header-wrap"> <calendar-header [forceToMonth]="true" [disabledMonth]="nzDisabledDate" [panelMode]="panelMode" (panelModeChange)="onPanelModeChange($event)" [value]="nzValue" (valueChange)="onValueChange($event)" [locale]="nzLocale.lang" [enablePrev]="true" [enableNext]="true" ></calendar-header> </div> <calendar-footer *ngIf="extraFooter" [extraFooter]="extraFooter"></calendar-footer> </div> </div> </div> </div> </nz-picker>`,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => NzMonthPickerComponent)
                    }],
                host: {
                    '[class.ant-checkbox-group]': 'true'
                }
            },] },
];
/** @nocollapse */
NzMonthPickerComponent.ctorParameters = () => [
    { type: NzI18nService }
];
NzMonthPickerComponent.propDecorators = {
    nzPlaceHolder: [{ type: Input }],
    nzRenderExtraFooter: [{ type: Input }],
    nzDefaultValue: [{ type: Input }],
    nzFormat: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzRangePickerComponent extends DateRangePickerComponent {
    constructor() {
        super(...arguments);
        this.isRange = true;
    }
}
NzRangePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-range-picker',
                template: `<nz-picker [isRange]="isRange" [value]="nzValue" (valueChange)="onValueChange($event)" [open]="nzOpen" [disabled]="nzDisabled" [format]="nzFormat" [allowClear]="nzAllowClear" [autoFocus]="nzAutoFocus" [className]="nzClassName" [placeholder]="nzPlaceHolder" [size]="nzSize" [style]="nzStyle" (openChange)="onOpenChange($event)" > <date-range-popup *ngIf="realOpenState" [isRange]="isRange" [showWeek]="showWeek" [panelMode]="nzMode" (panelModeChange)="nzOnPanelChange.emit($event)" [value]="nzValue" (valueChange)="onValueChange($event)" [locale]="nzLocale?.lang" [showToday]="realShowToday" [showTime]="nzShowTime" [format]="nzFormat" [dateRender]="nzDateRender" [disabledDate]="nzDisabledDate" [disabledTime]="nzDisabledTime" [placeholder]="nzPlaceHolder" [dropdownClassName]="nzDropdownClassName" [popupStyle]="nzPopupStyle" [extraFooter]="extraFooter" [ranges]="nzRanges" (resultOk)="onResultOk()" (closePicker)="closeOverlay()" ></date-range-popup> </nz-picker>`,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => NzRangePickerComponent)
                    }],
                host: {
                    '[class.ant-calendar-picker]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzWeekPickerComponent extends DateRangePickerComponent {
    constructor() {
        super(...arguments);
        this.showWeek = true;
    }
}
NzWeekPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-week-picker',
                template: `<nz-picker [isRange]="isRange" [value]="nzValue" (valueChange)="onValueChange($event)" [open]="nzOpen" [disabled]="nzDisabled" [format]="nzFormat" [allowClear]="nzAllowClear" [autoFocus]="nzAutoFocus" [className]="nzClassName" [placeholder]="nzPlaceHolder" [size]="nzSize" [style]="nzStyle" (openChange)="onOpenChange($event)" > <date-range-popup *ngIf="realOpenState" [isRange]="isRange" [showWeek]="showWeek" [panelMode]="nzMode" (panelModeChange)="nzOnPanelChange.emit($event)" [value]="nzValue" (valueChange)="onValueChange($event)" [locale]="nzLocale?.lang" [showToday]="realShowToday" [showTime]="nzShowTime" [format]="nzFormat" [dateRender]="nzDateRender" [disabledDate]="nzDisabledDate" [disabledTime]="nzDisabledTime" [placeholder]="nzPlaceHolder" [dropdownClassName]="nzDropdownClassName" [popupStyle]="nzPopupStyle" [extraFooter]="extraFooter" [ranges]="nzRanges" (resultOk)="onResultOk()" (closePicker)="closeOverlay()" ></date-range-popup> </nz-picker>`,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        multi: true,
                        useExisting: forwardRef(() => NzWeekPickerComponent)
                    }],
                host: {
                    '[class.ant-calendar-picker]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDatePickerModule {
}
NzDatePickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    OverlayModule,
                    LibPackerModule
                ],
                exports: [
                    NzDatePickerComponent,
                    NzRangePickerComponent,
                    NzMonthPickerComponent,
                    NzWeekPickerComponent
                ],
                declarations: [
                    DateRangePickerComponent,
                    NzDatePickerComponent,
                    NzMonthPickerComponent,
                    NzWeekPickerComponent,
                    NzRangePickerComponent,
                    NzPickerComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDividerComponent {
    /**
     * @param {?} el
     * @param {?} cd
     * @param {?} updateHostClassService
     */
    constructor(el, cd, updateHostClassService) {
        this.el = el;
        this.cd = cd;
        this.updateHostClassService = updateHostClassService;
        // region fields
        this.isText = false;
        this.textStr = '';
        this.nzType = 'horizontal';
        this.nzOrientation = '';
        this._dashed = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzText(value) {
        if (value instanceof TemplateRef) {
            this.textStr = null;
            this.textTpl = value;
        }
        else {
            this.textStr = value;
        }
        this.isText = !!value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDashed(value) {
        this._dashed = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDashed() {
        return this._dashed;
    }
    /**
     * @return {?}
     */
    setClass() {
        const /** @type {?} */ orientationPrefix = (this.nzOrientation.length > 0) ? '-' + this.nzOrientation : this.nzOrientation;
        const /** @type {?} */ classMap = {
            ['ant-divider']: true,
            [`ant-divider-${this.nzType}`]: true,
            [`ant-divider-with-text${orientationPrefix}`]: this.isText,
            [`ant-divider-dashed`]: this.nzDashed
        };
        this.updateHostClassService.updateHostClass(this.el.nativeElement, classMap);
        this.cd.detectChanges();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.setClass();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClass();
    }
}
NzDividerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-divider',
                template: `<span *ngIf="isText" class="ant-divider-inner-text"> <ng-container *ngIf="textStr; else textTpl">{{ textStr }}</ng-container> </span>`,
                providers: [NzUpdateHostClassService],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
NzDividerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NzUpdateHostClassService }
];
NzDividerComponent.propDecorators = {
    nzText: [{ type: Input }],
    nzType: [{ type: Input }],
    nzOrientation: [{ type: Input }],
    nzDashed: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDividerModule {
}
NzDividerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NzDividerComponent],
                exports: [NzDividerComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMenuDividerDirective {
}
NzMenuDividerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-menu-divider]',
                host: {
                    '[class.ant-dropdown-menu-item-divider]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMenuGroupComponent {
}
NzMenuGroupComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-menu-group]',
                preserveWhitespaces: false,
                template: `<div class="ant-menu-item-group-title"> <ng-content select="[title]"></ng-content> </div> <ul class="ant-menu-item-group-list"> <ng-content></ng-content> </ul>`,
                host: {
                    '[class.ant-menu-item-group]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMenuDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this._selectable = true;
        this._inlineCollapsed = false;
        this._inDropDown = false;
        /**
         * view init flat
         */
        this.isInit = false;
        /**
         * opened index of array
         */
        this.subMenusOpenIndex = [];
        /**
         * collection of menu item
         */
        this.menuItems = [];
        /**
         * collection of sub menu
         */
        this.subMenus = [];
        this.nzTheme = 'light';
        this.nzInlineIndent = 24;
        this.nzMode = 'vertical';
        this.nzClick = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzInDropDown(value) {
        this._inDropDown = toBoolean(value);
        this.nzSelectable = !this._inDropDown;
        this.menuItems.forEach(menu => menu.isInDropDown = this._inDropDown);
        this.subMenus.forEach(subMenu => subMenu.isInDropDown = this._inDropDown);
    }
    /**
     * @return {?}
     */
    get nzInDropDown() {
        return this._inDropDown;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSelectable(value) {
        this._selectable = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzSelectable() {
        return this._selectable;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzInlineCollapsed(value) {
        this._inlineCollapsed = toBoolean(value);
        if (this.isInit) {
            this.updateInlineCollapse();
        }
    }
    /**
     * @return {?}
     */
    get nzInlineCollapsed() {
        return this._inlineCollapsed;
    }
    /**
     * @return {?}
     */
    updateInlineCollapse() {
        if (this._inlineCollapsed) {
            this.hideSubMenus();
            this.nzMode = 'vertical';
        }
        else {
            this.reductionSubMenus();
            this.nzMode = this.cacheMode;
        }
    }
    /**
     * define host class
     * @return {?}
     */
    get isInDropDownClass() {
        return this.nzInDropDown;
    }
    /**
     * @return {?}
     */
    get isNotInDropDownClass() {
        return !this.nzInDropDown;
    }
    /**
     * @return {?}
     */
    get setDropDownThemeLightClass() {
        return this.nzInDropDown && (this.nzTheme === 'light');
    }
    /**
     * @return {?}
     */
    get setDropDownThemeDarkClass() {
        return this.nzInDropDown && (this.nzTheme === 'dark');
    }
    /**
     * @return {?}
     */
    get setMenuThemeLightClass() {
        return (!this.nzInDropDown) && (this.nzTheme === 'light');
    }
    /**
     * @return {?}
     */
    get setMenuThemeDarkClass() {
        return (!this.nzInDropDown) && (this.nzTheme === 'dark');
    }
    /**
     * @return {?}
     */
    get setMenuVerticalClass() {
        return (!this.nzInDropDown) && (this.nzMode === 'vertical');
    }
    /**
     * @return {?}
     */
    get setMenuHorizontalClass() {
        return (!this.nzInDropDown) && (this.nzMode === 'horizontal');
    }
    /**
     * @return {?}
     */
    get setMenuInlineClass() {
        return (!this.nzInDropDown) && (this.nzMode === 'inline');
    }
    /**
     * @return {?}
     */
    get setMenuInlineCollapsedClass() {
        return (!this.nzInDropDown) && (this.nzMode !== 'horizontal') && this.nzInlineCollapsed;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.isInit = true;
        this.cacheMode = this.nzMode;
        this.updateInlineCollapse();
    }
    /**
     * trigger when menu item clicked
     * @return {?}
     */
    clearAllSelected() {
        this.menuItems.forEach(menu => menu.nzSelected = false);
    }
    /**
     * @return {?}
     */
    hideSubMenus() {
        this.subMenusOpenIndex = [];
        this.subMenus.forEach((submenu, index) => {
            if (submenu.nzOpen) {
                this.subMenusOpenIndex.push(index);
            }
            submenu.nzOpen = false;
        });
    }
    /**
     * @return {?}
     */
    reductionSubMenus() {
        this.subMenusOpenIndex.forEach(i => this.subMenus[i].nzOpen = true);
        this.subMenusOpenIndex = [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    clickItem(value) {
        this.nzClick.emit(value);
    }
}
NzMenuDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-menu]'
            },] },
];
/** @nocollapse */
NzMenuDirective.ctorParameters = () => [
    { type: ElementRef }
];
NzMenuDirective.propDecorators = {
    nzTheme: [{ type: Input }],
    nzInlineIndent: [{ type: Input }],
    nzMode: [{ type: Input }],
    nzClick: [{ type: Output }],
    nzInDropDown: [{ type: Input }],
    nzSelectable: [{ type: Input }],
    nzInlineCollapsed: [{ type: Input }],
    isInDropDownClass: [{ type: HostBinding, args: ['class.ant-dropdown-menu',] }, { type: HostBinding, args: ['class.ant-menu-dropdown-vertical',] }, { type: HostBinding, args: ['class.ant-dropdown-menu-root',] }],
    isNotInDropDownClass: [{ type: HostBinding, args: ['class.ant-menu',] }, { type: HostBinding, args: ['class.ant-menu-root',] }],
    setDropDownThemeLightClass: [{ type: HostBinding, args: ['class.ant-dropdown-menu-light',] }],
    setDropDownThemeDarkClass: [{ type: HostBinding, args: ['class.ant-dropdown-menu-dark',] }],
    setMenuThemeLightClass: [{ type: HostBinding, args: ['class.ant-menu-light',] }],
    setMenuThemeDarkClass: [{ type: HostBinding, args: ['class.ant-menu-dark',] }],
    setMenuVerticalClass: [{ type: HostBinding, args: ['class.ant-menu-vertical',] }],
    setMenuHorizontalClass: [{ type: HostBinding, args: ['class.ant-menu-horizontal',] }],
    setMenuInlineClass: [{ type: HostBinding, args: ['class.ant-menu-inline',] }],
    setMenuInlineCollapsedClass: [{ type: HostBinding, args: ['class.ant-menu-inline-collapsed',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDropDownDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.$mouseenter = new Subject();
        this.$mouseleave = new Subject();
        this.$click = new Subject();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseEnter(e) {
        this.$mouseenter.next(e);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseLeave(e) {
        this.$mouseleave.next(e);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        this.$click.next(e);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.elementRef.nativeElement.nodeName === 'A') {
            this.renderer.addClass(this.elementRef.nativeElement, 'ant-dropdown-link');
        }
    }
}
NzDropDownDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-dropdown]',
                host: {
                    '[class.ant-dropdown-trigger]': 'true'
                }
            },] },
];
/** @nocollapse */
NzDropDownDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NzDropDownDirective.propDecorators = {
    onMouseEnter: [{ type: HostListener, args: ['mouseenter', ['$event'],] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDropDownComponent {
    /**
     * @param {?} renderer
     * @param {?} changeDetector
     */
    constructor(renderer, changeDetector) {
        this.renderer = renderer;
        this.changeDetector = changeDetector;
        this._clickHide = true;
        this._visible = false;
        this._disabled = false;
        this.unsubscribe$ = new Subject();
        this.hasFilterButton = false;
        this.triggerWidth = 0;
        this.placement = 'bottomLeft';
        this.dropDownPosition = 'bottom';
        this.positions = [...DEFAULT_DROPDOWN_POSITIONS];
        this.$subOpen = new BehaviorSubject(false);
        this.$visibleChange = new Subject();
        this.nzTrigger = 'hover';
        this.nzVisibleChange = new EventEmitter();
        this.onVisibleChange = (visible) => {
            if (visible) {
                this.setTriggerWidth();
            }
            if (this.nzVisible !== visible) {
                this.nzVisible = visible;
                this.nzVisibleChange.emit(this.nzVisible);
            }
            this.changeDetector.markForCheck();
        };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzClickHide(value) {
        this._clickHide = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzClickHide() {
        return this._clickHide;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
        if (this._disabled) {
            this.renderer.setAttribute(this.nzOrigin.elementRef.nativeElement, 'disabled', '');
        }
        else {
            this.renderer.removeAttribute(this.nzOrigin.elementRef.nativeElement, 'disabled');
        }
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzVisible(value) {
        this._visible = toBoolean(value);
        /** handle nzVisible change with mouse event **/
        this.$visibleChange.next(this._visible);
    }
    /**
     * @return {?}
     */
    get nzVisible() {
        return this._visible;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPlacement(value) {
        this.placement = value;
        this.dropDownPosition = (this.nzPlacement.indexOf('top') !== -1) ? 'top' : 'bottom';
        this.positions.unshift(/** @type {?} */ (POSITION_MAP[this.placement]));
    }
    /**
     * @return {?}
     */
    get nzPlacement() {
        return this.placement;
    }
    /**
     * @return {?}
     */
    onClickEvent() {
        if (this.nzTrigger === 'click') {
            this.show();
        }
    }
    /**
     * @return {?}
     */
    onMouseEnterEvent() {
        if (this.nzTrigger === 'hover') {
            this.show();
        }
    }
    /**
     * @return {?}
     */
    onMouseLeaveEvent() {
        if (this.nzTrigger === 'hover') {
            this.hide();
        }
    }
    /**
     * @return {?}
     */
    hide() {
        this.$visibleChange.next(false);
    }
    /**
     * @return {?}
     */
    show() {
        this.$visibleChange.next(true);
    }
    /**
     * @param {?} position
     * @return {?}
     */
    onPositionChange(position) {
        this.dropDownPosition = position.connectionPair.originY;
    }
    /**
     * @return {?}
     */
    setTriggerWidth() {
        this.triggerWidth = this.nzOrigin.elementRef.nativeElement.getBoundingClientRect().width;
        /** should remove after https://github.com/angular/material2/pull/8765 merged **/
        if (this.cdkOverlay && this.cdkOverlay.overlayRef) {
            this.cdkOverlay.overlayRef.updateSize({
                minWidth: this.triggerWidth
            });
        }
    }
    /**
     * @param {?} observable$
     * @return {?}
     */
    startSubscribe(observable$) {
        let /** @type {?} */ $pre = observable$;
        if (this.nzClickHide && this.nzMenu) {
            const /** @type {?} */ $menuItemClick = this.nzMenu.nzClick.asObservable().pipe(mapTo(false));
            $pre = merge($pre, $menuItemClick);
        }
        const /** @type {?} */ final$ = combineLatest($pre, this.$subOpen).pipe(map(value => value[0] || value[1]), debounceTime(50), distinctUntilChanged());
        final$.pipe(takeUntil(this.unsubscribe$)).subscribe(this.onVisibleChange);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.nzMenu) {
            this.nzMenu.nzInDropDown = true;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        let /** @type {?} */ mouse$;
        if (this.nzTrigger === 'hover') {
            const /** @type {?} */ mouseEnterOrigin$ = this.nzOrigin.$mouseenter.pipe(mapTo(true));
            const /** @type {?} */ mouseLeaveOrigin$ = this.nzOrigin.$mouseleave.pipe(mapTo(false));
            mouse$ = merge(mouseLeaveOrigin$, mouseEnterOrigin$);
        }
        if (this.nzTrigger === 'click') {
            mouse$ = this.nzOrigin.$click.pipe(mapTo(true));
        }
        const /** @type {?} */ observable$ = merge(this.$visibleChange, mouse$);
        this.startSubscribe(observable$);
    }
    /**
     * @return {?}
     */
    get hasBackdrop() {
        return this.nzTrigger === 'click';
    }
}
NzDropDownComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-dropdown',
                preserveWhitespaces: false,
                animations: [
                    dropDownAnimation
                ],
                template: `<div> <ng-content select="[nz-dropdown]"></ng-content> </div> <ng-template cdkConnectedOverlay [cdkConnectedOverlayHasBackdrop]="hasBackdrop" [cdkConnectedOverlayPositions]="positions" [cdkConnectedOverlayOrigin]="nzOrigin" (backdropClick)="hide()" (detach)="hide()" [cdkConnectedOverlayMinWidth]="triggerWidth" (positionChange)="onPositionChange($event)" [cdkConnectedOverlayOpen]="nzVisible"> <div class="{{'ant-dropdown ant-dropdown-placement-'+nzPlacement}}" [@dropDownAnimation]="dropDownPosition" (mouseenter)="onMouseEnterEvent()" (mouseleave)="onMouseLeaveEvent()" [style.minWidth.px]="triggerWidth"> <div [class.ant-table-filter-dropdown]="hasFilterButton"> <ng-content select="[nz-menu]"></ng-content> <ng-content select=".ant-table-filter-dropdown-btns"></ng-content> </div> <ng-content></ng-content> </div> </ng-template>`,
                styles: [
                    `
      :host {
        position: relative;
        display: inline-block;
      }

      .ant-dropdown {
        top: 100%;
        left: 0;
        position: relative;
        width: 100%;
        margin-top: 4px;
        margin-bottom: 4px;
      }
    `
                ]
            },] },
];
/** @nocollapse */
NzDropDownComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
NzDropDownComponent.propDecorators = {
    hasFilterButton: [{ type: Input }],
    nzOrigin: [{ type: ContentChild, args: [NzDropDownDirective,] }],
    nzMenu: [{ type: ContentChild, args: [NzMenuDirective,] }],
    nzTrigger: [{ type: Input }],
    nzVisibleChange: [{ type: Output }],
    cdkOverlay: [{ type: ViewChild, args: [CdkConnectedOverlay,] }],
    nzClickHide: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzVisible: [{ type: Input }],
    nzPlacement: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDropDownButtonComponent extends NzDropDownComponent {
    constructor() {
        super(...arguments);
        this.nzSize = 'default';
        this.nzType = 'default';
        this.nzClick = new EventEmitter();
        this.onVisibleChange = (visible) => {
            if (this.nzDisabled) {
                return;
            }
            if (visible) {
                this.setTriggerWidth();
            }
            if (this.nzVisible !== visible) {
                this.nzVisible = visible;
                this.nzVisibleChange.emit(this.nzVisible);
            }
            this.changeDetector.markForCheck();
        };
    }
    /**
     * rewrite afterViewInit hook
     * @return {?}
     */
    ngAfterViewInit() {
        this.startSubscribe(this.$visibleChange);
    }
}
NzDropDownButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-dropdown-button',
                preserveWhitespaces: false,
                animations: [
                    dropDownAnimation
                ],
                template: `<div class="ant-btn-group ant-dropdown-button" nz-dropdown> <button type="button" nz-button [disabled]="nzDisabled" [nzType]="nzType" [nzSize]="nzSize" (click)="nzClick.emit($event)"> <span><ng-content></ng-content></span> </button> <button nz-button type="button" class="ant-dropdown-trigger" [nzType]="nzType" [nzSize]="nzSize" [disabled]="nzDisabled" (click)="onClickEvent()" (mouseenter)="onMouseEnterEvent()" (mouseleave)="onMouseLeaveEvent()"> <i class="anticon anticon-ellipsis"></i> </button> </div> <ng-template cdkConnectedOverlay [cdkConnectedOverlayHasBackdrop]="hasBackdrop" [cdkConnectedOverlayPositions]="positions" [cdkConnectedOverlayOrigin]="nzOrigin" (backdropClick)="hide()" (detach)="hide()" [cdkConnectedOverlayMinWidth]="triggerWidth" (positionChange)="onPositionChange($event)" [cdkConnectedOverlayOpen]="nzVisible"> <div class="{{'ant-dropdown ant-dropdown-placement-'+nzPlacement}}" [@dropDownAnimation]="dropDownPosition" (mouseenter)="onMouseEnterEvent()" (mouseleave)="onMouseLeaveEvent()" [style.minWidth.px]="triggerWidth"> <ng-content select="[nz-menu]"></ng-content> </div> </ng-template>`,
                styles: [`
    :host {
      position: relative;
      display: inline-block;
    }

    .ant-dropdown {
      top: 100%;
      left: 0;
      position: relative;
      width: 100%;
      margin-top: 4px;
      margin-bottom: 4px;
    }
  `]
            },] },
];
NzDropDownButtonComponent.propDecorators = {
    nzSize: [{ type: Input }],
    nzType: [{ type: Input }],
    content: [{ type: ViewChild, args: ['content',] }],
    nzClick: [{ type: Output }],
    nzOrigin: [{ type: ViewChild, args: [NzDropDownDirective,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSubMenuComponent {
    /**
     * @param {?} nzMenuDirective
     * @param {?} cd
     * @param {?} nzSubMenuComponent
     * @param {?} nzDropDownComponent
     * @param {?} nzDropDownButtonComponent
     */
    constructor(nzMenuDirective, cd, nzSubMenuComponent, nzDropDownComponent, nzDropDownButtonComponent) {
        this.nzMenuDirective = nzMenuDirective;
        this.cd = cd;
        this.nzSubMenuComponent = nzSubMenuComponent;
        this.nzDropDownComponent = nzDropDownComponent;
        this.nzDropDownButtonComponent = nzDropDownButtonComponent;
        this._open = false;
        this._disabled = false;
        this.$mouseSubject = new Subject();
        this.unsubscribe$ = new Subject();
        this.placement = 'rightTop';
        this.$subOpen = new BehaviorSubject(false);
        this.isInDropDown = false;
        this.isInSubMenu = false;
        this.level = 1;
        this.triggerWidth = null;
        this.nzOpenChange = new EventEmitter();
        this.handleOpenEvent = (data) => {
            if (this.nzDisabled) {
                return;
            }
            if (this.nzOpen !== data) {
                this.nzOpen = data;
                this.nzOpenChange.emit(this.nzOpen);
            }
            if (this.nzSubMenuComponent) {
                this.nzSubMenuComponent.$subOpen.next(this.nzOpen);
            }
            if (this.nzDropDownComponent) {
                this.nzDropDownComponent.$subOpen.next(this.nzOpen);
            }
            if (this.nzDropDownButtonComponent) {
                this.nzDropDownButtonComponent.$subOpen.next(this.nzOpen);
            }
        };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzOpen(value) {
        this._open = toBoolean(value);
        this.setTriggerWidth();
    }
    /**
     * @return {?}
     */
    get nzOpen() {
        return this._open;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @return {?}
     */
    get subItemSelected() {
        return !!this.nzMenuDirective.menuItems.find(e => e.nzSelected && e.nzSubMenuComponent === this);
    }
    /**
     * @return {?}
     */
    get submenuSelected() {
        return !!this.subMenus.toArray().find(e => e !== this && e.subItemSelected);
    }
    /**
     * @return {?}
     */
    get expandState() {
        if (this.nzOpen && this.subMenuMode === 'inline') {
            return 'expand';
        }
        else if (this.nzOpen && this.subMenuMode === 'horizontal') {
            return 'bottom';
        }
        else if (this.nzOpen && this.subMenuMode === 'vertical') {
            return 'fade';
        }
        else {
            return 'hidden';
        }
    }
    /**
     * @return {?}
     */
    get overlayPositions() {
        if (this.subMenuMode === 'horizontal') {
            return [POSITION_MAP["bottomLeft"]];
        }
        else {
            return [POSITION_MAP["rightTop"], POSITION_MAP["leftTop"]];
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    clickSubMenuTitle($event) {
        if (this.nzDisabled) {
            $event.preventDefault();
            $event.stopPropagation();
            return;
        }
        if ((this.subMenuMode === 'inline') && (!this.isInDropDown)) {
            this.nzOpen = !this.nzOpen;
            this.nzOpenChange.emit(this.nzOpen);
        }
    }
    /**
     * @return {?}
     */
    clickSubMenuDropDown() {
        if (this.isInDropDown || (this.subMenuMode === 'vertical') || (this.subMenuMode === 'horizontal')) {
            this.$mouseSubject.next(false);
        }
    }
    /**
     * @return {?}
     */
    get subMenuMode() {
        if (this.nzMenuDirective.nzMode === 'inline') {
            return 'inline';
        }
        else if ((this.nzMenuDirective.nzMode === 'vertical') || (this.isInSubMenu)) {
            return 'vertical';
        }
        else {
            return 'horizontal';
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseEnterEvent(e) {
        if ((this.subMenuMode === 'horizontal') || (this.subMenuMode === 'vertical') || this.isInDropDown) {
            this.$mouseSubject.next(true);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onMouseLeaveEvent(e) {
        if ((this.subMenuMode === 'horizontal') || (this.subMenuMode === 'vertical') || this.isInDropDown) {
            this.$mouseSubject.next(false);
        }
    }
    /**
     * @return {?}
     */
    get setDropDownSubmenuClass() {
        return this.isInDropDown;
    }
    /**
     * @return {?}
     */
    get setMenuSubmenuOpenClass() {
        return (!this.isInDropDown) && (this.nzOpen);
    }
    /**
     * @return {?}
     */
    get setDropDownVerticalClass() {
        return this.isInDropDown && (this.subMenuMode === 'vertical');
    }
    /**
     * @return {?}
     */
    get setDropDownHorizontalClass() {
        return this.isInDropDown && (this.subMenuMode === 'horizontal');
    }
    /**
     * @return {?}
     */
    get setDropDownDisabled() {
        return this.isInDropDown && this.nzDisabled;
    }
    /**
     * @return {?}
     */
    get setMenuSubmenuClass() {
        return !this.isInDropDown;
    }
    /**
     * @return {?}
     */
    get setMenuSubmenuSelectedClass() {
        return this.submenuSelected || this.subItemSelected;
    }
    /**
     * @return {?}
     */
    get setMenuVerticalClass() {
        return (!this.isInDropDown) && (this.subMenuMode === 'vertical');
    }
    /**
     * @return {?}
     */
    get setMenuHorizontalClass() {
        return (!this.isInDropDown) && (this.subMenuMode === 'horizontal');
    }
    /**
     * @return {?}
     */
    get setMenuInlineClass() {
        return (!this.isInDropDown) && (this.subMenuMode === 'inline');
    }
    /**
     * @return {?}
     */
    get setMenuDisabled() {
        return (!this.isInDropDown) && this.nzDisabled;
    }
    /**
     * @return {?}
     */
    setTriggerWidth() {
        if (this.subMenuMode === 'horizontal') {
            this.triggerWidth = this.trigger.nativeElement.getBoundingClientRect().width;
            /** should remove after after https://github.com/angular/material2/pull/8765 merged **/
            if (this.cdkOverlay && this.cdkOverlay.overlayRef) {
                this.cdkOverlay.overlayRef.updateSize({
                    width: this.triggerWidth
                });
            }
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onPositionChange($event) {
        if ($event.connectionPair) {
            const /** @type {?} */ originMap = {
                originX: $event.connectionPair.originX,
                originY: $event.connectionPair.originY,
                overlayX: $event.connectionPair.overlayX,
                overlayY: $event.connectionPair.overlayY
            };
            const /** @type {?} */ keyList = ['originX', 'originY', 'overlayX', 'overlayY'];
            if (keyList.every(key => originMap[key] === POSITION_MAP["leftTop"][key])) {
                this.placement = 'leftTop';
            }
            else if (keyList.every(key => originMap[key] === POSITION_MAP["rightTop"][key])) {
                this.placement = 'rightTop';
            }
            this.cd.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.nzMenuDirective.subMenus.push(this);
        const /** @type {?} */ $combineAll = combineLatest(this.$subOpen, this.$mouseSubject.asObservable()).pipe(map(value => value[0] || value[1]), auditTime(150));
        $combineAll.pipe(takeUntil(this.unsubscribe$)).subscribe(this.handleOpenEvent);
        this.isInDropDown = this.nzMenuDirective.nzInDropDown;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.subMenus && this.subMenus.length) {
            this.subMenus.filter(x => x !== this).forEach(menu => {
                if (this.subMenuMode === 'inline') {
                    Promise.resolve().then(() => menu.level = this.level + 1);
                }
                menu.isInSubMenu = true;
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
}
NzSubMenuComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-submenu]',
                preserveWhitespaces: false,
                animations: [
                    trigger('expandAnimation', [
                        state('expand', style({ height: '*' })),
                        state('hidden', style({ height: 0, overflow: 'hidden' })),
                        transition('expand => hidden', animate(150)),
                        transition('hidden => expand', animate(150)),
                        state('fade', style({ opacity: 1 })),
                        transition('fade => void', [
                            animate(150, style({ opacity: 0 }))
                        ]),
                        transition('void => fade', [
                            style({ opacity: '0' }),
                            animate(150)
                        ]),
                        state('bottom', style({
                            opacity: 1,
                            transform: 'scaleY(1)',
                            transformOrigin: '0% 0%'
                        })),
                        transition('void => bottom', [
                            style({
                                opacity: 0,
                                transform: 'scaleY(0.8)',
                                transformOrigin: '0% 0%'
                            }),
                            animate('150ms cubic-bezier(0.23, 1, 0.32, 1)')
                        ]),
                        transition('bottom => void', [
                            animate('150ms cubic-bezier(0.23, 1, 0.32, 1)', style({
                                opacity: 0,
                                transform: 'scaleY(0.8)',
                                transformOrigin: '0% 0%'
                            }))
                        ])
                    ])
                ],
                template: `<div #trigger cdkOverlayOrigin #origin="cdkOverlayOrigin" [class.ant-dropdown-menu-submenu-title]="isInDropDown" [class.ant-menu-submenu-title]="!isInDropDown" (mouseenter)="onMouseEnterEvent($event)" (mouseleave)="onMouseLeaveEvent($event)" (click)="clickSubMenuTitle($event)" [style.paddingLeft.px]="(nzMenuDirective.nzMode === 'inline')?(level*nzMenuDirective.nzInlineIndent):null"> <ng-content select="[title]"></ng-content> <i [class.ant-dropdown-menu-submenu-arrow]="isInDropDown" [class.ant-menu-submenu-arrow]="!isInDropDown"></i> </div> <ul [class.ant-dropdown-menu]="isInDropDown" [@expandAnimation]="expandState" [class.ant-menu]="!isInDropDown" [class.ant-dropdown-menu-vertical]="isInDropDown" [class.ant-menu-inline]="!isInDropDown" [class.ant-dropdown-menu-sub]="isInDropDown" [class.ant-menu-sub]="!isInDropDown" (mouseleave)="onMouseLeaveEvent($event)" (mouseenter)="onMouseEnterEvent($event)" *ngIf="(nzMenuDirective.nzMode=='inline')"> <ng-template [ngTemplateOutlet]="subMenuTemplate"></ng-template> </ul> <ng-template cdkConnectedOverlay [cdkConnectedOverlayPositions]="overlayPositions" [cdkConnectedOverlayOrigin]="origin" [cdkConnectedOverlayWidth]="triggerWidth" (positionChange)="onPositionChange($event)" [cdkConnectedOverlayOpen]="nzOpen&&(nzMenuDirective.nzMode!='inline')"> <div class="ant-menu-submenu ant-menu-submenu-popup" [class.ant-menu-light]="nzMenuDirective.nzTheme=='light'" [class.ant-menu-dark]="nzMenuDirective.nzTheme=='dark'" [class.ant-menu-submenu-placement-bottomLeft]="subMenuMode=='horizontal'" [class.ant-menu-submenu-placement-rightTop]="(subMenuMode=='vertical')&&(placement=='rightTop')" [class.ant-menu-submenu-placement-leftTop]="(subMenuMode=='vertical')&&(placement=='leftTop')" [@expandAnimation]="expandState"> <ul [class.ant-dropdown-menu]="isInDropDown" [class.ant-menu]="!isInDropDown" [class.ant-dropdown-menu-vertical]="isInDropDown" [class.ant-menu-vertical]="!isInDropDown" [class.ant-dropdown-menu-sub]="isInDropDown" [class.ant-menu-sub]="!isInDropDown" (mouseleave)="onMouseLeaveEvent($event)" (mouseenter)="onMouseEnterEvent($event)"> <ng-template [ngTemplateOutlet]="subMenuTemplate"></ng-template> </ul> </div> </ng-template> <ng-template #subMenuTemplate> <ng-content></ng-content> </ng-template>`,
                styles: [
                    `
      .ant-menu-submenu-placement-bottomLeft {
        top: 6px;
        position: relative;
      }

      .ant-menu-submenu-placement-rightTop {
        left: 4px;
        position: relative;
      }

      .ant-menu-submenu-placement-leftTop {
        right: 4px;
        position: relative;
      }
    `
                ]
            },] },
];
/** @nocollapse */
NzSubMenuComponent.ctorParameters = () => [
    { type: NzMenuDirective },
    { type: ChangeDetectorRef },
    { type: NzSubMenuComponent, decorators: [{ type: SkipSelf }, { type: Optional }] },
    { type: NzDropDownComponent, decorators: [{ type: Host }, { type: Optional }] },
    { type: NzDropDownButtonComponent, decorators: [{ type: Host }, { type: Optional }] }
];
NzSubMenuComponent.propDecorators = {
    subMenus: [{ type: ContentChildren, args: [NzSubMenuComponent, { descendants: true },] }],
    nzOpenChange: [{ type: Output }],
    cdkOverlay: [{ type: ViewChild, args: [CdkConnectedOverlay,] }],
    trigger: [{ type: ViewChild, args: ['trigger',] }],
    nzOpen: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    setDropDownSubmenuClass: [{ type: HostBinding, args: ['class.ant-dropdown-menu-submenu',] }],
    setMenuSubmenuOpenClass: [{ type: HostBinding, args: ['class.ant-menu-submenu-open',] }],
    setDropDownVerticalClass: [{ type: HostBinding, args: ['class.ant-dropdown-menu-submenu-vertical',] }],
    setDropDownHorizontalClass: [{ type: HostBinding, args: ['class.ant-dropdown-menu-submenu-horizontal',] }],
    setDropDownDisabled: [{ type: HostBinding, args: ['class.ant-dropdown-menu-submenu-disabled',] }],
    setMenuSubmenuClass: [{ type: HostBinding, args: ['class.ant-menu-submenu',] }],
    setMenuSubmenuSelectedClass: [{ type: HostBinding, args: ['class.ant-menu-submenu-selected',] }],
    setMenuVerticalClass: [{ type: HostBinding, args: ['class.ant-menu-submenu-vertical',] }],
    setMenuHorizontalClass: [{ type: HostBinding, args: ['class.ant-menu-submenu-horizontal',] }],
    setMenuInlineClass: [{ type: HostBinding, args: ['class.ant-menu-submenu-inline',] }],
    setMenuDisabled: [{ type: HostBinding, args: ['class.ant-menu-submenu-disabled',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMenuItemDirective {
    /**
     * @param {?} renderer
     * @param {?} cd
     * @param {?} nzMenuDirective
     * @param {?} nzSubMenuComponent
     * @param {?} hostElement
     */
    constructor(renderer, cd, nzMenuDirective, nzSubMenuComponent, hostElement) {
        this.renderer = renderer;
        this.cd = cd;
        this.nzMenuDirective = nzMenuDirective;
        this.nzSubMenuComponent = nzSubMenuComponent;
        this.hostElement = hostElement;
        this._disabled = false;
        this._selected = false;
        this.level = 0;
        this.padding = null;
        this.isInDropDown = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSelected(value) {
        this._selected = toBoolean(value);
        if (this._selected) {
            this.renderer.addClass(this.hostElement.nativeElement, this.isInDropDown ? 'ant-dropdown-menu-item-selected' : 'ant-menu-item-selected');
        }
        else {
            this.renderer.removeClass(this.hostElement.nativeElement, this.isInDropDown ? 'ant-dropdown-menu-item-selected' : 'ant-menu-item-selected');
        }
    }
    /**
     * @return {?}
     */
    get nzSelected() {
        return this._selected;
    }
    /**
     * clear all item selected status except this
     * @param {?} e
     * @return {?}
     */
    onClickItem(e) {
        if (this.nzDisabled) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        this.nzMenuDirective.clickItem(this);
        if (this.nzMenuDirective.nzSelectable) {
            this.nzMenuDirective.clearAllSelected();
            this.nzSelected = true;
        }
        if (this.nzSubMenuComponent) {
            this.nzSubMenuComponent.clickSubMenuDropDown();
        }
    }
    /**
     * define host class
     * @return {?}
     */
    get isInDropDownClass() {
        return this.isInDropDown;
    }
    /**
     * @return {?}
     */
    get isNotInDropDownClass() {
        return !this.isInDropDown;
    }
    /**
     * @return {?}
     */
    get setDropDownDisableClass() {
        return this.isInDropDown && this.nzDisabled;
    }
    /**
     * @return {?}
     */
    get setMenuDisableClass() {
        return (!this.isInDropDown) && this.nzDisabled;
    }
    /**
     * @return {?}
     */
    get setPaddingLeft() {
        if (this.nzMenuDirective.nzMode === 'inline') {
            if (this.nzSubMenuComponent) {
                /** if in sub menu component and host menu's mode is inline add PADDING_BASE * level padding */
                return (this.nzSubMenuComponent.level + 1) * this.nzMenuDirective.nzInlineIndent;
            }
            else {
                /** not in sub menu component but root menu's mode is inline return default padding */
                return this.nzMenuDirective.nzInlineIndent;
            }
        }
        else {
            return this.padding;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.nzMenuDirective.menuItems.push(this);
        /** store origin padding in padding */
        if (this.hostElement.nativeElement.style['padding-left']) {
            this.padding = parseInt(this.hostElement.nativeElement.style['padding-left'], 10);
        }
        this.isInDropDown = this.nzMenuDirective.nzInDropDown;
    }
}
NzMenuItemDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-menu-item]'
            },] },
];
/** @nocollapse */
NzMenuItemDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: NzMenuDirective },
    { type: NzSubMenuComponent, decorators: [{ type: Optional }] },
    { type: ElementRef }
];
NzMenuItemDirective.propDecorators = {
    nzDisabled: [{ type: Input }],
    nzSelected: [{ type: Input }],
    onClickItem: [{ type: HostListener, args: ['click', ['$event'],] }],
    isInDropDownClass: [{ type: HostBinding, args: ['class.ant-dropdown-menu-item',] }],
    isNotInDropDownClass: [{ type: HostBinding, args: ['class.ant-menu-item',] }],
    setDropDownDisableClass: [{ type: HostBinding, args: ['class.ant-dropdown-menu-item-disabled',] }],
    setMenuDisableClass: [{ type: HostBinding, args: ['class.ant-menu-item-disabled',] }],
    setPaddingLeft: [{ type: HostBinding, args: ['style.padding-left.px',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMenuModule {
}
NzMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, NzButtonModule, OverlayModule],
                declarations: [NzMenuDirective, NzMenuItemDirective, NzSubMenuComponent, NzMenuDividerDirective, NzMenuGroupComponent],
                exports: [NzMenuDirective, NzMenuItemDirective, NzSubMenuComponent, NzMenuDividerDirective, NzMenuGroupComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDropdownContextComponent {
    constructor() {
        this.dropDownPosition = 'bottom';
        this.open = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setTemplateRef(value) {
        this.template = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setControl(value) {
        this.control = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setDropDownPosition(value) {
        this.dropDownPosition = value;
    }
    /**
     * @return {?}
     */
    close() {
        this.open = false;
    }
    /**
     * @return {?}
     */
    afterAnimation() {
        if (!this.open) {
            this.control.close();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // TODO auto set dropdown class after the bug resolved
        /** https://github.com/angular/angular/issues/14842 **/
    }
}
NzDropdownContextComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-dropdown-context',
                animations: [
                    dropDownAnimation
                ],
                template: `<div class="ant-dropdown ant-dropdown-placement-bottomLeft" [@dropDownAnimation]="dropDownPosition" (@dropDownAnimation.done)="afterAnimation()" *ngIf="open"> <ng-template [ngTemplateOutlet]="template"></ng-template> </div>`,
                styles: [
                    `
      .ant-dropdown {
        top: 100%;
        left: 0;
        position: relative;
        width: 100%;
        margin-top: 4px;
        margin-bottom: 4px;
      }
    `
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDropDownModule {
}
NzDropDownModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule, FormsModule, NzButtonModule, NzMenuModule],
                declarations: [NzDropDownComponent, NzDropDownButtonComponent, NzDropDownDirective, NzDropdownContextComponent],
                entryComponents: [NzDropdownContextComponent],
                exports: [NzDropDownComponent, NzDropDownButtonComponent, NzDropDownDirective]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function matchMediaFunc() {
    if (typeof window === 'undefined') {
        return () => null;
    }
    if (window.matchMedia) {
        return window.matchMedia.bind(window);
    }
    else {
        const /** @type {?} */ matchMediaPolyfill = (mediaQuery) => {
            return {
                media: mediaQuery,
                matches: false,
                /**
                 * @return {?}
                 */
                addListener() {
                },
                /**
                 * @return {?}
                 */
                removeListener() {
                },
            };
        };
        return matchMediaPolyfill;
    }
}
const matchMedia = matchMediaFunc();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

const responsiveMap = {
    xs: '(max-width: 575px)',
    sm: '(min-width: 576px)',
    md: '(min-width: 768px)',
    lg: '(min-width: 992px)',
    xl: '(min-width: 1200px)',
    xxl: '(min-width: 1600px)'
};
class NzRowComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} nzUpdateHostClassService
     */
    constructor(elementRef, renderer, nzUpdateHostClassService) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.nzUpdateHostClassService = nzUpdateHostClassService;
        this._align = 'top';
        this._justify = 'start';
        this.prefixCls = 'ant-row';
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzType(value) {
        this._type = value;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzType() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAlign(value) {
        this._align = value;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzAlign() {
        return this._align;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzJustify(value) {
        this._justify = value;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzJustify() {
        return this._justify;
    }
    /**
     * @return {?}
     */
    get nzGutter() {
        return this._gutter;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzGutter(value) {
        this._gutter = value;
        this.updateGutter();
        this.setStyle();
    }
    /**
     * @return {?}
     */
    setStyle() {
        this.renderer.setStyle(this.el, 'margin-left', `-${this.actualGutter / 2}px`);
        this.renderer.setStyle(this.el, 'margin-right', `-${this.actualGutter / 2}px`);
    }
    /**
     * @return {?}
     */
    calculateGutter() {
        if (typeof this.nzGutter !== 'object') {
            return this.nzGutter;
        }
        else if (this.breakPoint && this.nzGutter[this.breakPoint]) {
            return this.nzGutter[this.breakPoint];
        }
        else {
            return;
        }
    }
    /**
     * @return {?}
     */
    updateGutter() {
        this.actualGutter = this.calculateGutter();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onWindowResize(e) {
        this.watchMedia();
    }
    /**
     * @return {?}
     */
    watchMedia() {
        Object.keys(responsiveMap).map((screen) => {
            const /** @type {?} */ matchBelow = matchMedia(responsiveMap[screen]).matches;
            if (matchBelow) {
                this.breakPoint = screen;
            }
        });
        this.updateGutter();
        this.setStyle();
    }
    /**
     * temp solution since no method add classMap to host https://github.com/angular/angular/issues/7289
     * @return {?}
     */
    setClassMap() {
        const /** @type {?} */ classMap = {
            [`${this.prefixCls}`]: !this.nzType,
            [`${this.prefixCls}-${this.nzType}`]: this.nzType,
            [`${this.prefixCls}-${this.nzType}-${this.nzAlign}`]: this.nzType && this.nzAlign,
            [`${this.prefixCls}-${this.nzType}-${this.nzJustify}`]: this.nzType && this.nzJustify
        };
        this.nzUpdateHostClassService.updateHostClass(this.el, classMap);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
        this.watchMedia();
    }
}
NzRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-row',
                preserveWhitespaces: false,
                providers: [NzUpdateHostClassService],
                template: `<ng-content></ng-content>`
            },] },
];
/** @nocollapse */
NzRowComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NzUpdateHostClassService }
];
NzRowComponent.propDecorators = {
    nzType: [{ type: Input }],
    nzAlign: [{ type: Input }],
    nzJustify: [{ type: Input }],
    nzGutter: [{ type: Input }],
    onWindowResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzRowDirective extends NzRowComponent {
}
NzRowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-row]',
                providers: [NzUpdateHostClassService]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class NzColComponent {
    /**
     * @param {?} nzUpdateHostClassService
     * @param {?} elementRef
     * @param {?} nzRowComponent
     * @param {?} nzRowDirective
     * @param {?} renderer
     */
    constructor(nzUpdateHostClassService, elementRef, nzRowComponent, nzRowDirective, renderer) {
        this.nzUpdateHostClassService = nzUpdateHostClassService;
        this.elementRef = elementRef;
        this.nzRowComponent = nzRowComponent;
        this.nzRowDirective = nzRowDirective;
        this.renderer = renderer;
        this.prefixCls = 'ant-col';
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    get paddingLeft() {
        return this.nzRow && this.nzRow.actualGutter / 2;
    }
    /**
     * @return {?}
     */
    get paddingRight() {
        return this.nzRow && this.nzRow.actualGutter / 2;
    }
    /**
     * temp solution since no method add classMap to host https://github.com/angular/angular/issues/7289
     * @return {?}
     */
    setClassMap() {
        const /** @type {?} */ classMap = Object.assign({ [`${this.prefixCls}-${this.nzSpan}`]: isNotNil(this.nzSpan), [`${this.prefixCls}-order-${this.nzOrder}`]: isNotNil(this.nzOrder), [`${this.prefixCls}-offset-${this.nzOffset}`]: isNotNil(this.nzOffset), [`${this.prefixCls}-pull-${this.nzPull}`]: isNotNil(this.nzPull), [`${this.prefixCls}-push-${this.nzPush}`]: isNotNil(this.nzPush) }, this.generateClass());
        this.nzUpdateHostClassService.updateHostClass(this.el, classMap);
    }
    /**
     * @return {?}
     */
    generateClass() {
        const /** @type {?} */ listOfSizeInputName = ['nzXs', 'nzSm', 'nzMd', 'nzLg', 'nzXl', 'nzXXl'];
        const /** @type {?} */ listClassMap = {};
        listOfSizeInputName.forEach(name => {
            const /** @type {?} */ sizeName = name.replace('nz', '').toLowerCase();
            if (isNotNil(this[name])) {
                if ((typeof (this[name]) === 'number') || (typeof (this[name]) === 'string')) {
                    listClassMap[`${this.prefixCls}-${sizeName}-${this[name]}`] = true;
                }
                else {
                    listClassMap[`${this.prefixCls}-${sizeName}-${this[name].span}`] = this[name] && isNotNil(this[name].span);
                    listClassMap[`${this.prefixCls}-${sizeName}-pull-${this[name].pull}`] = this[name] && isNotNil(this[name].pull);
                    listClassMap[`${this.prefixCls}-${sizeName}-push-${this[name].push}`] = this[name] && isNotNil(this[name].push);
                    listClassMap[`${this.prefixCls}-${sizeName}-offset-${this[name].offset}`] = this[name] && isNotNil(this[name].offset);
                    listClassMap[`${this.prefixCls}-${sizeName}-order-${this[name].order}`] = this[name] && isNotNil(this[name].order);
                }
            }
        });
        return listClassMap;
    }
    /**
     * @return {?}
     */
    get nzRow() {
        return this.nzRowComponent || this.nzRowDirective;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
    }
}
NzColComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-col',
                providers: [NzUpdateHostClassService],
                preserveWhitespaces: false,
                template: `<ng-content></ng-content>`
            },] },
];
/** @nocollapse */
NzColComponent.ctorParameters = () => [
    { type: NzUpdateHostClassService },
    { type: ElementRef },
    { type: NzRowComponent, decorators: [{ type: Optional }, { type: Host }] },
    { type: NzRowDirective, decorators: [{ type: Optional }, { type: Host }] },
    { type: Renderer2 }
];
NzColComponent.propDecorators = {
    paddingLeft: [{ type: HostBinding, args: ['style.padding-left.px',] }],
    paddingRight: [{ type: HostBinding, args: ['style.padding-right.px',] }],
    nzSpan: [{ type: Input }],
    nzOrder: [{ type: Input }],
    nzOffset: [{ type: Input }],
    nzPush: [{ type: Input }],
    nzPull: [{ type: Input }],
    nzXs: [{ type: Input }],
    nzSm: [{ type: Input }],
    nzMd: [{ type: Input }],
    nzLg: [{ type: Input }],
    nzXl: [{ type: Input }],
    nzXXl: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzColDirective extends NzColComponent {
}
NzColDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-col]',
                providers: [NzUpdateHostClassService]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzGridModule {
}
NzGridModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzRowComponent, NzColDirective, NzColComponent, NzRowDirective],
                exports: [NzRowComponent, NzColDirective, NzColComponent, NzRowDirective],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzFormControlComponent extends NzColComponent {
    constructor() {
        super(...arguments);
        this._hasFeedback = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzHasFeedback(value) {
        this._hasFeedback = toBoolean(value);
        this.setControlClassMap();
    }
    /**
     * @return {?}
     */
    get nzHasFeedback() {
        return this._hasFeedback;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzValidateStatus(value) {
        if (value instanceof FormControl) {
            this.validateControl = value;
            this.validateString = null;
            this.controlStatus = null;
            this.setControlClassMap();
            this.watchControl();
        }
        else {
            this.validateString = value;
            this.validateControl = null;
            this.removeSubscribe();
            this.setControlClassMap();
        }
    }
    /**
     * @return {?}
     */
    removeSubscribe() {
        if (this.validateChanges) {
            this.validateChanges.unsubscribe();
            this.validateChanges = null;
        }
    }
    /**
     * @param {?} status
     * @return {?}
     */
    updateValidateStatus(status) {
        if (this.validateControl.dirty) {
            this.controlStatus = status;
            this.setControlClassMap();
        }
        else {
            this.controlStatus = null;
            this.setControlClassMap();
        }
    }
    /**
     * @return {?}
     */
    watchControl() {
        this.removeSubscribe();
        /** miss detect https://github.com/angular/angular/issues/10887 **/
        if (this.validateControl && this.validateControl.statusChanges) {
            this.validateChanges = this.validateControl.statusChanges.subscribe(data => this.updateValidateStatus(data));
        }
    }
    /**
     * @return {?}
     */
    setControlClassMap() {
        this.controlClassMap = {
            [`has-warning`]: this.validateString === 'warning',
            [`is-validating`]: this.validateString === 'validating' || this.validateString === 'pending' || this.controlStatus === 'PENDING',
            [`has-error`]: this.validateString === 'error' || this.controlStatus === 'INVALID',
            [`has-success`]: this.validateString === 'success' || this.controlStatus === 'VALID',
            [`has-feedback`]: this.nzHasFeedback
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
        this.setControlClassMap();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeSubscribe();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.watchControl();
        if (this.validateControl) {
            this.updateValidateStatus(this.validateControl.status);
        }
    }
}
NzFormControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-form-control',
                providers: [NzUpdateHostClassService],
                preserveWhitespaces: false,
                template: `<div class="ant-form-item-control" [ngClass]="controlClassMap"> <span class="ant-form-item-children"> <ng-content></ng-content> </span> <ng-content select="nz-form-explain"></ng-content> </div>`,
                host: {
                    '[class.ant-form-item-control-wrapper]': 'true'
                },
                styles: [`:host {
    display: block;
  }`]
            },] },
];
NzFormControlComponent.propDecorators = {
    validateControl: [{ type: ContentChild, args: [NgControl,] }],
    nzHasFeedback: [{ type: Input }],
    nzValidateStatus: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * should add nz-row directive to host, track https://github.com/angular/angular/issues/8785 *
 */
class NzFormItemComponent extends NzRowComponent {
    constructor() {
        super(...arguments);
        this._flex = false;
        this.withHelp = 0;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzFlex(value) {
        this._flex = toBoolean(value);
        if (this._flex) {
            this.renderer.setStyle(this.elementRef.nativeElement, 'display', 'flex');
        }
        else {
            this.renderer.removeStyle(this.elementRef.nativeElement, 'display');
        }
    }
    /**
     * @return {?}
     */
    enableHelp() {
        this.withHelp++;
    }
    /**
     * @return {?}
     */
    disableHelp() {
        this.withHelp--;
    }
}
NzFormItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-form-item',
                preserveWhitespaces: false,
                providers: [NzUpdateHostClassService],
                template: `<ng-content></ng-content>`,
                host: {
                    '[class.ant-form-item]': 'true',
                    '[class.ant-form-item-with-help]': 'withHelp>0'
                },
                styles: [`:host {
    display: block;
  }`]
            },] },
];
NzFormItemComponent.propDecorators = {
    nzFlex: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzFormExplainComponent {
    /**
     * @param {?} nzFormItemComponent
     */
    constructor(nzFormItemComponent) {
        this.nzFormItemComponent = nzFormItemComponent;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.nzFormItemComponent.disableHelp();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.nzFormItemComponent.enableHelp();
    }
}
NzFormExplainComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-form-explain',
                preserveWhitespaces: false,
                animations: [
                    trigger('formExplainAnimation', [
                        transition('void => *', [
                            style({
                                opacity: 0,
                                transform: 'translateY(-5px)'
                            }),
                            animate('0.3s cubic-bezier(0.645, 0.045, 0.355, 1)', style({
                                opacity: 1,
                                transform: 'translateY(0)'
                            }))
                        ]),
                        transition('* => void', [
                            style({
                                opacity: 1,
                                transform: 'translateY(0)'
                            }),
                            animate('0.3s cubic-bezier(0.645, 0.045, 0.355, 1)', style({
                                opacity: 0,
                                transform: 'translateY(-5px)'
                            }))
                        ])
                    ])
                ],
                template: `<div [@formExplainAnimation]> <ng-content></ng-content> </div>`,
                host: {
                    '[class.ant-form-explain]': 'true'
                },
                styles: [
                    `:host{
      display:block;
    }`
                ]
            },] },
];
/** @nocollapse */
NzFormExplainComponent.ctorParameters = () => [
    { type: NzFormItemComponent }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzFormExtraComponent {
}
NzFormExtraComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-form-extra',
                template: `<ng-content></ng-content>`,
                host: {
                    '[class.ant-form-extra]': 'true'
                },
                styles: [`:host {
    display: block;
  }`]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzFormLabelComponent extends NzColComponent {
    constructor() {
        super(...arguments);
        this._required = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzRequired(value) {
        this._required = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzRequired() {
        return this._required;
    }
}
NzFormLabelComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-form-label',
                providers: [NzUpdateHostClassService],
                preserveWhitespaces: false,
                template: `<label [attr.for]="nzFor" [class.ant-form-item-required]="nzRequired"> <ng-content></ng-content> </label>`,
                host: {
                    '[class.ant-form-item-label]': 'true'
                }
            },] },
];
NzFormLabelComponent.propDecorators = {
    nzFor: [{ type: Input }],
    nzRequired: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzFormSplitComponent {
}
NzFormSplitComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-form-split',
                template: `<ng-content></ng-content>`,
                host: {
                    '[class.ant-form-split]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzFormTextComponent {
}
NzFormTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-form-text',
                template: `<ng-content></ng-content>`,
                host: {
                    '[class.ant-form-text]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzFormDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} nzUpdateHostClassService
     */
    constructor(elementRef, renderer, nzUpdateHostClassService) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.nzUpdateHostClassService = nzUpdateHostClassService;
        this.prefixCls = 'ant-form';
        this._layout = 'horizontal';
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzLayout(value) {
        this._layout = value;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzLayout() {
        return this._layout;
    }
    /**
     * @return {?}
     */
    setClassMap() {
        const /** @type {?} */ classMap = {
            [`${this.prefixCls}`]: true,
            [`${this.prefixCls}-${this.nzLayout}`]: this.nzLayout
        };
        this.nzUpdateHostClassService.updateHostClass(this.el, classMap);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
    }
}
NzFormDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-form]',
                providers: [NzUpdateHostClassService]
            },] },
];
/** @nocollapse */
NzFormDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NzUpdateHostClassService }
];
NzFormDirective.propDecorators = {
    nzLayout: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzFormModule {
}
NzFormModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzFormExtraComponent, NzFormLabelComponent, NzFormDirective, NzFormItemComponent, NzFormControlComponent, NzFormExplainComponent, NzFormTextComponent, NzFormSplitComponent],
                exports: [NzFormExtraComponent, NzFormLabelComponent, NzFormDirective, NzFormItemComponent, NzFormControlComponent, NzFormExplainComponent, NzFormTextComponent, NzFormSplitComponent],
                imports: [CommonModule, NzGridModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzInputNumberComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.isInit = false;
        this._disabled = false;
        this._step = 1;
        this._autoFocus = false;
        this._formatter = (value) => value;
        this.isFocused = false;
        this.prefixCls = 'ant-input-number';
        this.disabledUp = false;
        this.disabledDown = false;
        this.onChange = () => null;
        this.onTouched = () => null;
        this.nzSize = 'default';
        this.nzMin = -Infinity;
        this.nzMax = Infinity;
        this.nzParser = (value) => value;
        this.nzPlaceHolder = '';
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    get isLarge() {
        return this.nzSize === 'large';
    }
    /**
     * @return {?}
     */
    get isSmall() {
        return this.nzSize === 'small';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAutoFocus(value) {
        this._autoFocus = toBoolean(value);
        this.updateAutoFocus();
    }
    /**
     * @return {?}
     */
    get nzAutoFocus() {
        return this._autoFocus;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzStep(value) {
        this._step = value;
    }
    /**
     * @return {?}
     */
    get nzStep() {
        return this._step;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set nzFormatter(v) {
        this._formatter = v;
        const /** @type {?} */ value = this.getCurrentValidValue(this.actualValue);
        this.writeValue(value);
    }
    /**
     * @return {?}
     */
    get nzFormatter() {
        return this._formatter;
    }
    /**
     * @return {?}
     */
    updateAutoFocus() {
        if (this.isInit) {
            if (this.nzAutoFocus) {
                this.renderer.setAttribute(this.inputElement.nativeElement, 'autofocus', 'autofocus');
            }
            else {
                this.renderer.removeAttribute(this.inputElement.nativeElement, 'autofocus');
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onModelChange(value) {
        this.actualValue = this.nzParser(value.trim().replace(/。/g, '.').replace(/[^\w\.-]+/g, ''));
        this.inputElement.nativeElement.value = this.actualValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getCurrentValidValue(value) {
        let /** @type {?} */ val = value;
        if (val === '') {
            val = '';
        }
        else if (!this.isNotCompleteNumber(val)) {
            val = /** @type {?} */ (this.getValidValue(val));
        }
        else {
            val = this.value;
        }
        return this.toNumber(val);
    }
    /**
     * @param {?} num
     * @return {?}
     */
    isNotCompleteNumber(num) {
        return (isNaN(/** @type {?} */ (num)) ||
            num === '' ||
            num === null ||
            (num && num.toString().indexOf('.') === num.toString().length - 1));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getValidValue(value) {
        let /** @type {?} */ val = parseFloat(/** @type {?} */ (value));
        // https://github.com/ant-design/ant-design/issues/7358
        if (isNaN(val)) {
            return value;
        }
        if (val < this.nzMin) {
            val = this.nzMin;
        }
        if (val > this.nzMax) {
            val = this.nzMax;
        }
        return val;
    }
    /**
     * @param {?} num
     * @return {?}
     */
    toNumber(num) {
        if (this.isNotCompleteNumber(num)) {
            return /** @type {?} */ (num);
        }
        if (isNotNil(this.nzPrecision)) {
            return Number(Number(num).toFixed(this.nzPrecision));
        }
        return Number(num);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onBlur(e) {
        this.isFocused = false;
        const /** @type {?} */ value = this.getCurrentValidValue(this.actualValue);
        this.setValue(value, `${this.value}` !== `${value}`);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocus(e) {
        this.isFocused = true;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    getRatio(e) {
        let /** @type {?} */ ratio = 1;
        if (e.metaKey || e.ctrlKey) {
            ratio = 0.1;
        }
        else if (e.shiftKey) {
            ratio = 10;
        }
        return ratio;
    }
    /**
     * @param {?} e
     * @param {?=} ratio
     * @return {?}
     */
    down(e, ratio) {
        if (!this.isFocused) {
            this.focus();
        }
        this.step('down', e, ratio);
    }
    /**
     * @param {?} e
     * @param {?=} ratio
     * @return {?}
     */
    up(e, ratio) {
        if (!this.isFocused) {
            this.focus();
        }
        this.step('up', e, ratio);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getPrecision(value) {
        const /** @type {?} */ valueString = value.toString();
        if (valueString.indexOf('e-') >= 0) {
            return parseInt(valueString.slice(valueString.indexOf('e-') + 2), 10);
        }
        let /** @type {?} */ precision = 0;
        if (valueString.indexOf('.') >= 0) {
            precision = valueString.length - valueString.indexOf('.') - 1;
        }
        return precision;
    }
    /**
     * @param {?} currentValue
     * @param {?} ratio
     * @return {?}
     */
    getMaxPrecision(currentValue, ratio) {
        if (isNotNil(this.nzPrecision)) {
            return this.nzPrecision;
        }
        const /** @type {?} */ ratioPrecision = this.getPrecision(ratio);
        const /** @type {?} */ stepPrecision = this.getPrecision(this.nzStep);
        const /** @type {?} */ currentValuePrecision = this.getPrecision(/** @type {?} */ (currentValue));
        if (!currentValue) {
            return ratioPrecision + stepPrecision;
        }
        return Math.max(currentValuePrecision, ratioPrecision + stepPrecision);
    }
    /**
     * @param {?} currentValue
     * @param {?} ratio
     * @return {?}
     */
    getPrecisionFactor(currentValue, ratio) {
        const /** @type {?} */ precision = this.getMaxPrecision(currentValue, ratio);
        return Math.pow(10, precision);
    }
    /**
     * @param {?} val
     * @param {?} rat
     * @return {?}
     */
    upStep(val, rat) {
        const /** @type {?} */ precisionFactor = this.getPrecisionFactor(val, rat);
        const /** @type {?} */ precision = Math.abs(this.getMaxPrecision(val, rat));
        let /** @type {?} */ result;
        if (typeof val === 'number') {
            result =
                ((precisionFactor * val + precisionFactor * this.nzStep * rat) /
                    precisionFactor).toFixed(precision);
        }
        else {
            result = this.nzMin === -Infinity ? this.nzStep : this.nzMin;
        }
        return this.toNumber(result);
    }
    /**
     * @param {?} val
     * @param {?} rat
     * @return {?}
     */
    downStep(val, rat) {
        const /** @type {?} */ precisionFactor = this.getPrecisionFactor(val, rat);
        const /** @type {?} */ precision = Math.abs(this.getMaxPrecision(val, rat));
        let /** @type {?} */ result;
        if (typeof val === 'number') {
            result =
                ((precisionFactor * val - precisionFactor * this.nzStep * rat) /
                    precisionFactor).toFixed(precision);
        }
        else {
            result = this.nzMin === -Infinity ? -this.nzStep : this.nzMin;
        }
        return this.toNumber(result);
    }
    /**
     * @param {?} type
     * @param {?} e
     * @param {?=} ratio
     * @return {?}
     */
    step(type, e, ratio = 1) {
        this.stop();
        e.preventDefault();
        if (this.nzDisabled) {
            return;
        }
        const /** @type {?} */ value = this.getCurrentValidValue(this.actualValue) || 0;
        let /** @type {?} */ val;
        if (type === 'up') {
            val = this.upStep(value, ratio);
        }
        else if (type === 'down') {
            val = this.downStep(value, ratio);
        }
        const /** @type {?} */ outOfRange = val > this.nzMax || val < this.nzMin;
        if (val > this.nzMax) {
            val = this.nzMax;
        }
        else if (val < this.nzMin) {
            val = this.nzMin;
        }
        this.setValue(val, true);
        this.isFocused = true;
        if (outOfRange) {
            return;
        }
        this.autoStepTimer = setTimeout(() => {
            this[type](e, ratio, true);
        }, 600);
    }
    /**
     * @return {?}
     */
    stop() {
        if (this.autoStepTimer) {
            clearTimeout(this.autoStepTimer);
        }
    }
    /**
     * @param {?} value
     * @param {?} emit
     * @return {?}
     */
    setValue(value, emit) {
        if (emit && (`${this.value}` !== `${value}`)) {
            this.onChange(value);
        }
        this.value = value;
        this.actualValue = value;
        const /** @type {?} */ displayValue = isNotNil(this.nzFormatter(this.value)) ? this.nzFormatter(this.value) : '';
        this.displayValue = displayValue;
        this.inputElement.nativeElement.value = displayValue;
        this.disabledUp = this.disabledDown = false;
        if (value || value === 0) {
            const /** @type {?} */ val = Number(value);
            if (val >= this.nzMax) {
                this.disabledUp = true;
            }
            if (val <= this.nzMin) {
                this.disabledDown = true;
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        if (e.code === 'ArrowUp' || e.keyCode === 38) {
            const /** @type {?} */ ratio = this.getRatio(e);
            this.up(e, ratio);
            this.stop();
        }
        else if (e.code === 'ArrowDown' || e.keyCode === 40) {
            const /** @type {?} */ ratio = this.getRatio(e);
            this.down(e, ratio);
            this.stop();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyUp(e) {
        this.stop();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.setValue(value, false);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
    }
    /**
     * @return {?}
     */
    focus() {
        this.inputElement.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    blur() {
        this.inputElement.nativeElement.blur();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.isInit = true;
    }
}
NzInputNumberComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-input-number',
                template: `<div class="ant-input-number-handler-wrap"> <a (mousedown)="up($event)" (mouseup)="stop()" (mouseleave)="stop()" class="ant-input-number-handler ant-input-number-handler-up" [class.ant-input-number-handler-up-disabled]="disabledUp"> <span class="ant-input-number-handler-up-inner" unselectable="unselectable" (click)="$event.preventDefault()"></span> </a> <a (mousedown)="down($event)" (mouseup)="stop()" (mouseleave)="stop()" class="ant-input-number-handler ant-input-number-handler-down" [class.ant-input-number-handler-down-disabled]="disabledDown"> <span class="ant-input-number-handler-down-inner" unselectable="unselectable" (click)="$event.preventDefault()"></span> </a> </div> <div class="ant-input-number-input-wrap"> <input #inputElement class="ant-input-number-input" [disabled]="nzDisabled" [attr.min]="nzMin" [attr.max]="nzMax" [placeholder]="nzPlaceHolder" [attr.step]="nzStep" (keydown)="onKeyDown($event)" (keyup)="onKeyUp($event)" (blur)="onBlur($event)" (focus)="onFocus($event)" [ngModel]="displayValue" (ngModelChange)="onModelChange($event)" autocomplete="off"> </div>`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzInputNumberComponent),
                        multi: true
                    }
                ],
                host: {
                    '[class.ant-input-number]': 'true',
                    '[class.ant-input-number-focused]': 'isFocused'
                }
            },] },
];
/** @nocollapse */
NzInputNumberComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NzInputNumberComponent.propDecorators = {
    inputElement: [{ type: ViewChild, args: ['inputElement',] }],
    nzSize: [{ type: Input }],
    nzMin: [{ type: Input }],
    nzMax: [{ type: Input }],
    nzParser: [{ type: Input }],
    nzPrecision: [{ type: Input }],
    nzPlaceHolder: [{ type: Input }],
    isLarge: [{ type: HostBinding, args: ['class.ant-input-number-lg',] }],
    isSmall: [{ type: HostBinding, args: ['class.ant-input-number-sm',] }],
    nzAutoFocus: [{ type: Input }],
    nzDisabled: [{ type: Input }, { type: HostBinding, args: ['class.ant-input-number-disabled',] }],
    nzStep: [{ type: Input }],
    nzFormatter: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzInputNumberModule {
}
NzInputNumberModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                declarations: [NzInputNumberComponent],
                exports: [NzInputNumberComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMatchMediaService {
    /**
     * @param {?} mediaQuery
     * @return {?}
     */
    matchMedia(mediaQuery) {
        return matchMedia(mediaQuery);
    }
}
NzMatchMediaService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzContentComponent {
}
NzContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-content',
                preserveWhitespaces: false,
                template: `<ng-content></ng-content>`,
                styles: [
                    `:host {
      display: block;
    }`
                ],
                host: {
                    '[class.ant-layout-content]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzFooterComponent {
}
NzFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-footer',
                preserveWhitespaces: false,
                template: `<ng-content></ng-content>`,
                styles: [
                    `:host {
      display: block;
    }`
                ],
                host: {
                    '[class.ant-layout-footer]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzHeaderComponent {
}
NzHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-header',
                preserveWhitespaces: false,
                template: `<ng-content></ng-content>`,
                styles: [
                    `:host {
      display: block;
    }`
                ],
                host: {
                    '[class.ant-layout-header]': 'true'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzLayoutComponent {
    constructor() {
        this.hasSider = false;
    }
}
NzLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-layout',
                preserveWhitespaces: false,
                template: `<ng-content></ng-content>`,
                host: {
                    '[class.ant-layout]': 'true',
                    '[class.ant-layout-has-sider]': 'hasSider'
                }
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSiderComponent {
    /**
     * @param {?} nzLayoutComponent
     * @param {?} nzMatchMediaService
     */
    constructor(nzLayoutComponent, nzMatchMediaService) {
        this.nzLayoutComponent = nzLayoutComponent;
        this.nzMatchMediaService = nzMatchMediaService;
        this._collapsed = false;
        this._collapsible = false;
        this._reverseArrow = false;
        this.below = false;
        this.isInit = false;
        this.dimensionMap = {
            xs: '480px',
            sm: '576px',
            md: '768px',
            lg: '992px',
            xl: '1200px',
            xxl: '1600px'
        };
        this.nzWidth = 200;
        this.nzCollapsedWidth = 80;
        this.nzCollapsedChange = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzReverseArrow(value) {
        this._reverseArrow = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzReverseArrow() {
        return this._reverseArrow;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTrigger(value) {
        this._trigger = value;
    }
    /**
     * @return {?}
     */
    get nzTrigger() {
        return this._trigger;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCollapsible(value) {
        this._collapsible = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzCollapsible() {
        return this._collapsible;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCollapsed(value) {
        this._collapsed = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzCollapsed() {
        return this._collapsed;
    }
    /**
     * @return {?}
     */
    get setZeroClass() {
        return this.nzCollapsed && (this.nzCollapsedWidth === 0);
    }
    /**
     * @return {?}
     */
    get setFlex() {
        if (this.nzCollapsed) {
            return `0 0 ${this.nzCollapsedWidth}px`;
        }
        else {
            return `0 0 ${this.nzWidth}px`;
        }
    }
    /**
     * @return {?}
     */
    get setWidth() {
        if (this.nzCollapsed) {
            return this.nzCollapsedWidth;
        }
        else {
            return this.nzWidth;
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onWindowResize(e) {
        this.watchMatchMedia();
    }
    /**
     * @return {?}
     */
    watchMatchMedia() {
        if (this.nzBreakpoint) {
            const /** @type {?} */ matchBelow = this.nzMatchMediaService.matchMedia(`(max-width: ${this.dimensionMap[this.nzBreakpoint]})`).matches;
            this.below = matchBelow;
            this.nzCollapsed = matchBelow;
            if (this.isInit) {
                this.nzCollapsedChange.emit(matchBelow);
            }
        }
    }
    /**
     * @return {?}
     */
    toggleCollapse() {
        this.nzCollapsed = !this.nzCollapsed;
        this.nzCollapsedChange.emit(this.nzCollapsed);
    }
    /**
     * @return {?}
     */
    get isZeroTrigger() {
        return this.nzCollapsible && this.nzTrigger && (this.nzCollapsedWidth === 0) && ((this.nzBreakpoint && this.below) || (!this.nzBreakpoint));
    }
    /**
     * @return {?}
     */
    get isSiderTrigger() {
        return this.nzCollapsible && this.nzTrigger && (this.nzCollapsedWidth !== 0);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.watchMatchMedia();
        if (this.nzLayoutComponent) {
            this.nzLayoutComponent.hasSider = true;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.isInit = true;
    }
}
NzSiderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-sider',
                preserveWhitespaces: false,
                template: `<div class="ant-layout-sider-children"> <ng-content></ng-content> </div> <span class="ant-layout-sider-zero-width-trigger" *ngIf="isZeroTrigger" (click)="toggleCollapse()"> <i class="anticon anticon-bars"></i> </span> <div class="ant-layout-sider-trigger" *ngIf="isSiderTrigger" (click)="toggleCollapse()" [style.width.px]="nzCollapsed?nzCollapsedWidth:nzWidth"> <ng-template [ngTemplateOutlet]="nzTrigger"></ng-template> </div> <ng-template #defaultTrigger> <i class="anticon" [class.anticon-left]="!nzCollapsed" [class.anticon-right]="nzCollapsed" *ngIf="!nzReverseArrow"></i> <i class="anticon" [class.anticon-left]="nzCollapsed" [class.anticon-right]="!nzCollapsed" *ngIf="nzReverseArrow"></i> </ng-template>`,
                host: {
                    '[class.ant-layout-sider]': 'true'
                }
            },] },
];
/** @nocollapse */
NzSiderComponent.ctorParameters = () => [
    { type: NzLayoutComponent, decorators: [{ type: Optional }, { type: Host }] },
    { type: NzMatchMediaService }
];
NzSiderComponent.propDecorators = {
    _trigger: [{ type: ViewChild, args: ['defaultTrigger',] }],
    nzWidth: [{ type: Input }],
    nzCollapsedWidth: [{ type: Input }],
    nzBreakpoint: [{ type: Input }],
    nzReverseArrow: [{ type: Input }],
    nzTrigger: [{ type: Input }],
    nzCollapsible: [{ type: Input }],
    nzCollapsed: [{ type: Input }, { type: HostBinding, args: ['class.ant-layout-sider-collapsed',] }],
    nzCollapsedChange: [{ type: Output }],
    setZeroClass: [{ type: HostBinding, args: ['class.ant-layout-sider-zero-width',] }],
    setFlex: [{ type: HostBinding, args: ['style.flex',] }],
    setWidth: [{ type: HostBinding, args: ['style.max-width.px',] }, { type: HostBinding, args: ['style.min-width.px',] }, { type: HostBinding, args: ['style.width.px',] }],
    onWindowResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzLayoutModule {
}
NzLayoutModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzLayoutComponent, NzHeaderComponent, NzContentComponent, NzFooterComponent, NzSiderComponent],
                exports: [NzLayoutComponent, NzHeaderComponent, NzContentComponent, NzFooterComponent, NzSiderComponent],
                providers: [NzMatchMediaService],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSpinComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} zone
     */
    constructor(elementRef, renderer, zone) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        this._delay = 0;
        this.isNested = false;
        this.baseSpinning$ = new BehaviorSubject(true);
        this.resultSpinning$ = this.baseSpinning$.asObservable().pipe(debounceTime(this.nzDelay));
        this.nzSize = 'default';
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDelay(value) {
        if (isNotNil(value)) {
            this._delay = value;
            this.resultSpinning$ = this.baseSpinning$.asObservable().pipe(debounceTime(this.nzDelay));
        }
    }
    /**
     * @return {?}
     */
    get nzDelay() {
        return this._delay;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTip(value) {
        this._tip = value;
    }
    /**
     * @return {?}
     */
    get nzTip() {
        return this._tip;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSpinning(value) {
        this.baseSpinning$.next(toBoolean(value));
    }
    /**
     * @return {?}
     */
    checkNested() {
        /** no way to detect empty https://github.com/angular/angular/issues/12530 **/
        if (!isEmpty(this.containerElement.nativeElement)) {
            this.isNested = true;
            this.renderer.setStyle(this.el, 'display', 'block');
        }
        else {
            this.isNested = false;
            this.renderer.removeStyle(this.el, 'display');
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.checkNested();
    }
}
NzSpinComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-spin',
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `<ng-template #defaultIndicatorTemplate> <span class="ant-spin-dot" [class.ant-spin-dot-spin]="resultSpinning$|async"> <i></i><i></i><i></i><i></i> </span> </ng-template> <div [class.ant-spin-nested-loading]="isNested"> <div [hidden]="!(resultSpinning$|async)"> <div class="ant-spin" [class.ant-spin-spinning]="resultSpinning$|async" [class.ant-spin-lg]="nzSize=='large'" [class.ant-spin-sm]="nzSize=='small'" [class.ant-spin-show-text]="nzTip"> <ng-template [ngTemplateOutlet]="nzIndicator||defaultIndicatorTemplate"></ng-template> <div class="ant-spin-text" *ngIf="nzTip">{{ nzTip }}</div> </div> </div> <div #containerElement class="ant-spin-container" [class.ant-spin-blur]="resultSpinning$|async" [hidden]="!isNested" (cdkObserveContent)="checkNested()"> <ng-content></ng-content> </div> </div>`
            },] },
];
/** @nocollapse */
NzSpinComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
NzSpinComponent.propDecorators = {
    containerElement: [{ type: ViewChild, args: ['containerElement',] }],
    nzIndicator: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzDelay: [{ type: Input }],
    nzTip: [{ type: Input }],
    nzSpinning: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSpinModule {
}
NzSpinModule.decorators = [
    { type: NgModule, args: [{
                exports: [NzSpinComponent],
                declarations: [NzSpinComponent],
                imports: [CommonModule, ObserversModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzListItemMetaComponent {
    constructor() {
        this.isAvatar = false;
        this.avatarStr = '';
        this.isTitle = false;
        this.titleStr = '';
        this.isDesc = false;
        this.descStr = '';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAvatar(value) {
        if (value instanceof TemplateRef) {
            this.avatarStr = null;
            this.avatarTpl = value;
        }
        else {
            this.avatarStr = value;
        }
        this.isAvatar = !!value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTitle(value) {
        if (value instanceof TemplateRef) {
            this.titleStr = null;
            this.titleTpl = value;
        }
        else {
            this.titleStr = value;
        }
        this.isTitle = !!value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDescription(value) {
        if (value instanceof TemplateRef) {
            this.descStr = null;
            this.descTpl = value;
        }
        else {
            this.descStr = value;
        }
        this.isDesc = !!value;
    }
}
NzListItemMetaComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-list-item-meta',
                template: `<div *ngIf="isAvatar" class="ant-list-item-meta-avatar"> <ng-container *ngIf="avatarStr; else avatarTpl"> <nz-avatar [nzSrc]="avatarStr"></nz-avatar> </ng-container> </div> <div *ngIf="isTitle || isDesc" class="ant-list-item-meta-content"> <h4 *ngIf="isTitle" class="ant-list-item-meta-title"> <ng-container *ngIf="titleStr; else titleTpl">{{ titleStr }}</ng-container> </h4> <div *ngIf="isDesc" class="ant-list-item-meta-description"> <ng-container *ngIf="descStr; else descTpl">{{ descStr }}</ng-container> </div> </div>`,
                preserveWhitespaces: false,
                host: {
                    '[class.ant-list-item-meta]': 'true'
                }
            },] },
];
NzListItemMetaComponent.propDecorators = {
    nzAvatar: [{ type: Input }],
    nzTitle: [{ type: Input }],
    nzDescription: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzListItemComponent {
    constructor() {
        this.nzActions = [];
        this.isCon = false;
        this.conStr = '';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzContent(value) {
        if (value instanceof TemplateRef) {
            this.conStr = null;
            this.conTpl = value;
        }
        else {
            this.conStr = value;
        }
        this.isCon = !!value;
    }
}
NzListItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-list-item',
                template: `<ng-template #contentTpl> <div *ngIf="isCon" class="ant-list-item-content" [ngClass]="{'ant-list-item-content-single': metas.length < 1}"> <ng-container *ngIf="conStr; else conTpl">{{ conStr }}</ng-container> </div> </ng-template> <ng-template #actionsTpl> <ul *ngIf="nzActions?.length > 0" class="ant-list-item-action"> <li *ngFor="let i of nzActions; let idx = index"> <ng-template [ngTemplateOutlet]="i"></ng-template> <em *ngIf="idx!==nzActions.length-1" class="ant-list-item-action-split"></em> </li> </ul> </ng-template> <ng-template #mainTpl> <ng-content></ng-content> <ng-template [ngTemplateOutlet]="contentTpl"></ng-template> <ng-template [ngTemplateOutlet]="actionsTpl"></ng-template> </ng-template> <div *ngIf="nzExtra; else mainTpl" class="ant-list-item-extra-wrap"> <div class="ant-list-item-main"> <ng-template [ngTemplateOutlet]="mainTpl"></ng-template> </div> <div class="ant-list-item-extra"> <ng-template [ngTemplateOutlet]="nzExtra"></ng-template> </div> </div>`,
                preserveWhitespaces: false,
                host: {
                    '[class.ant-list-item]': 'true'
                }
            },] },
];
NzListItemComponent.propDecorators = {
    nzActions: [{ type: Input }],
    metas: [{ type: ContentChildren, args: [NzListItemMetaComponent,] }],
    nzContent: [{ type: Input }],
    nzExtra: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzListComponent {
    /**
     * @param {?} el
     * @param {?} cd
     * @param {?} updateHostClassService
     */
    constructor(el, cd, updateHostClassService) {
        this.el = el;
        this.cd = cd;
        this.updateHostClassService = updateHostClassService;
        // region: fields
        this.nzDataSource = [];
        this._bordered = false;
        this._isHeader = false;
        this._header = '';
        this._isFooter = false;
        this._footer = '';
        this.nzItemLayout = 'horizontal';
        this._loading = false;
        this.nzSize = 'default';
        this._split = true;
        this.prefixCls = 'ant-list';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzBordered(value) {
        this._bordered = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzBordered() {
        return this._bordered;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzHeader(value) {
        if (value instanceof TemplateRef) {
            this._header = null;
            this._headerTpl = value;
        }
        else {
            this._header = value;
        }
        this._isHeader = !!value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzFooter(value) {
        if (value instanceof TemplateRef) {
            this._footer = null;
            this._footerTpl = value;
        }
        else {
            this._footer = value;
        }
        this._isFooter = !!value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzLoading(value) {
        this._loading = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzLoading() {
        return this._loading;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSplit(value) {
        this._split = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzSplit() {
        return this._split;
    }
    /**
     * @return {?}
     */
    _setClassMap() {
        const /** @type {?} */ classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-vertical`]: this.nzItemLayout === 'vertical',
            [`${this.prefixCls}-lg`]: this.nzSize === 'large',
            [`${this.prefixCls}-sm`]: this.nzSize === 'small',
            [`${this.prefixCls}-split`]: this.nzSplit,
            [`${this.prefixCls}-bordered`]: this.nzBordered,
            [`${this.prefixCls}-loading`]: this.nzLoading,
            [`${this.prefixCls}-grid`]: this.nzGrid,
            [`${this.prefixCls}-something-after-last-item`]: !!(this.nzLoadMore || this.nzPagination || this._isFooter)
        };
        this.updateHostClassService.updateHostClass(this.el.nativeElement, classMap);
        this.cd.detectChanges();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this._setClassMap();
    }
}
NzListComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-list',
                template: `<ng-template #itemsTpl> <ng-container *ngFor="let item of nzDataSource; let index = index"> <ng-template [ngTemplateOutlet]="nzRenderItem" [ngTemplateOutletContext]="{ $implicit: item, index: index }"></ng-template> </ng-container> </ng-template> <div *ngIf="_isHeader" class="ant-list-header"> <ng-container *ngIf="_header; else _headerTpl">{{ _header }}</ng-container> </div> <nz-spin [nzSpinning]="nzLoading"> <div *ngIf="nzLoading && nzDataSource.length === 0" [style.min-height.px]="53"></div> <div *ngIf="nzGrid; else itemsTpl" nz-row [nzGutter]="nzGrid.gutter"> <div nz-col [nzSpan]="nzGrid.span" [nzXs]="nzGrid.xs" [nzSm]="nzGrid.sm" [nzMd]="nzGrid.md" [nzLg]="nzGrid.lg" [nzXl]="nzGrid.xl" [nzXXl]="nzGrid.xxl" *ngFor="let item of nzDataSource; let index = index"> <ng-template [ngTemplateOutlet]="nzRenderItem" [ngTemplateOutletContext]="{ $implicit: item, index: index }"></ng-template> </div> </div> </nz-spin> <ng-template [ngTemplateOutlet]="nzLoadMore"></ng-template> <ng-content></ng-content> <div *ngIf="nzPagination" class="ant-list-pagination"> <ng-template [ngTemplateOutlet]="nzPagination"></ng-template> </div> <div *ngIf="_isFooter" class="ant-list-footer"> <ng-container *ngIf="_footer; else _footerTpl">{{ _footer }}</ng-container> </div>`,
                providers: [NzUpdateHostClassService],
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    :host {
      display: block;
    }

    nz-spin {
      display: block;
    }
  `]
            },] },
];
/** @nocollapse */
NzListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NzUpdateHostClassService }
];
NzListComponent.propDecorators = {
    nzDataSource: [{ type: Input }],
    nzBordered: [{ type: Input }],
    nzGrid: [{ type: Input }],
    nzHeader: [{ type: Input }],
    nzFooter: [{ type: Input }],
    nzItemLayout: [{ type: Input }],
    nzRenderItem: [{ type: Input }],
    nzLoading: [{ type: Input }],
    nzLoadMore: [{ type: Input }],
    nzPagination: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzSplit: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzListModule {
}
NzListModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NzSpinModule, NzGridModule, NzAvatarModule],
                declarations: [NzListComponent, NzListItemComponent, NzListItemMetaComponent],
                exports: [NzListComponent, NzListItemComponent, NzListItemMetaComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMentionSuggestionDirective {
}
NzMentionSuggestionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nzMentionSuggestion]'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const NZ_MENTION_TRIGGER_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NzMentionTriggerDirective),
    multi: true
};
class NzMentionTriggerDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this.onFocusin = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.onInput = new EventEmitter();
        this.onKeydown = new EventEmitter();
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.completeEvents();
    }
    /**
     * @return {?}
     */
    completeEvents() {
        this.onFocusin.complete();
        this.onBlur.complete();
        this.onInput.complete();
        this.onKeydown.complete();
        this.onClick.complete();
    }
    /**
     * @param {?=} caretPos
     * @return {?}
     */
    focus(caretPos) {
        this.el.nativeElement.focus();
        this.el.nativeElement.setSelectionRange(caretPos, caretPos);
    }
    /**
     * @param {?} mention
     * @return {?}
     */
    insertMention(mention) {
        const /** @type {?} */ value = this.el.nativeElement.value;
        const /** @type {?} */ insertValue = mention.mention.trim() + ' ';
        const /** @type {?} */ newValue = [
            value.slice(0, mention.startPos + 1),
            insertValue,
            value.slice(mention.endPos, value.length)
        ].join('');
        this.el.nativeElement.value = newValue;
        this.focus(mention.startPos + insertValue.length + 1);
        this.onChange(newValue);
        this.value = newValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
        if (typeof value === 'string') {
            this.el.nativeElement.value = value;
        }
        else {
            this.el.nativeElement.value = '';
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
NzMentionTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[nzMentionTrigger], textarea[nzMentionTrigger]',
                providers: [NZ_MENTION_TRIGGER_ACCESSOR],
                host: {
                    'autocomplete': 'off',
                    '(focusin)': 'onFocusin.emit()',
                    '(blur)': 'onBlur.emit()',
                    '(input)': 'onInput.emit($event)',
                    '(keydown)': 'onKeydown.emit($event)',
                    '(click)': 'onClick.emit($event)'
                }
            },] },
];
/** @nocollapse */
NzMentionTriggerDirective.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} prefix
 * @return {?}
 */
function getRegExp(prefix) {
    const /** @type {?} */ prefixArray = Array.isArray(prefix) ? prefix : [prefix];
    let /** @type {?} */ prefixToken = prefixArray.join('').replace(/(\$|\^)/g, '\\$1');
    if (prefixArray.length > 1) {
        prefixToken = `[${prefixToken}]`;
    }
    return new RegExp(`(\\s|^)(${prefixToken})[^\\s]*`, 'g');
}
/**
 * @param {?} value
 * @param {?=} prefix
 * @return {?}
 */
function getMentions(value, prefix = '@') {
    if (typeof value !== 'string') {
        return [];
    }
    const /** @type {?} */ regex = getRegExp(prefix);
    const /** @type {?} */ mentions = value.match(regex);
    return mentions !== null ? mentions.map(e => e.trim()) : [];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// from https://github.com/component/textarea-caret-position
// We'll copy the properties below into the mirror div.
// Note that some browsers, such as Firefox, do not concatenate properties
// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),
// so we have to list every single property explicitly.
const properties = [
    'direction',
    'boxSizing',
    'width',
    'height',
    'overflowX',
    'overflowY',
    'borderTopWidth',
    'borderRightWidth',
    'borderBottomWidth',
    'borderLeftWidth',
    'borderStyle',
    'paddingTop',
    'paddingRight',
    'paddingBottom',
    'paddingLeft',
    'fontStyle',
    'fontVariant',
    'fontWeight',
    'fontStretch',
    'fontSize',
    'fontSizeAdjust',
    'lineHeight',
    'fontFamily',
    'textAlign',
    'textTransform',
    'textIndent',
    'textDecoration',
    'letterSpacing',
    'wordSpacing',
    'tabSize',
    'MozTabSize'
];
const isBrowser = (typeof window !== 'undefined');
// tslint:disable-next-line:no-any
const isFirefox = (isBrowser && (/** @type {?} */ (window)).mozInnerScreenX != null);
const _parseInt = (str) => parseInt(str, 10);
/**
 * @record
 */

/**
 * @param {?} element
 * @param {?} position
 * @param {?=} options
 * @return {?}
 */
function getCaretCoordinates(element, position, options) {
    if (!isBrowser) {
        throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');
    }
    const /** @type {?} */ debug = options && options.debug || false;
    if (debug) {
        const /** @type {?} */ el = document.querySelector('#input-textarea-caret-position-mirror-div');
        if (el) {
            el.parentNode.removeChild(el);
        }
    }
    // The mirror div will replicate the textarea's style
    const /** @type {?} */ div = document.createElement('div');
    div.id = 'input-textarea-caret-position-mirror-div';
    document.body.appendChild(div);
    const /** @type {?} */ style$$1 = div.style;
    // tslint:disable-next-line:no-any
    const /** @type {?} */ computed = window.getComputedStyle ? window.getComputedStyle(element) : (/** @type {?} */ (element)).currentStyle; // currentStyle for IE < 9
    const /** @type {?} */ isInput = element.nodeName === 'INPUT';
    // Default textarea styles
    style$$1.whiteSpace = 'pre-wrap';
    if (!isInput) {
        style$$1.wordWrap = 'break-word'; // only for textarea-s
    }
    // Position off-screen
    style$$1.position = 'absolute'; // required to return coordinates properly
    if (!debug) {
        style$$1.visibility = 'hidden';
    } // not 'display: none' because we want rendering
    // Transfer the element's properties to the div
    properties.forEach((prop) => {
        if (isInput && prop === 'lineHeight') {
            // Special case for <input>s because text is rendered centered and line height may be != height
            style$$1.lineHeight = computed.height;
        }
        else {
            style$$1[prop] = computed[prop];
        }
    });
    if (isFirefox) {
        // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275
        if (element.scrollHeight > _parseInt(computed.height)) {
            style$$1.overflowY = 'scroll';
        }
    }
    else {
        style$$1.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'
    }
    div.textContent = element.value.substring(0, position);
    // The second special handling for input type="text" vs textarea:
    // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037
    if (isInput) {
        div.textContent = div.textContent.replace(/\s/g, '\u00a0');
    }
    const /** @type {?} */ span = document.createElement('span');
    // Wrapping must be replicated *exactly*, including when a long word gets
    // onto the next line, with whitespace at the end of the line before (#7).
    // The  *only* reliable way to do that is to copy the *entire* rest of the
    // textarea's content into the <span> created at the caret position.
    // For inputs, just '.' would be enough, but no need to bother.
    span.textContent = element.value.substring(position) || '.'; // || because a completely empty faux span doesn't render at all
    div.appendChild(span);
    const /** @type {?} */ coordinates = {
        top: span.offsetTop + _parseInt(computed.borderTopWidth),
        left: span.offsetLeft + _parseInt(computed.borderLeftWidth),
        height: _parseInt(computed.lineHeight)
    };
    if (debug) {
        span.style.backgroundColor = '#eee';
        createDebugEle(element, coordinates);
    }
    else {
        document.body.removeChild(div);
    }
    return coordinates;
}
/**
 * @param {?} element
 * @param {?} coordinates
 * @return {?}
 */
function createDebugEle(element, coordinates) {
    const /** @type {?} */ fontSize = getComputedStyle(element).getPropertyValue('font-size');
    const /** @type {?} */ rect = (/** @type {?} */ (document.querySelector('#DEBUG')))
        || document.createElement('div');
    document.body.appendChild(rect);
    rect.id = 'DEBUG';
    rect.style.position = 'absolute';
    rect.style.backgroundColor = 'red';
    rect.style.height = fontSize;
    rect.style.width = '1px';
    rect.style.top = `${element.getBoundingClientRect().top - element.scrollTop + window.pageYOffset + coordinates.top}px`;
    rect.style.left = `${element.getBoundingClientRect().left - element.scrollLeft + window.pageXOffset + coordinates.left}px`;
    console.log(rect.style.top);
    console.log(rect.style.left);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class NzMentionComponent {
    /**
     * @param {?} document
     * @param {?} ngZone
     * @param {?} overlay
     * @param {?} viewContainerRef
     */
    constructor(document, ngZone, overlay, viewContainerRef) {
        this.document = document;
        this.ngZone = ngZone;
        this.overlay = overlay;
        this.viewContainerRef = viewContainerRef;
        this.nzOnSelect = new EventEmitter();
        this.nzOnSearchChange = new EventEmitter();
        this.nzValueWith = value => value;
        this.nzPrefix = '@';
        this.nzLoading = false;
        this.nzNotFoundContent = '无匹配结果，轻敲空格完成输入';
        this.isOpen = false;
        this.suggestionTemplate = null;
        this._placement = 'bottom';
        this.activeIndex = -1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSuggestions(value) {
        this._suggestions = value;
        if (this.isOpen) {
            this.previousValue = null;
            this.activeIndex = -1;
            this.resetDropdown(false);
        }
    }
    /**
     * @return {?}
     */
    get nzSuggestions() {
        return this._suggestions;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPlacement(value) {
        this._placement = value;
    }
    /**
     * @return {?}
     */
    get nzPlacement() {
        return this._placement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set suggestionChild(value) {
        if (value) {
            this.suggestionTemplate = value;
        }
    }
    /**
     * @return {?}
     */
    get triggerNativeElement() {
        return this.trigger.el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.bindTriggerEvents();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.closeDropdown();
    }
    /**
     * @return {?}
     */
    closeDropdown() {
        if (this.overlayRef && this.overlayRef.hasAttached()) {
            this.overlayRef.detach();
            this.overlayBackdropClickSubscription.unsubscribe();
            this.isOpen = false;
        }
    }
    /**
     * @return {?}
     */
    openDropdown() {
        this.attachOverlay();
        this.isOpen = true;
    }
    /**
     * @return {?}
     */
    getMentions() {
        return getMentions(this.trigger.value, this.nzPrefix);
    }
    /**
     * @param {?} suggestion
     * @return {?}
     */
    selectSuggestion(suggestion) {
        const /** @type {?} */ value = this.nzValueWith(suggestion);
        this.trigger.insertMention({
            mention: value,
            startPos: this.cursorMentionStart,
            endPos: this.cursorMentionEnd
        });
        this.nzOnSelect.emit(suggestion);
        this.closeDropdown();
        this.activeIndex = -1;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleInput(event) {
        const /** @type {?} */ target = /** @type {?} */ (event.target);
        this.trigger.onChange(target.value);
        this.trigger.value = target.value;
        this.resetDropdown();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleKeydown(event) {
        const /** @type {?} */ keyCode = event.keyCode;
        if (this.isOpen && keyCode === ENTER && this.activeIndex !== -1 && this.filteredSuggestions.length) {
            this.selectSuggestion(this.filteredSuggestions[this.activeIndex]);
            event.preventDefault();
        }
        else if (keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW) {
            this.resetDropdown();
            event.stopPropagation();
        }
        else {
            if (this.isOpen && (keyCode === TAB || keyCode === ESCAPE)) {
                this.closeDropdown();
                return;
            }
            if (this.isOpen && (keyCode === UP_ARROW)) {
                this.setPreviousItemActive();
                event.preventDefault();
                event.stopPropagation();
            }
            if (this.isOpen && (keyCode === DOWN_ARROW)) {
                this.setNextItemActive();
                event.preventDefault();
                event.stopPropagation();
            }
        }
    }
    /**
     * @return {?}
     */
    handleClick() {
        this.resetDropdown();
    }
    /**
     * @return {?}
     */
    bindTriggerEvents() {
        this.trigger.onInput.subscribe((e) => this.handleInput(e));
        this.trigger.onKeydown.subscribe((e) => this.handleKeydown(e));
        this.trigger.onClick.subscribe(() => this.handleClick());
    }
    /**
     * @param {?} value
     * @param {?} emit
     * @return {?}
     */
    suggestionsFilter(value, emit) {
        const /** @type {?} */ suggestions = value.substring(1);
        if (this.previousValue === value) {
            return;
        }
        this.previousValue = value;
        if (emit) {
            this.nzOnSearchChange.emit({
                value: this.cursorMention.substring(1),
                prefix: this.cursorMention[0]
            });
        }
        const /** @type {?} */ searchValue = suggestions.toLowerCase();
        this.filteredSuggestions = this.nzSuggestions
            .filter(suggestion => this.nzValueWith(suggestion).toLowerCase().includes(searchValue));
    }
    /**
     * @param {?=} emit
     * @return {?}
     */
    resetDropdown(emit = true) {
        this.resetCursorMention();
        if (typeof this.cursorMention !== 'string' || !this.canOpen()) {
            this.closeDropdown();
            return;
        }
        this.suggestionsFilter(this.cursorMention, emit);
        const /** @type {?} */ activeIndex = this.filteredSuggestions.indexOf(this.cursorMention.substring(1));
        this.activeIndex = activeIndex >= 0 ? activeIndex : 0;
        this.openDropdown();
    }
    /**
     * @return {?}
     */
    setNextItemActive() {
        this.activeIndex = this.activeIndex + 1 <= this.filteredSuggestions.length - 1
            ? this.activeIndex + 1
            : 0;
    }
    /**
     * @return {?}
     */
    setPreviousItemActive() {
        this.activeIndex = this.activeIndex - 1 < 0
            ? this.filteredSuggestions.length - 1
            : this.activeIndex - 1;
    }
    /**
     * @return {?}
     */
    canOpen() {
        const /** @type {?} */ element = this.triggerNativeElement;
        return !element.readOnly && !element.disabled;
    }
    /**
     * @return {?}
     */
    resetCursorMention() {
        const /** @type {?} */ value = this.triggerNativeElement.value.replace(/[\r\n]/g, ' ') || '';
        const /** @type {?} */ selectionStart = this.triggerNativeElement.selectionStart;
        const /** @type {?} */ prefix = typeof this.nzPrefix === 'string' ? [this.nzPrefix] : this.nzPrefix;
        let /** @type {?} */ i = prefix.length;
        while (i >= 0) {
            const /** @type {?} */ startPos = value.lastIndexOf(prefix[i], selectionStart);
            const /** @type {?} */ endPos = value.indexOf(' ', selectionStart) > -1 ? value.indexOf(' ', selectionStart) : value.length;
            const /** @type {?} */ mention = value.substring(startPos, endPos);
            if ((startPos > 0 && value[startPos - 1] !== ' ')
                || startPos < 0
                || mention.includes(prefix[i], 1)
                || mention.includes(' ')) {
                this.cursorMention = null;
                this.cursorMentionStart = -1;
                this.cursorMentionEnd = -1;
            }
            else {
                this.cursorMention = mention;
                this.cursorMentionStart = startPos;
                this.cursorMentionEnd = endPos;
                return;
            }
            i--;
        }
    }
    /**
     * @return {?}
     */
    updatePositions() {
        const /** @type {?} */ coordinates = getCaretCoordinates(this.triggerNativeElement, this.cursorMentionStart);
        const /** @type {?} */ top = coordinates.top
            - this.triggerNativeElement.getBoundingClientRect().height
            - this.triggerNativeElement.scrollTop
            + (this.nzPlacement === 'bottom' ? coordinates.height : 0);
        const /** @type {?} */ left = coordinates.left - this.triggerNativeElement.scrollLeft;
        this.positionStrategy.withDefaultOffsetX(left).withDefaultOffsetY(top);
        if (this.nzPlacement === 'bottom') {
            this.positionStrategy.withPositions([DEFAULT_MENTION_POSITIONS[0]]);
        }
        if (this.nzPlacement === 'top') {
            this.positionStrategy.withPositions([DEFAULT_MENTION_POSITIONS[1]]);
        }
        this.positionStrategy.apply();
    }
    /**
     * @return {?}
     */
    subscribeOverlayBackdropClick() {
        return merge(fromEvent(this.document, 'click'), fromEvent(this.document, 'touchend'))
            .subscribe((event) => {
            const /** @type {?} */ clickTarget = /** @type {?} */ (event.target);
            if (clickTarget !== this.trigger.el.nativeElement && this.isOpen) {
                this.closeDropdown();
            }
        });
    }
    /**
     * @return {?}
     */
    attachOverlay() {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.suggestionsTemp, this.viewContainerRef);
            this.overlayRef = this.overlay.create(this.getOverlayConfig());
        }
        if (this.overlayRef && !this.overlayRef.hasAttached()) {
            this.overlayRef.attach(this.portal);
            this.overlayBackdropClickSubscription = this.subscribeOverlayBackdropClick();
        }
        this.updatePositions();
    }
    /**
     * @return {?}
     */
    getOverlayConfig() {
        return new OverlayConfig({
            positionStrategy: this.getOverlayPosition(),
            scrollStrategy: this.overlay.scrollStrategies.reposition()
        });
    }
    /**
     * @return {?}
     */
    getOverlayPosition() {
        const /** @type {?} */ positions = [
            new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
            new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
        ];
        this.positionStrategy = this.overlay.position()
            .flexibleConnectedTo(this.trigger.el)
            .withPositions(positions)
            .withFlexibleDimensions(false)
            .withPush(false);
        return this.positionStrategy;
    }
}
NzMentionComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-mention',
                template: `<ng-content></ng-content> <ng-template #suggestions> <ul class="ant-mention-dropdown"> <li class="ant-mention-dropdown-item" *ngFor="let suggestion of filteredSuggestions; let i = index" [class.focus]="i === activeIndex" (click)="selectSuggestion(suggestion)"> <ng-container *ngIf="suggestionTemplate else defaultSuggestion"> <ng-container *ngTemplateOutlet="suggestionTemplate; context: {$implicit: suggestion}"></ng-container> </ng-container> <ng-template #defaultSuggestion>{{ nzValueWith(suggestion) }}</ng-template> </li> <li class="ant-mention-dropdown-notfound ant-mention-dropdown-item" *ngIf="filteredSuggestions.length === 0"> <span *ngIf="nzLoading"><i class="anticon anticon-spin anticon-loading"></i></span> <span *ngIf="!nzLoading">{{ nzNotFoundContent }}</span> </li> </ul> </ng-template> `,
                preserveWhitespaces: false,
                styles: [`
    .ant-mention-dropdown {
      top: 100%;
      left: 0;
      position: relative;
      width: 100%;
      margin-top: 4px;
      margin-bottom: 4px;
    }
  `]
            },] },
];
/** @nocollapse */
NzMentionComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone },
    { type: Overlay },
    { type: ViewContainerRef }
];
NzMentionComponent.propDecorators = {
    nzOnSelect: [{ type: Output }],
    nzOnSearchChange: [{ type: Output }],
    nzValueWith: [{ type: Input }],
    nzPrefix: [{ type: Input }],
    nzLoading: [{ type: Input }],
    nzNotFoundContent: [{ type: Input }],
    nzSuggestions: [{ type: Input }],
    nzPlacement: [{ type: Input }],
    trigger: [{ type: ContentChild, args: [NzMentionTriggerDirective,] }],
    suggestionsTemp: [{ type: ViewChild, args: [TemplateRef,] }],
    suggestionChild: [{ type: ContentChild, args: [NzMentionSuggestionDirective, { read: TemplateRef },] }]
};
/**
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const COMPONENTS = [NzMentionComponent, NzMentionTriggerDirective, NzMentionSuggestionDirective];
class NzMentionModule {
}
NzMentionModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, OverlayModule],
                declarations: [...COMPONENTS],
                exports: [...COMPONENTS]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

const NZ_MESSAGE_DEFAULT_CONFIG = new InjectionToken('NZ_MESSAGE_DEFAULT_CONFIG');
const NZ_MESSAGE_CONFIG = new InjectionToken('NZ_MESSAGE_CONFIG');
const NZ_MESSAGE_DEFAULT_CONFIG_PROVIDER = {
    provide: NZ_MESSAGE_DEFAULT_CONFIG,
    useValue: {
        nzDuration: 3000,
        nzAnimate: true,
        nzPauseOnHover: true,
        nzMaxStack: 7
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMessageContainerComponent {
    /**
     * @param {?} defaultConfig
     * @param {?} config
     */
    constructor(defaultConfig, config) {
        this.messages = [];
        this.config = {};
        this.setConfig(Object.assign({}, defaultConfig, config));
    }
    /**
     * @param {?} config
     * @return {?}
     */
    setConfig(config) {
        this.config = Object.assign({}, this.config, config);
    }
    /**
     * @param {?} message
     * @return {?}
     */
    createMessage(message) {
        if (this.messages.length >= this.config.nzMaxStack) {
            this.messages.splice(0, 1);
        }
        message.options = this._mergeMessageOptions(message.options);
        this.messages.push(message);
    }
    /**
     * @param {?} messageId
     * @return {?}
     */
    removeMessage(messageId) {
        this.messages.some((message, index) => {
            if (message.messageId === messageId) {
                this.messages.splice(index, 1);
                return true;
            }
        });
    }
    /**
     * @return {?}
     */
    removeMessageAll() {
        this.messages = [];
    }
    /**
     * @param {?} options
     * @return {?}
     */
    _mergeMessageOptions(options) {
        const /** @type {?} */ defaultOptions = {
            nzDuration: this.config.nzDuration,
            nzAnimate: this.config.nzAnimate,
            nzPauseOnHover: this.config.nzPauseOnHover
        };
        return Object.assign({}, defaultOptions, options);
    }
}
NzMessageContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-message-container',
                preserveWhitespaces: false,
                template: `<div class="ant-message"> <nz-message *ngFor="let message of messages; let i = index" [nzMessage]="message" [nzIndex]="i"></nz-message> </div>`
            },] },
];
/** @nocollapse */
NzMessageContainerComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NZ_MESSAGE_DEFAULT_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NZ_MESSAGE_CONFIG,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMessageComponent {
    /**
     * @param {?} _messageContainer
     */
    constructor(_messageContainer) {
        this._messageContainer = _messageContainer;
        this._eraseTimer = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._options = this.nzMessage.options;
        if (this._options.nzAnimate) {
            this.nzMessage.state = 'enter';
        }
        this._autoErase = this._options.nzDuration > 0;
        if (this._autoErase) {
            this._initErase();
            this._startEraseTimeout();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._autoErase) {
            this._clearEraseTimeout();
        }
    }
    /**
     * @return {?}
     */
    onEnter() {
        if (this._autoErase && this._options.nzPauseOnHover) {
            this._clearEraseTimeout();
            this._updateTTL();
        }
    }
    /**
     * @return {?}
     */
    onLeave() {
        if (this._autoErase && this._options.nzPauseOnHover) {
            this._startEraseTimeout();
        }
    }
    /**
     * @return {?}
     */
    _destroy() {
        if (this._options.nzAnimate) {
            this.nzMessage.state = 'leave';
            setTimeout(() => this._messageContainer.removeMessage(this.nzMessage.messageId), 200);
        }
        else {
            this._messageContainer.removeMessage(this.nzMessage.messageId);
        }
    }
    /**
     * @return {?}
     */
    _initErase() {
        this._eraseTTL = this._options.nzDuration;
        this._eraseTimingStart = Date.now();
    }
    /**
     * @return {?}
     */
    _updateTTL() {
        if (this._autoErase) {
            this._eraseTTL -= Date.now() - this._eraseTimingStart;
        }
    }
    /**
     * @return {?}
     */
    _startEraseTimeout() {
        if (this._eraseTTL > 0) {
            this._clearEraseTimeout(); // To prevent calling _startEraseTimeout() more times to create more timer
            this._eraseTimer = window.setTimeout(() => this._destroy(), this._eraseTTL);
            this._eraseTimingStart = Date.now();
        }
        else {
            this._destroy();
        }
    }
    /**
     * @return {?}
     */
    _clearEraseTimeout() {
        if (this._eraseTimer !== null) {
            window.clearTimeout(this._eraseTimer);
            this._eraseTimer = null;
        }
    }
}
NzMessageComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-message',
                preserveWhitespaces: false,
                animations: [
                    trigger('enterLeave', [
                        state('enter', style({ opacity: 1, transform: 'translateY(0)' })),
                        transition('* => enter', [
                            style({ opacity: 0, transform: 'translateY(-50%)' }),
                            animate('100ms linear')
                        ]),
                        state('leave', style({ opacity: 0, transform: 'translateY(-50%)' })),
                        transition('* => leave', [
                            style({ opacity: 1, transform: 'translateY(0)' }),
                            animate('100ms linear')
                        ])
                    ])
                ],
                template: `<div class="ant-message-notice" [@enterLeave]="nzMessage.state" (mouseenter)="onEnter()" (mouseleave)="onLeave()"> <div class="ant-message-notice-content"> <div class="ant-message-custom-content" [ngClass]="'ant-message-' + nzMessage.type"> <ng-container [ngSwitch]="nzMessage.type"> <i *ngSwitchCase="'success'" class="anticon anticon-check-circle"></i> <i *ngSwitchCase="'info'" class="anticon anticon-info-circle"></i> <i *ngSwitchCase="'warning'" class="anticon anticon-exclamation-circle"></i> <i *ngSwitchCase="'error'" class="anticon anticon-cross-circle"></i> <i *ngSwitchCase="'loading'" class="anticon anticon-spin anticon-loading"></i> </ng-container> <span [innerHTML]="nzMessage.content"></span> </div> </div> </div>`
            },] },
];
/** @nocollapse */
NzMessageComponent.ctorParameters = () => [
    { type: NzMessageContainerComponent }
];
NzMessageComponent.propDecorators = {
    nzMessage: [{ type: Input }],
    nzIndex: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
let globalCounter = 0;
// unsupported: template constraints.
// unsupported: template constraints.
/**
 * @template ContainerClass, MessageData, MessageConfig
 */
class NzMessageBaseService {
    /**
     * @param {?} overlay
     * @param {?} containerClass
     * @param {?} injector
     * @param {?} cfr
     * @param {?} appRef
     * @param {?=} _idPrefix
     */
    constructor(overlay, containerClass, injector, cfr, appRef, _idPrefix = '') {
        this.overlay = overlay;
        this.containerClass = containerClass;
        this.injector = injector;
        this.cfr = cfr;
        this.appRef = appRef;
        this._idPrefix = _idPrefix;
        // this._container = overlay.create().attach(new ComponentPortal(containerClass)).instance;
        this._container = this.createContainer();
    }
    /**
     * @param {?=} messageId
     * @return {?}
     */
    remove(messageId) {
        if (messageId) {
            this._container.removeMessage(messageId);
        }
        else {
            this._container.removeMessageAll();
        }
    }
    /**
     * @param {?} message
     * @param {?=} options
     * @return {?}
     */
    createMessage(message, options) {
        // TODO: spread on literal has been disallow on latest proposal
        const /** @type {?} */ resultMessage = Object.assign({}, (/** @type {?} */ (message)), {
            messageId: this._generateMessageId(),
            options,
            createdAt: new Date()
        });
        this._container.createMessage(resultMessage);
        return resultMessage;
    }
    /**
     * @param {?} config
     * @return {?}
     */
    config(config) {
        this._container.setConfig(config);
    }
    /**
     * @return {?}
     */
    _generateMessageId() {
        return this._idPrefix + globalCounter++;
    }
    /**
     * @return {?}
     */
    createContainer() {
        const /** @type {?} */ factory = this.cfr.resolveComponentFactory(this.containerClass);
        const /** @type {?} */ componentRef = factory.create(this.injector); // Use root injector
        componentRef.changeDetectorRef.detectChanges(); // Immediately change detection to avoid multi-checking error
        this.appRef.attachView(componentRef.hostView); // Load view into app root
        const /** @type {?} */ overlayPane = this.overlay.create().overlayElement;
        overlayPane.style.zIndex = '1010'; // Patching: assign the same zIndex of ant-message to it's parent overlay panel, to the ant-message's zindex work.
        overlayPane.appendChild(/** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]));
        return componentRef.instance;
    }
}
class NzMessageService extends NzMessageBaseService {
    /**
     * @param {?} overlay
     * @param {?} injector
     * @param {?} cfr
     * @param {?} appRef
     */
    constructor(overlay, injector, cfr, appRef) {
        super(overlay, NzMessageContainerComponent, injector, cfr, appRef, 'message-');
    }
    /**
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    success(content, options) {
        return this.createMessage({ type: 'success', content }, options);
    }
    /**
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    error(content, options) {
        return this.createMessage({ type: 'error', content }, options);
    }
    /**
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    info(content, options) {
        return this.createMessage({ type: 'info', content }, options);
    }
    /**
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    warning(content, options) {
        return this.createMessage({ type: 'warning', content }, options);
    }
    /**
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    loading(content, options) {
        return this.createMessage({ type: 'loading', content }, options);
    }
    /**
     * @param {?} type
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    create(type, content, options) {
        return this.createMessage({ type, content }, options);
    }
}
NzMessageService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
];
/** @nocollapse */
NzMessageService.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ComponentFactoryResolver },
    { type: ApplicationRef }
];
/** @nocollapse */ NzMessageService.ngInjectableDef = defineInjectable({ factory: function NzMessageService_Factory() { return new NzMessageService(inject(Overlay), inject(INJECTOR), inject(ComponentFactoryResolver), inject(ApplicationRef)); }, token: NzMessageService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMessageModule {
}
NzMessageModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule],
                declarations: [NzMessageContainerComponent, NzMessageComponent],
                providers: [NZ_MESSAGE_DEFAULT_CONFIG_PROVIDER, NzMessageService],
                entryComponents: [NzMessageContainerComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CssUnitPipe {
    /**
     * @param {?} value
     * @param {?=} defaultUnit
     * @return {?}
     */
    transform(value, defaultUnit = 'px') {
        const /** @type {?} */ formatted = +value; // force convert
        return isNaN(formatted) ? `${value}` : `${formatted}${defaultUnit}`;
    }
}
CssUnitPipe.decorators = [
    { type: Pipe, args: [{
                name: 'toCssUnit'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzModalControlService {
    /**
     * @param {?} parentService
     */
    constructor(parentService) {
        this.parentService = parentService;
        this.rootOpenModals = this.parentService ? null : [];
        this.rootAfterAllClose = this.parentService ? null : new Subject();
        this.rootRegisteredMetaMap = this.parentService ? null : new Map();
    }
    /**
     * @return {?}
     */
    get afterAllClose() {
        return this.parentService ? this.parentService.afterAllClose : this.rootAfterAllClose;
    }
    /**
     * @return {?}
     */
    get openModals() {
        return this.parentService ? this.parentService.openModals : this.rootOpenModals;
    }
    /**
     * @return {?}
     */
    get registeredMetaMap() {
        // Registered modal for later usage
        return this.parentService ? this.parentService.registeredMetaMap : this.rootRegisteredMetaMap;
    }
    /**
     * @param {?} modalRef
     * @return {?}
     */
    registerModal(modalRef) {
        if (!this.hasRegistered(modalRef)) {
            const /** @type {?} */ afterOpenSubscription = modalRef.afterOpen.subscribe(() => this.openModals.push(modalRef));
            const /** @type {?} */ afterCloseSubscription = modalRef.afterClose.subscribe(() => this.removeOpenModal(modalRef));
            this.registeredMetaMap.set(modalRef, { modalRef, afterOpenSubscription, afterCloseSubscription });
        }
    }
    /**
     * @param {?} modalRef
     * @return {?}
     */
    hasRegistered(modalRef) {
        return this.registeredMetaMap.has(modalRef);
    }
    /**
     * @return {?}
     */
    closeAll() {
        let /** @type {?} */ i = this.openModals.length;
        while (i--) {
            this.openModals[i].close();
        }
    }
    /**
     * @param {?} modalRef
     * @return {?}
     */
    removeOpenModal(modalRef) {
        const /** @type {?} */ index = this.openModals.indexOf(modalRef);
        if (index > -1) {
            this.openModals.splice(index, 1);
            if (!this.openModals.length) {
                this.afterAllClose.next();
            }
        }
    }
}
NzModalControlService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NzModalControlService.ctorParameters = () => [
    { type: NzModalControlService, decorators: [{ type: Optional }, { type: SkipSelf }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzMeasureScrollbarService {
    /**
     * @param {?} document
     */
    constructor(document) {
        this.document = document;
        this.scrollbarMeasure = {
            position: 'absolute',
            top: '-9999px',
            width: '50px',
            height: '50px',
            overflow: 'scroll'
        };
        this.initScrollBarWidth();
    }
    /**
     * @return {?}
     */
    get scrollBarWidth() {
        if (isNotNil(this._scrollbarWidth)) {
            return this._scrollbarWidth;
        }
        this.initScrollBarWidth();
        return this._scrollbarWidth;
    }
    /**
     * @return {?}
     */
    initScrollBarWidth() {
        const /** @type {?} */ scrollDiv = this.document.createElement('div');
        for (const /** @type {?} */ scrollProp in this.scrollbarMeasure) {
            if (this.scrollbarMeasure.hasOwnProperty(scrollProp)) {
                scrollDiv.style[scrollProp] = this.scrollbarMeasure[scrollProp];
            }
        }
        this.document.body.appendChild(scrollDiv);
        const /** @type {?} */ width = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.document.body.removeChild(scrollDiv);
        this._scrollbarWidth = width;
    }
}
NzMeasureScrollbarService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] },
];
/** @nocollapse */
NzMeasureScrollbarService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
/** @nocollapse */ NzMeasureScrollbarService.ngInjectableDef = defineInjectable({ factory: function NzMeasureScrollbarService_Factory() { return new NzMeasureScrollbarService(inject(DOCUMENT)); }, token: NzMeasureScrollbarService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class ModalUtil {
    /**
     * @param {?} document
     */
    constructor(document) {
        this.document = document;
        this.lastPosition = null;
        this.listenDocumentClick();
    }
    /**
     * @return {?}
     */
    getLastClickPosition() {
        return this.lastPosition;
    }
    /**
     * @return {?}
     */
    listenDocumentClick() {
        this.document.addEventListener('click', (event) => {
            this.lastPosition = { x: event.clientX, y: event.clientY };
        });
    }
}
var ModalUtil$1 = new ModalUtil(document);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * API class that public to users to handle the modal instance.
 * NzModalRef is aim to avoid accessing to the modal instance directly by users.
 * @abstract
 * @template T, R
 */
class NzModalRef {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MODAL_ANIMATE_DURATION = 200;
/**
 * @template T, R
 */
// tslint:disable-next-line:no-any
class NzModalComponent extends NzModalRef {
    /**
     * @param {?} overlay
     * @param {?} i18n
     * @param {?} renderer
     * @param {?} cfr
     * @param {?} elementRef
     * @param {?} viewContainer
     * @param {?} nzMeasureScrollbarService
     * @param {?} modalControl
     * @param {?} document
     */
    constructor(overlay, i18n, renderer, cfr, elementRef, viewContainer, nzMeasureScrollbarService, modalControl, document) {
        // tslint:disable-line:no-any
        super();
        this.overlay = overlay;
        this.i18n = i18n;
        this.renderer = renderer;
        this.cfr = cfr;
        this.elementRef = elementRef;
        this.viewContainer = viewContainer;
        this.nzMeasureScrollbarService = nzMeasureScrollbarService;
        this.modalControl = modalControl;
        this.document = document;
        this.unsubscribe$ = new Subject();
        // tslint:disable-next-line:no-any
        this.locale = {};
        this.nzModalType = 'default';
        this.nzGetContainer = () => this.overlay.create();
        this.nzVisible = false;
        this.nzVisibleChange = new EventEmitter();
        this.nzZIndex = 1000;
        this.nzWidth = 520;
        this.nzIconType = 'question-circle';
        this.nzClosable = true;
        this.nzMask = true;
        this.nzMaskClosable = true;
        this.nzAfterOpen = new EventEmitter();
        this.nzAfterClose = new EventEmitter();
        this.nzOkType = 'primary';
        this.nzOkLoading = false;
        this.nzOnOk = new EventEmitter();
        this.nzCancelLoading = false;
        this.nzOnCancel = new EventEmitter();
        this.transformOrigin = '0px 0px 0px';
    }
    /**
     * @return {?}
     */
    get afterOpen() {
        // Observable alias for nzAfterOpen
        return this.nzAfterOpen.asObservable();
    }
    /**
     * @return {?}
     */
    get afterClose() {
        // Observable alias for nzAfterClose
        return this.nzAfterClose.asObservable();
    }
    /**
     * @return {?}
     */
    get okText() {
        return this.nzOkText || this.locale.okText;
    }
    /**
     * @return {?}
     */
    get cancelText() {
        return this.nzCancelText || this.locale.cancelText;
    }
    /**
     * @return {?}
     */
    get hidden() {
        return !this.nzVisible && !this.animationState;
    } // Indicate whether this dialog should hidden
    /**
     * @return {?}
     */
    ngOnInit() {
        this.i18n.localeChange.pipe(takeUntil(this.unsubscribe$)).subscribe(() => this.locale = this.i18n.getLocaleData('Modal'));
        if (this.isComponent(this.nzContent)) {
            this.createDynamicComponent(/** @type {?} */ (this.nzContent)); // Create component along without View
        }
        if (this.isModalButtons(this.nzFooter)) {
            // Setup default button options
            this.nzFooter = this.formatModalButtons(/** @type {?} */ (this.nzFooter));
        }
        // Place the modal dom to elsewhere
        this.container = typeof this.nzGetContainer === 'function' ? this.nzGetContainer() : this.nzGetContainer;
        if (this.container instanceof HTMLElement) {
            this.container.appendChild(this.elementRef.nativeElement);
        }
        else if (this.container instanceof OverlayRef) {
            // NOTE: only attach the dom to overlay, the view container is not changed actually
            this.container.overlayElement.appendChild(this.elementRef.nativeElement);
        }
        // Register modal when afterOpen/afterClose is stable
        this.modalControl.registerModal(this);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["nzVisible"]) {
            this.handleVisibleStateChange(this.nzVisible, !changes["nzVisible"].firstChange); // Do not trigger animation while initializing
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // If using Component, it is the time to attach View while bodyContainer is ready
        if (this.contentComponentRef) {
            this.bodyContainer.insert(this.contentComponentRef.hostView);
        }
        if (this.autoFocusButtonOk) {
            (/** @type {?} */ (this.autoFocusButtonOk.nativeElement)).focus();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.container instanceof OverlayRef) {
            this.container.dispose();
        }
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    /**
     * @return {?}
     */
    open() {
        this.changeVisibleFromInside(true);
    }
    /**
     * @param {?=} result
     * @return {?}
     */
    close(result) {
        this.changeVisibleFromInside(false, result);
    }
    /**
     * @param {?=} result
     * @return {?}
     */
    destroy(result) {
        // Destroy equals Close
        this.close(result);
    }
    /**
     * @return {?}
     */
    triggerOk() {
        this.onClickOkCancel('ok');
    }
    /**
     * @return {?}
     */
    triggerCancel() {
        this.onClickOkCancel('cancel');
    }
    /**
     * @return {?}
     */
    getInstance() {
        return this;
    }
    /**
     * @return {?}
     */
    getContentComponentRef() {
        return this.contentComponentRef;
    }
    /**
     * @return {?}
     */
    getContentComponent() {
        return this.contentComponentRef && this.contentComponentRef.instance;
    }
    /**
     * @return {?}
     */
    getElement() {
        return this.elementRef && this.elementRef.nativeElement;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onClickMask($event) {
        if (this.nzMask &&
            this.nzMaskClosable &&
            (/** @type {?} */ ($event.target)).classList.contains('ant-modal-wrap') &&
            this.nzVisible) {
            this.onClickOkCancel('cancel');
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    isModalType(type) {
        return this.nzModalType === type;
    }
    /**
     * @return {?}
     */
    onClickCloseBtn() {
        if (this.nzVisible) {
            this.onClickOkCancel('cancel');
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    onClickOkCancel(type) {
        const /** @type {?} */ trigger$$1 = { 'ok': this.nzOnOk, 'cancel': this.nzOnCancel }[type];
        const /** @type {?} */ loadingKey = { 'ok': 'nzOkLoading', 'cancel': 'nzCancelLoading' }[type];
        if (trigger$$1 instanceof EventEmitter) {
            trigger$$1.emit(this.getContentComponent());
        }
        else if (typeof trigger$$1 === 'function') {
            const /** @type {?} */ result = trigger$$1(this.getContentComponent());
            const /** @type {?} */ caseClose = (doClose) => (doClose !== false) && this.close(/** @type {?} */ (doClose)); // Users can return "false" to prevent closing by default
            if (isPromise(result)) {
                this[loadingKey] = true;
                const /** @type {?} */ handleThen = (doClose) => {
                    this[loadingKey] = false;
                    caseClose(doClose);
                };
                (/** @type {?} */ (result)).then(handleThen).catch(handleThen);
            }
            else {
                caseClose(result);
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isNonEmptyString(value) {
        return typeof value === 'string' && value !== '';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isTemplateRef(value) {
        return value instanceof TemplateRef;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isComponent(value) {
        return value instanceof Type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isModalButtons(value) {
        return Array.isArray(value) && value.length > 0;
    }
    /**
     * @param {?} visible
     * @param {?=} animation
     * @param {?=} closeResult
     * @return {?}
     */
    handleVisibleStateChange(visible, animation = true, closeResult) {
        if (visible) {
            // Hide scrollbar at the first time when shown up
            this.changeBodyOverflow(1);
        }
        return Promise
            .resolve(animation && this.animateTo(visible))
            .then(() => {
            // Emit open/close event after animations over
            if (visible) {
                this.nzAfterOpen.emit();
            }
            else {
                this.nzAfterClose.emit(closeResult);
                this.changeBodyOverflow(); // Show/hide scrollbar when animation is over
            }
        });
        // .then(() => this.changeBodyOverflow());
    }
    /**
     * @param {?} options
     * @param {?} prop
     * @return {?}
     */
    getButtonCallableProp(options, prop) {
        const /** @type {?} */ value = options[prop];
        const /** @type {?} */ args = [];
        if (this.contentComponentRef) {
            args.push(this.contentComponentRef.instance);
        }
        return typeof value === 'function' ? value.apply(options, args) : value;
    }
    /**
     * @param {?} button
     * @return {?}
     */
    onButtonClick(button) {
        const /** @type {?} */ result = this.getButtonCallableProp(button, 'onClick'); // Call onClick directly
        if (isPromise(result)) {
            button.loading = true;
            (/** @type {?} */ (result)).then(() => button.loading = false).catch(() => button.loading = false);
        }
    }
    /**
     * @param {?} visible
     * @param {?=} closeResult
     * @return {?}
     */
    changeVisibleFromInside(visible, closeResult) {
        if (this.nzVisible !== visible) {
            // Change nzVisible value immediately
            this.nzVisible = visible;
            this.nzVisibleChange.emit(visible);
            return this.handleVisibleStateChange(visible, true, closeResult);
        }
        return Promise.resolve();
    }
    /**
     * @param {?} state
     * @return {?}
     */
    changeAnimationState(state$$1) {
        this.animationState = state$$1;
        if (state$$1) {
            this.maskAnimationClassMap = {
                [`fade-${state$$1}`]: true,
                [`fade-${state$$1}-active`]: true
            };
            this.modalAnimationClassMap = {
                [`zoom-${state$$1}`]: true,
                [`zoom-${state$$1}-active`]: true
            };
        }
        else {
            this.maskAnimationClassMap = this.modalAnimationClassMap = null;
        }
    }
    /**
     * @param {?} isVisible
     * @return {?}
     */
    animateTo(isVisible) {
        if (isVisible) {
            // Figure out the lastest click position when shows up
            window.setTimeout(() => this.updateTransformOrigin()); // [NOTE] Using timeout due to the document.click event is fired later than visible change, so if not postponed to next event-loop, we can't get the lastest click position
        }
        this.changeAnimationState(isVisible ? 'enter' : 'leave');
        return new Promise((resolve) => window.setTimeout(() => {
            // Return when animation is over
            this.changeAnimationState(null);
            resolve();
        }, MODAL_ANIMATE_DURATION));
    }
    /**
     * @param {?} buttons
     * @return {?}
     */
    formatModalButtons(buttons) {
        return buttons.map((button) => {
            const /** @type {?} */ mixedButton = Object.assign({
                type: 'default',
                size: 'default',
                autoLoading: true,
                show: true,
                loading: false,
                disabled: false
            }, button);
            // if (mixedButton.autoLoading) { mixedButton.loading = false; } // Force loading to false when autoLoading=true
            return mixedButton;
        });
    }
    /**
     * Create a component dynamically but not attach to any View (this action will be executed when bodyContainer is ready)
     * @param {?} component Component class
     * @return {?}
     */
    createDynamicComponent(component) {
        const /** @type {?} */ factory = this.cfr.resolveComponentFactory(component);
        const /** @type {?} */ childInjector = Injector.create({
            providers: [{ provide: NzModalRef, useValue: this }],
            parent: this.viewContainer.parentInjector
        });
        this.contentComponentRef = factory.create(childInjector);
        if (this.nzComponentParams) {
            Object.assign(this.contentComponentRef.instance, this.nzComponentParams);
        }
        // Do the first change detection immediately (or we do detection at ngAfterViewInit, multi-changes error will be thrown)
        this.contentComponentRef.changeDetectorRef.detectChanges();
    }
    /**
     * @return {?}
     */
    updateTransformOrigin() {
        const /** @type {?} */ modalElement = /** @type {?} */ (this.modalContainer.nativeElement);
        const /** @type {?} */ lastPosition = ModalUtil$1.getLastClickPosition();
        if (lastPosition) {
            this.transformOrigin = `${lastPosition.x - modalElement.offsetLeft}px ${lastPosition.y - modalElement.offsetTop}px 0px`;
        }
        // else {
        //   this.transformOrigin = '0px 0px 0px';
        // }
    }
    /**
     * Take care of the body's overflow to decide the existense of scrollbar
     * @param {?=} plusNum The number that the openModals.length will increase soon
     * @return {?}
     */
    changeBodyOverflow(plusNum = 0) {
        const /** @type {?} */ openModals = this.modalControl.openModals;
        if (openModals.length + plusNum > 0) {
            this.renderer.setStyle(this.document.body, 'padding-right', `${this.nzMeasureScrollbarService.scrollBarWidth}px`);
            this.renderer.setStyle(this.document.body, 'overflow', 'hidden');
        }
        else {
            this.renderer.removeStyle(this.document.body, 'padding-right');
            this.renderer.removeStyle(this.document.body, 'overflow');
        }
    }
}
NzModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-modal',
                template: `<ng-template #tplOriginContent><ng-content></ng-content></ng-template> <!-- Compatible: the <ng-content> can appear only once --> <div> <div *ngIf="nzMask" class="ant-modal-mask" [ngClass]="maskAnimationClassMap" [class.ant-modal-mask-hidden]="hidden" [ngStyle]="nzMaskStyle" [style.zIndex]="nzZIndex" ></div> <div (click)="onClickMask($event)" class="ant-modal-wrap {{ nzWrapClassName }}" [style.zIndex]="nzZIndex" [style.display]="hidden ? 'none' : ''" tabindex="-1" role="dialog" > <div #modalContainer class="ant-modal {{ nzClassName }}" [ngClass]="modalAnimationClassMap" [ngStyle]="nzStyle" [style.width]="nzWidth | toCssUnit" [style.transform-origin]="transformOrigin" role="document" > <div class="ant-modal-content"> <button *ngIf="nzClosable" (click)="onClickCloseBtn($event)" class="ant-modal-close" aria-label="Close"> <span class="ant-modal-close-x"></span> </button> <ng-container [ngSwitch]="true"> <ng-container *ngSwitchCase="isModalType('default')" [ngTemplateOutlet]="tplContentDefault"></ng-container> <ng-container *ngSwitchCase="isModalType('confirm')" [ngTemplateOutlet]="tplContentConfirm"></ng-container> </ng-container> </div> </div> <div tabindex="0" style="width: 0px; height: 0px; overflow: hidden;">sentinel</div> </div> </div> <!-- [Predefined] Default Modal Content --> <ng-template #tplContentDefault> <div *ngIf="nzTitle" class="ant-modal-header"> <div class="ant-modal-title"> <ng-container [ngSwitch]="true"> <ng-container *ngSwitchCase="isTemplateRef(nzTitle)" [ngTemplateOutlet]="nzTitle"></ng-container> <ng-container *ngSwitchCase="isNonEmptyString(nzTitle)"><div [innerHTML]="nzTitle"></div></ng-container> </ng-container> </div> </div> <div class="ant-modal-body" [ngStyle]="nzBodyStyle"> <ng-container #bodyContainer> <ng-container *ngIf="!isComponent(nzContent)" [ngSwitch]="true"> <ng-container *ngSwitchCase="isTemplateRef(nzContent)" [ngTemplateOutlet]="nzContent"></ng-container> <ng-container *ngSwitchCase="isNonEmptyString(nzContent)"><div [innerHTML]="nzContent"></div></ng-container> <ng-container *ngSwitchDefault [ngTemplateOutlet]="tplOriginContent"></ng-container> </ng-container> </ng-container> </div> <div *ngIf="nzFooter !== null" class="ant-modal-footer"> <ng-container [ngSwitch]="true"> <ng-container *ngSwitchCase="isTemplateRef(nzFooter)" [ngTemplateOutlet]="nzFooter"></ng-container> <ng-container *ngSwitchCase="isNonEmptyString(nzFooter)"><div [innerHTML]="nzFooter"></div></ng-container> <ng-container *ngSwitchCase="isModalButtons(nzFooter)"> <button *ngFor="let button of nzFooter" nz-button (click)="onButtonClick(button)" [hidden]="!getButtonCallableProp(button, 'show')" [nzLoading]="getButtonCallableProp(button, 'loading')" [disabled]="getButtonCallableProp(button, 'disabled')" [nzType]="button.type" [nzShape]="button.shape" [nzSize]="button.size" [nzGhost]="button.ghost" >{{ button.label }}</button> </ng-container> <ng-container *ngSwitchDefault> <button *ngIf="nzCancelText!==null" nz-button (click)="onClickOkCancel('cancel')" [nzLoading]="nzCancelLoading"> {{ cancelText }} </button> <button *ngIf="nzOkText!==null" nz-button [nzType]="nzOkType" (click)="onClickOkCancel('ok')" [nzLoading]="nzOkLoading"> {{ okText }} </button> </ng-container> </ng-container> </div> </ng-template> <!-- /[Predefined] Default Modal Content --> <!-- [Predefined] Confirm Modal Content --> <ng-template #tplContentConfirm> <div class="ant-modal-body" [ngStyle]="nzBodyStyle"> <div class="ant-confirm-body-wrapper"> <div class="ant-confirm-body"> <i class="anticon anticon-{{ nzIconType }}"></i> <span class="ant-confirm-title"> <ng-container [ngSwitch]="true"> <ng-container *ngSwitchCase="isTemplateRef(nzTitle)" [ngTemplateOutlet]="nzTitle"></ng-container> <ng-container *ngSwitchCase="isNonEmptyString(nzTitle)"><span [innerHTML]="nzTitle"></span></ng-container> </ng-container> </span> <div class="ant-confirm-content"> <ng-container #bodyContainer> <ng-container *ngIf="!isComponent(nzContent)" [ngSwitch]="true"> <ng-container *ngSwitchCase="isTemplateRef(nzContent)" [ngTemplateOutlet]="nzContent"></ng-container> <ng-container *ngSwitchCase="isNonEmptyString(nzContent)"><div [innerHTML]="nzContent"></div></ng-container> <ng-container *ngSwitchDefault [ngTemplateOutlet]="tplOriginContent"></ng-container> </ng-container> </ng-container> </div> </div> <div class="ant-confirm-btns"> <button nz-button *ngIf="nzCancelText!==null" (click)="onClickOkCancel('cancel')" [nzLoading]="nzCancelLoading"> {{ cancelText }} </button> <button *ngIf="nzOkText!==null" #autoFocusButtonOk nz-button [nzType]="nzOkType" (click)="onClickOkCancel('ok')" [nzLoading]="nzOkLoading"> {{ okText }} </button> </div> </div> <!-- /.ant-confirm-body-wrapper --> </div> </ng-template> <!-- /[Predefined] Confirm Modal Content --> `
            },] },
];
/** @nocollapse */
NzModalComponent.ctorParameters = () => [
    { type: Overlay },
    { type: NzI18nService },
    { type: Renderer2 },
    { type: ComponentFactoryResolver },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: NzMeasureScrollbarService },
    { type: NzModalControlService },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
NzModalComponent.propDecorators = {
    nzModalType: [{ type: Input }],
    nzContent: [{ type: Input }],
    nzComponentParams: [{ type: Input }],
    nzFooter: [{ type: Input }],
    nzGetContainer: [{ type: Input }],
    nzVisible: [{ type: Input }],
    nzVisibleChange: [{ type: Output }],
    nzZIndex: [{ type: Input }],
    nzWidth: [{ type: Input }],
    nzWrapClassName: [{ type: Input }],
    nzClassName: [{ type: Input }],
    nzStyle: [{ type: Input }],
    nzIconType: [{ type: Input }],
    nzTitle: [{ type: Input }],
    nzClosable: [{ type: Input }],
    nzMask: [{ type: Input }],
    nzMaskClosable: [{ type: Input }],
    nzMaskStyle: [{ type: Input }],
    nzBodyStyle: [{ type: Input }],
    nzAfterOpen: [{ type: Output }],
    nzAfterClose: [{ type: Output }],
    nzOkText: [{ type: Input }],
    nzOkType: [{ type: Input }],
    nzOkLoading: [{ type: Input }],
    nzOnOk: [{ type: Input }, { type: Output }],
    autoFocusButtonOk: [{ type: ViewChild, args: ['autoFocusButtonOk', { read: ElementRef },] }],
    nzCancelText: [{ type: Input }],
    nzCancelLoading: [{ type: Input }],
    nzOnCancel: [{ type: Input }, { type: Output }],
    modalContainer: [{ type: ViewChild, args: ['modalContainer',] }],
    bodyContainer: [{ type: ViewChild, args: ['bodyContainer', { read: ViewContainerRef },] }]
};
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], NzModalComponent.prototype, "nzVisible", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], NzModalComponent.prototype, "nzClosable", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], NzModalComponent.prototype, "nzMask", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], NzModalComponent.prototype, "nzMaskClosable", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], NzModalComponent.prototype, "nzOkLoading", void 0);
__decorate([
    InputBoolean(),
    __metadata("design:type", Boolean)
], NzModalComponent.prototype, "nzCancelLoading", void 0);
/**
 * @param {?} obj
 * @return {?}
 */
function isPromise(obj) {
    return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof (/** @type {?} */ (obj)).then === 'function' && typeof (/** @type {?} */ (obj)).catch === 'function';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ModalBuilderForService {
    /**
     * @param {?} overlay
     * @param {?=} options
     */
    constructor(overlay, options = {}) {
        this.overlay = overlay;
        this.createModal();
        if (!('nzGetContainer' in options)) {
            // As we use CDK to create modal in service by force, there is no need to use nzGetContainer
            options.nzGetContainer = null; // Override nzGetContainer's default value to prevent creating another overlay
        }
        this.changeProps(options);
        this.modalRef.instance.open();
        this.modalRef.instance.nzAfterClose.subscribe(() => this.destroyModal()); // [NOTE] By default, close equals destroy when using as Service
    }
    /**
     * @return {?}
     */
    getInstance() {
        return this.modalRef && this.modalRef.instance;
    }
    /**
     * @return {?}
     */
    destroyModal() {
        if (this.modalRef) {
            this.overlayRef.dispose();
            this.modalRef = null;
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    changeProps(options) {
        if (this.modalRef) {
            Object.assign(this.modalRef.instance, options); // DANGER: here not limit user's inputs at runtime
        }
    }
    /**
     * @return {?}
     */
    createModal() {
        this.overlayRef = this.overlay.create();
        this.modalRef = this.overlayRef.attach(new ComponentPortal(NzModalComponent));
    }
}
class NzModalService {
    /**
     * @param {?} overlay
     * @param {?} logger
     * @param {?} modalControl
     */
    constructor(overlay, logger, modalControl) {
        this.overlay = overlay;
        this.logger = logger;
        this.modalControl = modalControl;
    }
    /**
     * @return {?}
     */
    get openModals() {
        return this.modalControl.openModals;
    }
    /**
     * @return {?}
     */
    get afterAllClose() {
        return this.modalControl.afterAllClose.asObservable();
    }
    /**
     * @return {?}
     */
    closeAll() {
        this.modalControl.closeAll();
    }
    /**
     * @template T
     * @param {?=} options
     * @return {?}
     */
    create(options = {}) {
        if (typeof options.nzOnCancel !== 'function') {
            options.nzOnCancel = () => {
            }; // Leave a empty function to close this modal by default
        }
        const /** @type {?} */ modalRef = new ModalBuilderForService(this.overlay, options).getInstance(); // NOTE: use NzModalComponent as the NzModalRef by now, we may need archive the real NzModalRef object in the future
        return modalRef;
    }
    /**
     * @template T
     * @param {?=} options
     * @param {?=} confirmType
     * @return {?}
     */
    confirm(options = {}, confirmType = 'confirm') {
        if ('nzFooter' in options) {
            this.logger.warn(`The Confirm-Modal doesn't support "nzFooter", this property will be ignored.`);
        }
        if (!('nzWidth' in options)) {
            options.nzWidth = 416;
        }
        if (typeof options.nzOnOk !== 'function') {
            // NOTE: only support function currently by calling confirm()
            options.nzOnOk = () => {
            }; // Leave a empty function to close this modal by default
        }
        options.nzModalType = 'confirm';
        options.nzClassName = `ant-confirm ant-confirm-${confirmType} ${options.nzClassName || ''}`;
        options.nzMaskClosable = false;
        return this.create(options);
    }
    /**
     * @template T
     * @param {?=} options
     * @return {?}
     */
    info(options = {}) {
        return this.simpleConfirm(options, 'info');
    }
    /**
     * @template T
     * @param {?=} options
     * @return {?}
     */
    success(options = {}) {
        return this.simpleConfirm(options, 'success');
    }
    /**
     * @template T
     * @param {?=} options
     * @return {?}
     */
    error(options = {}) {
        return this.simpleConfirm(options, 'error');
    }
    /**
     * @template T
     * @param {?=} options
     * @return {?}
     */
    warning(options = {}) {
        return this.simpleConfirm(options, 'warning');
    }
    /**
     * @template T
     * @param {?=} options
     * @param {?=} confirmType
     * @return {?}
     */
    simpleConfirm(options = {}, confirmType) {
        if (!('nzIconType' in options)) {
            options.nzIconType = {
                'info': 'info-circle',
                'success': 'check-circle',
                'error': 'cross-circle',
                'warning': 'exclamation-circle'
            }[confirmType];
        }
        if (!('nzCancelText' in options)) {
            // Remove the Cancel button if the user not specify a Cancel button
            options.nzCancelText = null;
        }
        return this.confirm(options, confirmType);
    }
}
NzModalService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NzModalService.ctorParameters = () => [
    { type: Overlay },
    { type: LoggerService },
    { type: NzModalControlService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzModalModule {
}
NzModalModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule, NzI18nModule, NzButtonModule, LoggerModule],
                exports: [NzModalComponent],
                declarations: [NzModalComponent, CssUnitPipe],
                entryComponents: [NzModalComponent],
                providers: [NzModalControlService, NzModalService]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

const NZ_NOTIFICATION_DEFAULT_CONFIG = new InjectionToken('NZ_NOTIFICATION_DEFAULT_CONFIG');
const NZ_NOTIFICATION_CONFIG = new InjectionToken('NZ_NOTIFICATION_CONFIG');
const NZ_NOTIFICATION_DEFAULT_CONFIG_PROVIDER = {
    provide: NZ_NOTIFICATION_DEFAULT_CONFIG,
    useValue: {
        nzTop: '24px',
        nzBottom: '24px',
        nzPlacement: 'topRight',
        nzDuration: 4500,
        nzMaxStack: 7,
        nzPauseOnHover: true,
        nzAnimate: true
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzNotificationContainerComponent extends NzMessageContainerComponent {
    /**
     * @param {?} defaultConfig
     * @param {?} config
     */
    constructor(defaultConfig, config) {
        super(defaultConfig, config);
    }
}
NzNotificationContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-notification-container',
                preserveWhitespaces: false,
                template: `<div class="ant-notification ant-notification-{{config.nzPlacement}}" [style.top]="(config.nzPlacement==='topLeft'||config.nzPlacement=='topRight')? config.nzTop:null" [style.bottom]="(config.nzPlacement==='bottomLeft'||config.nzPlacement=='bottomRight')? config.nzBottom:null" [style.right]="(config.nzPlacement==='bottomRight'||config.nzPlacement=='topRight')?'0px':null" [style.left]="(config.nzPlacement==='topLeft'||config.nzPlacement=='bottomLeft')?'0px':null"> <nz-notification *ngFor="let message of messages; let i = index" [nzMessage]="message" [nzIndex]="i"></nz-notification> </div>`
            },] },
];
/** @nocollapse */
NzNotificationContainerComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NZ_NOTIFICATION_DEFAULT_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NZ_NOTIFICATION_CONFIG,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzNotificationComponent extends NzMessageComponent {
    /**
     * @param {?} container
     */
    constructor(container) {
        super(container);
        this.container = container;
    }
    /**
     * @return {?}
     */
    close() {
        this._destroy();
    }
    /**
     * @return {?}
     */
    get state() {
        if (this.nzMessage.state === 'enter') {
            if ((this.container.config["nzPlacement"] === 'topLeft') || (this.container.config["nzPlacement"] === 'bottomLeft')) {
                return 'enterLeft';
            }
            else {
                return 'enterRight';
            }
        }
        else {
            return this.nzMessage.state;
        }
    }
}
NzNotificationComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-notification',
                preserveWhitespaces: false,
                animations: [
                    trigger('enterLeave', [
                        state('enterRight', style({ opacity: 1, transform: 'translateX(0)' })),
                        transition('* => enterRight', [
                            style({ opacity: 0, transform: 'translateX(5%)' }),
                            animate('100ms linear')
                        ]),
                        state('enterLeft', style({ opacity: 1, transform: 'translateX(0)' })),
                        transition('* => enterLeft', [
                            style({ opacity: 0, transform: 'translateX(-5%)' }),
                            animate('100ms linear')
                        ]),
                        state('leave', style({
                            opacity: 0,
                            transform: 'scaleY(0.8)',
                            transformOrigin: '0% 0%'
                        })),
                        transition('* => leave', [
                            style({
                                opacity: 1,
                                transform: 'scaleY(1)',
                                transformOrigin: '0% 0%'
                            }),
                            animate('100ms linear')
                        ])
                    ])
                ],
                template: `<div class="ant-notification-notice ant-notification-notice-closable" [ngStyle]="nzMessage.options.nzStyle" [ngClass]="nzMessage.options.nzClass" [@enterLeave]="state" (mouseenter)="onEnter()" (mouseleave)="onLeave()"> <div *ngIf="!nzMessage.template" class="ant-notification-notice-content"> <div class="ant-notification-notice-content" [ngClass]="{ 'ant-notification-notice-with-icon': nzMessage.type !== 'blank' }"> <div [class.ant-notification-notice-with-icon]="nzMessage.type !== 'blank'"> <ng-container [ngSwitch]="nzMessage.type"> <i *ngSwitchCase="'success'" class="ant-notification-notice-icon ant-notification-notice-icon-success anticon anticon-check-circle-o"></i> <i *ngSwitchCase="'info'" class="ant-notification-notice-icon ant-notification-notice-icon-info anticon anticon-info-circle-o"></i> <i *ngSwitchCase="'warning'" class="ant-notification-notice-icon ant-notification-notice-icon-warning anticon anticon-exclamation-circle-o"></i> <i *ngSwitchCase="'error'" class="ant-notification-notice-icon ant-notification-notice-icon-error anticon anticon-cross-circle-o"></i> </ng-container> <div class="ant-notification-notice-message" [innerHTML]="nzMessage.title"></div> <div class="ant-notification-notice-description" [innerHTML]="nzMessage.content"></div> </div> </div> </div> <ng-template [ngIf]="nzMessage.template" [ngTemplateOutlet]="nzMessage.template" [ngTemplateOutletContext]="{ $implicit: this }"></ng-template> <a tabindex="0" class="ant-notification-notice-close" (click)="close()"> <span class="ant-notification-notice-close-x"></span> </a> </div>`
            },] },
];
/** @nocollapse */
NzNotificationComponent.ctorParameters = () => [
    { type: NzNotificationContainerComponent }
];
NzNotificationComponent.propDecorators = {
    nzMessage: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzNotificationService extends NzMessageBaseService {
    /**
     * @param {?} overlay
     * @param {?} injector
     * @param {?} cfr
     * @param {?} appRef
     */
    constructor(overlay, injector, cfr, appRef) {
        super(overlay, NzNotificationContainerComponent, injector, cfr, appRef, 'notification-');
    }
    /**
     * @param {?} title
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    success(title, content, options) {
        return /** @type {?} */ (this.createMessage({ type: 'success', title, content }, options));
    }
    /**
     * @param {?} title
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    error(title, content, options) {
        return /** @type {?} */ (this.createMessage({ type: 'error', title, content }, options));
    }
    /**
     * @param {?} title
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    info(title, content, options) {
        return /** @type {?} */ (this.createMessage({ type: 'info', title, content }, options));
    }
    /**
     * @param {?} title
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    warning(title, content, options) {
        return /** @type {?} */ (this.createMessage({ type: 'warning', title, content }, options));
    }
    /**
     * @param {?} title
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    blank(title, content, options) {
        return /** @type {?} */ (this.createMessage({ type: 'blank', title, content }, options));
    }
    /**
     * @param {?} type
     * @param {?} title
     * @param {?} content
     * @param {?=} options
     * @return {?}
     */
    create(type, title, content, options) {
        return /** @type {?} */ (this.createMessage({ type, title, content }, options));
    }
    /**
     * @param {?} template
     * @param {?=} options
     * @return {?}
     */
    template(template, options) {
        return /** @type {?} */ (this.createMessage({ template }, options));
    }
}
NzNotificationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
];
/** @nocollapse */
NzNotificationService.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: ComponentFactoryResolver },
    { type: ApplicationRef }
];
/** @nocollapse */ NzNotificationService.ngInjectableDef = defineInjectable({ factory: function NzNotificationService_Factory() { return new NzNotificationService(inject(Overlay), inject(INJECTOR), inject(ComponentFactoryResolver), inject(ApplicationRef)); }, token: NzNotificationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzNotificationModule {
}
NzNotificationModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule],
                declarations: [NzNotificationComponent, NzNotificationContainerComponent],
                providers: [NZ_NOTIFICATION_DEFAULT_CONFIG_PROVIDER, NzNotificationService],
                entryComponents: [NzNotificationContainerComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzPaginationComponent {
    /**
     * @param {?} i18n
     */
    constructor(i18n) {
        this.i18n = i18n;
        this.unsubscribe$ = new Subject();
        // tslint:disable-next-line:no-any
        this.locale = {};
        this._showSizeChanger = false;
        this._showQuickJumper = false;
        this._simple = false;
        this._hideOnSinglePage = false;
        this._pageSize = 10;
        this._pageSizeOptions = [10, 20, 30, 40];
        this._pageIndex = 1;
        this.firstIndex = 1;
        this.pages = [];
        this.nzInTable = false;
        this.nzPageSizeChange = new EventEmitter();
        this.nzPageIndexChange = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzItemRender(value) {
        this._itemRender = value;
    }
    /**
     * @return {?}
     */
    get nzItemRender() {
        return this._itemRender;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowSizeChanger(value) {
        this._showSizeChanger = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowSizeChanger() {
        return this._showSizeChanger;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzHideOnSinglePage(value) {
        this._hideOnSinglePage = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzHideOnSinglePage() {
        return this._hideOnSinglePage;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowQuickJumper(value) {
        this._showQuickJumper = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowQuickJumper() {
        return this._showQuickJumper;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSimple(value) {
        this._simple = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzSimple() {
        return this._simple;
    }
    /**
     * page size changer select values
     * @param {?} value
     * @return {?}
     */
    set nzPageSizeOptions(value) {
        if (value && value.length) {
            this._pageSizeOptions = value;
        }
    }
    /**
     * @return {?}
     */
    get nzPageSizeOptions() {
        return this._pageSizeOptions;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPageIndex(value) {
        if (this._pageIndex === value) {
            return;
        }
        if (value > this.lastIndex) {
            this._pageIndex = this.lastIndex;
        }
        else if (value < this.firstIndex) {
            this._pageIndex = this.firstIndex;
        }
        else {
            this._pageIndex = Number(value);
        }
        this.buildIndexes();
    }
    /**
     * @return {?}
     */
    get nzPageIndex() {
        return this._pageIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPageSize(value) {
        if (value === this._pageSize) {
            return;
        }
        this._pageSize = value;
        const /** @type {?} */ pageIndexOverflow = this.checkLastIndexOverflow();
        if (pageIndexOverflow) {
            this.nzPageIndex = this.lastIndex;
            this.nzPageIndexChange.emit(this.lastIndex);
        }
        this.buildIndexes();
    }
    /**
     * @return {?}
     */
    get nzPageSize() {
        return this._pageSize;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTotal(value) {
        this._total = value;
        this.buildIndexes();
    }
    /**
     * @return {?}
     */
    get nzTotal() {
        return this._total;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    jumpPage(index) {
        if (index === this.nzPageIndex) {
            return;
        }
        if (index < this.firstIndex) {
            this.nzPageIndex = this.firstIndex;
        }
        else if (index > this.lastIndex) {
            this.nzPageIndex = this.lastIndex;
        }
        else {
            this.nzPageIndex = index;
        }
        this.nzPageIndexChange.emit(this.nzPageIndex);
    }
    /**
     * @return {?}
     */
    jumpPreFive() {
        this.jumpPage(this.nzPageIndex - 5);
    }
    /**
     * @return {?}
     */
    jumpNextFive() {
        this.jumpPage(this.nzPageIndex + 5);
    }
    /**
     * @return {?}
     */
    jumpPreOne() {
        if (this.isFirstIndex) {
            return;
        }
        this.jumpPage(this.nzPageIndex - 1);
    }
    /**
     * @return {?}
     */
    jumpNextOne() {
        if (this.isLastIndex) {
            return;
        }
        this.jumpPage(this.nzPageIndex + 1);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onPageSizeChange($event) {
        this.nzPageSize = $event;
        this.nzPageSizeChange.emit($event);
    }
    /**
     * @param {?} e
     * @param {?} input
     * @param {?} clearInputValue
     * @return {?}
     */
    handleKeyDown(e, input, clearInputValue) {
        const /** @type {?} */ target = input;
        const /** @type {?} */ inputValue = target.value;
        const /** @type {?} */ currentInputValue = this.nzPageIndex;
        let /** @type {?} */ value;
        if (inputValue === '') {
            value = inputValue;
        }
        else if (isNaN(Number(inputValue))) {
            value = currentInputValue;
        }
        else {
            value = Number(inputValue);
        }
        this.handleChange(value, target, clearInputValue);
    }
    /**
     * @param {?} page
     * @return {?}
     */
    isValid(page) {
        return isInteger(page) && (page >= 1) && (page !== this.nzPageIndex) && (page <= this.lastIndex);
    }
    /**
     * @param {?} value
     * @param {?} target
     * @param {?} clearInputValue
     * @return {?}
     */
    handleChange(value, target, clearInputValue) {
        const /** @type {?} */ page = value;
        if (this.isValid(page)) {
            this.nzPageIndex = page;
            this.nzPageIndexChange.emit(this.nzPageIndex);
        }
        if (clearInputValue) {
            target.value = null;
        }
        else {
            target.value = `${this.nzPageIndex}`;
        }
    }
    /**
     * @return {?}
     */
    checkLastIndexOverflow() {
        return this.nzPageIndex > this.lastIndex;
    }
    /**
     * @return {?}
     */
    get lastIndex() {
        return Math.ceil(this.nzTotal / this.nzPageSize);
    }
    /**
     * generate indexes list
     * @return {?}
     */
    buildIndexes() {
        const /** @type {?} */ tmpPages = [];
        if (this.lastIndex <= 9) {
            for (let /** @type {?} */ i = 2; i <= this.lastIndex - 1; i++) {
                tmpPages.push({ index: i });
            }
        }
        else {
            const /** @type {?} */ current = +this.nzPageIndex;
            let /** @type {?} */ left = Math.max(2, current - 2);
            let /** @type {?} */ right = Math.min(current + 2, this.lastIndex - 1);
            if (current - 1 <= 2) {
                right = 5;
            }
            if (this.lastIndex - current <= 2) {
                left = this.lastIndex - 4;
            }
            for (let /** @type {?} */ i = left; i <= right; i++) {
                tmpPages.push({ index: i });
            }
        }
        this.pages = tmpPages;
    }
    /**
     * @return {?}
     */
    get isLastIndex() {
        return this.nzPageIndex === this.lastIndex;
    }
    /**
     * @return {?}
     */
    get isFirstIndex() {
        return this.nzPageIndex === this.firstIndex;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.i18n.localeChange.pipe(takeUntil(this.unsubscribe$)).subscribe(() => this.locale = this.i18n.getLocaleData('Pagination'));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
}
NzPaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-pagination',
                preserveWhitespaces: false,
                template: `<ng-template #renderItemTemplate let-type let-page="page"> <a class="ant-pagination-item-link" *ngIf="type!='page'"></a> <a *ngIf="type=='page'">{{page}}</a> </ng-template> <ng-container *ngIf="(nzHideOnSinglePage&&(nzTotal>nzPageSize))||!nzHideOnSinglePage"> <ul *ngIf="nzSimple" [class.ant-table-pagination]="nzInTable" class="ant-pagination ant-pagination-simple"> <li title="{{ locale.prev_page }}" class="ant-pagination-prev" (click)="jumpPreOne()" [class.ant-pagination-disabled]="isFirstIndex"> <ng-template [ngTemplateOutlet]="nzItemRender" [ngTemplateOutletContext]="{ $implicit: 'pre'}"></ng-template> </li> <li [attr.title]="nzPageIndex+'/'+lastIndex" class="ant-pagination-simple-pager"> <input #simplePagerInput [ngModel]="nzPageIndex" (keydown.enter)="handleKeyDown($event,simplePagerInput,false)" size="3"> <span class="ant-pagination-slash">／</span> {{ lastIndex }} </li> <li title="{{ locale.next_page }}" class="ant-pagination-next" (click)="jumpNextOne()" [class.ant-pagination-disabled]="isLastIndex"> <ng-template [ngTemplateOutlet]="nzItemRender" [ngTemplateOutletContext]="{ $implicit: 'next'}"></ng-template> </li> </ul> <ul *ngIf="!nzSimple" [class.mini]="nzSize=='small'" [class.ant-table-pagination]="nzInTable" class="ant-pagination"> <span class="ant-pagination-total-text" *ngIf="nzShowTotal"> <ng-template [ngTemplateOutlet]="nzShowTotal" [ngTemplateOutletContext]="{ $implicit: nzTotal,range:[(nzPageIndex-1)*nzPageSize+1,nzPageIndex*nzPageSize] }"> </ng-template> </span> <li title="{{ locale.prev_page }}" class="ant-pagination-prev" (click)="jumpPreOne()" [class.ant-pagination-disabled]="isFirstIndex"> <ng-template [ngTemplateOutlet]="nzItemRender" [ngTemplateOutletContext]="{ $implicit: 'pre'}"></ng-template> </li> <li [attr.title]="firstIndex" class="ant-pagination-item" (click)="jumpPage(firstIndex)" [class.ant-pagination-item-active]="isFirstIndex"> <ng-template [ngTemplateOutlet]="nzItemRender" [ngTemplateOutletContext]="{ $implicit: 'page',page: firstIndex }"></ng-template> </li> <li [attr.title]="locale.prev_5" (click)="jumpPreFive()" class="ant-pagination-jump-prev" *ngIf="(lastIndex >9)&&(nzPageIndex-3>firstIndex)"> <a></a> </li> <li *ngFor="let page of pages" [attr.title]="page.index" class="ant-pagination-item" (click)="jumpPage(page.index)" [class.ant-pagination-item-active]="nzPageIndex==page.index"> <ng-template [ngTemplateOutlet]="nzItemRender" [ngTemplateOutletContext]="{ $implicit: 'page',page: page.index }"></ng-template> </li> <li [attr.title]="locale.next_5" (click)="jumpNextFive()" class="ant-pagination-jump-next" *ngIf="(lastIndex >9)&&(nzPageIndex+3<lastIndex)"> <a></a> </li> <li [attr.title]="lastIndex" class="ant-pagination-item" (click)="jumpPage(lastIndex)" *ngIf="(lastIndex>0)&&(lastIndex!==firstIndex)" [class.ant-pagination-item-active]="isLastIndex"> <ng-template [ngTemplateOutlet]="nzItemRender" [ngTemplateOutletContext]="{ $implicit: 'page',page: lastIndex }"></ng-template> </li> <li title="{{ locale.next_page }}" class="ant-pagination-next" (click)="jumpNextOne()" [class.ant-pagination-disabled]="isLastIndex"> <ng-template [ngTemplateOutlet]="nzItemRender" [ngTemplateOutletContext]="{ $implicit: 'next'}"></ng-template> </li> <div class="ant-pagination-options" *ngIf="nzShowQuickJumper||nzShowSizeChanger"> <nz-select *ngIf="nzShowSizeChanger" [nzSize]="nzSize=='small'?'small':''" class="ant-pagination-options-size-changer" [ngModel]="nzPageSize" (ngModelChange)="onPageSizeChange($event)"> <nz-option *ngFor="let option of nzPageSizeOptions" [nzLabel]="option + locale.items_per_page" [nzValue]="option"> </nz-option> <nz-option *ngIf="nzPageSizeOptions.indexOf(nzPageSize)==-1" [nzLabel]="nzPageSize + locale.items_per_page" [nzValue]="nzPageSize"> </nz-option> </nz-select> <div class="ant-pagination-options-quick-jumper" *ngIf="nzShowQuickJumper"> {{ locale.jump_to }} <input #quickJumperInput (keydown.enter)="handleKeyDown($event,quickJumperInput,true)"> {{ locale.page }} </div> </div> </ul> </ng-container>`
            },] },
];
/** @nocollapse */
NzPaginationComponent.ctorParameters = () => [
    { type: NzI18nService }
];
NzPaginationComponent.propDecorators = {
    _itemRender: [{ type: ViewChild, args: ['renderItemTemplate',] }],
    nzShowTotal: [{ type: Input }],
    nzInTable: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzPageSizeChange: [{ type: Output }],
    nzPageIndexChange: [{ type: Output }],
    nzItemRender: [{ type: Input }],
    nzShowSizeChanger: [{ type: Input }],
    nzHideOnSinglePage: [{ type: Input }],
    nzShowQuickJumper: [{ type: Input }],
    nzSimple: [{ type: Input }],
    nzPageSizeOptions: [{ type: Input }],
    nzPageIndex: [{ type: Input }],
    nzPageSize: [{ type: Input }],
    nzTotal: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzPaginationModule {
}
NzPaginationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzPaginationComponent],
                exports: [NzPaginationComponent],
                imports: [CommonModule, FormsModule, NzSelectModule, NzI18nModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzToolTipComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        this._hasBackdrop = false;
        this._prefix = 'ant-tooltip-placement';
        this._positions = [...DEFAULT_4_POSITIONS];
        this._classMap = {};
        this._placement = 'top';
        this._trigger = 'hover';
        this.visibleSource = new BehaviorSubject(false);
        this.visible$ = this.visibleSource.asObservable();
        this.nzVisibleChange = new EventEmitter();
        this.nzOverlayClassName = '';
        this.nzOverlayStyle = {};
        this.nzMouseEnterDelay = 0.15;
        this.nzMouseLeaveDelay = 0.1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzContent(value) {
        this.isContentString = !(value instanceof TemplateRef);
        this._content = value;
    }
    /**
     * @return {?}
     */
    get nzContent() {
        return this._content;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTitle(value) {
        this.isTitleString = !(value instanceof TemplateRef);
        this._title = value;
    }
    /**
     * @return {?}
     */
    get nzTitle() {
        return this._title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzVisible(value) {
        const /** @type {?} */ visible = toBoolean(value);
        if (this.visibleSource.value !== visible) {
            this.visibleSource.next(visible);
            this.nzVisibleChange.emit(visible);
        }
    }
    /**
     * @return {?}
     */
    get nzVisible() {
        return this.visibleSource.value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTrigger(value) {
        this._trigger = value;
        this._hasBackdrop = this._trigger === 'click';
    }
    /**
     * @return {?}
     */
    get nzTrigger() {
        return this._trigger;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPlacement(value) {
        if (value !== this._placement) {
            this._placement = value;
            this._positions.unshift(/** @type {?} */ (POSITION_MAP[this.nzPlacement]));
        }
    }
    /**
     * @return {?}
     */
    get nzPlacement() {
        return this._placement;
    }
    /**
     * @return {?}
     */
    updatePosition() {
        if (this.overlay && this.overlay.overlayRef) {
            this.overlay.overlayRef.updatePosition();
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onPositionChange($event) {
        for (const /** @type {?} */ key in POSITION_MAP) {
            if (JSON.stringify($event.connectionPair) === JSON.stringify(POSITION_MAP[key])) {
                this.nzPlacement = key;
                break;
            }
        }
        this.setClassMap();
        /** TODO may cause performance problem */
        this.cdr.detectChanges();
    }
    /**
     * @return {?}
     */
    show() {
        if (!this.isContentEmpty()) {
            this.nzVisible = true;
        }
    }
    /**
     * @return {?}
     */
    hide() {
        this.nzVisible = false;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    _afterVisibilityAnimation(e) {
        if (e.toState === 'false' && !this.nzVisible) {
            this.nzVisibleChange.emit(false);
        }
        if (e.toState === 'true' && this.nzVisible) {
            this.nzVisibleChange.emit(true);
        }
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this._classMap = {
            [this.nzOverlayClassName]: true,
            [`${this._prefix}-${this._placement}`]: true
        };
    }
    /**
     * @param {?} origin
     * @return {?}
     */
    setOverlayOrigin(origin) {
        this.overlayOrigin = origin;
    }
    /**
     * @return {?}
     */
    isContentEmpty() {
        return this.isTitleString ? (this.nzTitle === '' || !isNotNil(this.nzTitle)) : false; // Pity, can't detect whether nzTemplate is empty due to can't get it's content before shown up
    }
}
NzToolTipComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-tooltip',
                animations: [fadeAnimation],
                template: `<ng-content></ng-content> <ng-template #overlay="cdkConnectedOverlay" cdkConnectedOverlay [cdkConnectedOverlayOrigin]="overlayOrigin" [cdkConnectedOverlayHasBackdrop]="_hasBackdrop" (backdropClick)="hide()" (detach)="hide()" (positionChange)="onPositionChange($event)" [cdkConnectedOverlayPositions]="_positions" [cdkConnectedOverlayOpen]="visible$ | async"> <div class="ant-tooltip" [ngClass]="_classMap" [ngStyle]="nzOverlayStyle" [@fadeAnimation]="''+(visible$ | async)" (@fadeAnimation.done)="_afterVisibilityAnimation($event)"> <div class="ant-tooltip-content"> <div class="ant-tooltip-arrow"></div> <div class="ant-tooltip-inner"> <ng-container *ngIf="isTitleString; else titleTemplate">{{ nzTitle }}</ng-container> <ng-template #titleTemplate> <ng-template [ngTemplateOutlet]="nzTitle"></ng-template> </ng-template> </div> </div> </div> </ng-template>`,
                preserveWhitespaces: false,
                styles: [`
    .ant-tooltip {
      position: relative;
    }
  `]
            },] },
];
/** @nocollapse */
NzToolTipComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NzToolTipComponent.propDecorators = {
    _title: [{ type: ContentChild, args: ['nzTemplate',] }],
    overlay: [{ type: ViewChild, args: ['overlay',] }],
    nzVisibleChange: [{ type: Output }],
    nzOverlayClassName: [{ type: Input }],
    nzOverlayStyle: [{ type: Input }],
    nzMouseEnterDelay: [{ type: Input }],
    nzMouseLeaveDelay: [{ type: Input }],
    nzContent: [{ type: Input }],
    nzTitle: [{ type: Input }],
    nzVisible: [{ type: Input }],
    nzTrigger: [{ type: Input }],
    nzPlacement: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzPopconfirmComponent extends NzToolTipComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        super(cdr);
        this._condition = false;
        this._prefix = 'ant-popover-placement';
        this._trigger = 'click';
        this._hasBackdrop = true;
        this.nzOnCancel = new EventEmitter();
        this.nzOnConfirm = new EventEmitter();
        this.nzOkType = 'primary';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCondition(value) {
        this._condition = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzCondition() {
        return this._condition;
    }
    /**
     * @return {?}
     */
    show() {
        if (!this.nzCondition) {
            this.nzVisible = true;
        }
        else {
            this.onConfirm();
        }
    }
    /**
     * @return {?}
     */
    onCancel() {
        this.nzOnCancel.emit();
        this.nzVisible = false;
    }
    /**
     * @return {?}
     */
    onConfirm() {
        this.nzOnConfirm.emit();
        this.nzVisible = false;
    }
}
NzPopconfirmComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-popconfirm',
                preserveWhitespaces: false,
                animations: [fadeAnimation],
                template: `<ng-content></ng-content> <ng-template #overlay="cdkConnectedOverlay" cdkConnectedOverlay [cdkConnectedOverlayOrigin]="overlayOrigin" [cdkConnectedOverlayHasBackdrop]="_hasBackdrop" (backdropClick)="hide()" (detach)="hide()" (positionChange)="onPositionChange($event)" [cdkConnectedOverlayPositions]="_positions" [cdkConnectedOverlayOpen]="visible$ | async"> <div class="ant-popover" [ngClass]="_classMap" [ngStyle]="nzOverlayStyle" [@fadeAnimation]="''+(visible$ | async)" (@fadeAnimation.done)="_afterVisibilityAnimation($event)"> <div class="ant-popover-content"> <div class="ant-popover-arrow"></div> <div class="ant-popover-inner"> <div> <div class="ant-popover-inner-content"> <div class="ant-popover-message"> <ng-container *ngIf="isTitleString; else titleTemplate"> <i class="anticon anticon-exclamation-circle"></i> <div class="ant-popover-message-title">{{ nzTitle }}</div> </ng-container> <ng-template #titleTemplate> <ng-template [ngTemplateOutlet]="nzTitle"></ng-template> </ng-template> </div> <div class="ant-popover-buttons"> <button nz-button [nzSize]="'small'" (click)="onCancel()"> <ng-container *ngIf="nzCancelText">{{ nzCancelText }}</ng-container> <ng-container *ngIf="!nzCancelText">{{ 'Modal.cancelText' | nzI18n }}</ng-container> </button> <button nz-button [nzSize]="'small'" [nzType]="nzOkType" (click)="onConfirm()"> <ng-container *ngIf="nzOkText">{{ nzOkText }}</ng-container> <ng-container *ngIf="!nzOkText">{{ 'Modal.okText' | nzI18n }}</ng-container> </button> </div> </div> </div> </div> </div> </div> </ng-template>`,
                styles: [`
    .ant-popover {
      position: relative;
    }
  `]
            },] },
];
/** @nocollapse */
NzPopconfirmComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NzPopconfirmComponent.propDecorators = {
    nzOnCancel: [{ type: Output }],
    nzOnConfirm: [{ type: Output }],
    nzOkText: [{ type: Input }],
    nzOkType: [{ type: Input }],
    nzCancelText: [{ type: Input }],
    nzCondition: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTooltipDirective {
    /**
     * @param {?} elementRef
     * @param {?} hostView
     * @param {?} resolver
     * @param {?} renderer
     * @param {?} tooltip
     */
    constructor(elementRef, hostView, resolver, renderer, tooltip) {
        this.elementRef = elementRef;
        this.hostView = hostView;
        this.resolver = resolver;
        this.renderer = renderer;
        this.tooltip = tooltip;
        this.unsubscribe$ = new Subject();
        // [NOTE] Here hard coded, and nzTitle used only under NzTooltipDirective currently.
        this.isTooltipOpen = false;
        this.isDynamicTooltip = false;
        this.factory = this.resolver.resolveComponentFactory(NzToolTipComponent);
        this.nzVisibleChange = new EventEmitter();
    }
    /**
     * @param {?} title
     * @return {?}
     */
    set nzTitle(title) {
        this._title = title;
        this.updateCompValue('nzTitle', title);
    }
    /**
     * @return {?}
     */
    get nzTitle() {
        return this._title;
    }
    /**
     * @param {?} title
     * @return {?}
     */
    set setTitle(title) {
        this.nzTitle = title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzContent(value) {
        this._content = value;
        this.updateCompValue('nzContent', value);
    }
    /**
     * @return {?}
     */
    get nzContent() {
        return this._content;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzOverlayClassName(value) {
        this._overlayClassName = value;
        this.updateCompValue('nzOverlayClassName', value);
    }
    /**
     * @return {?}
     */
    get nzOverlayClassName() {
        return this._overlayClassName;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzOverlayStyle(value) {
        this._overlayStyle = value;
        this.updateCompValue('nzOverlayStyle', value);
    }
    /**
     * @return {?}
     */
    get nzOverlayStyle() {
        return this._overlayStyle;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzMouseEnterDelay(value) {
        this._mouseEnterDelay = value;
        this.updateCompValue('nzMouseEnterDelay', value);
    }
    /**
     * @return {?}
     */
    get nzMouseEnterDelay() {
        return this._mouseEnterDelay;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzMouseLeaveDelay(value) {
        this._mouseLeaveDelay = value;
        this.updateCompValue('nzMouseLeaveDelay', value);
    }
    /**
     * @return {?}
     */
    get nzMouseLeaveDelay() {
        return this._mouseEnterDelay;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzVisible(value) {
        this._visible = value;
        this.updateCompValue('nzVisible', value);
    }
    /**
     * @return {?}
     */
    get nzVisible() {
        return this._visible;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTrigger(value) {
        this._trigger = value;
        this.updateCompValue('nzTrigger', value);
    }
    /**
     * @return {?}
     */
    get nzTrigger() {
        return this._trigger;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPlacement(value) {
        this._placement = value;
        this.updateCompValue('nzPlacement', value);
    }
    /**
     * @return {?}
     */
    get nzPlacement() {
        return this._placement;
    }
    /**
     * @return {?}
     */
    get isOpen() {
        return this.isTooltipOpen;
    }
    /**
     * @return {?}
     */
    show() {
        this.tooltip.show();
        this.isTooltipOpen = true;
    }
    /**
     * @return {?}
     */
    hide() {
        this.tooltip.hide();
        this.isTooltipOpen = false;
    }
    /**
     * @param {?} isOrigin
     * @param {?} isEnter
     * @param {?=} delay
     * @return {?}
     */
    delayEnterLeave(isOrigin, isEnter, delay$$1 = -1) {
        if (this.delayTimer) {
            // Clear timer during the delay time
            window.clearTimeout(this.delayTimer);
            this.delayTimer = null;
        }
        else if (delay$$1 > 0) {
            this.delayTimer = window.setTimeout(() => {
                this.delayTimer = null;
                isEnter ? this.show() : this.hide();
            }, delay$$1 * 1000);
        }
        else {
            isEnter && isOrigin ? this.show() : this.hide(); // [Compatible] The "isOrigin" is used due to the tooltip will not hide immediately (may caused by the fade-out animation)
        }
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    updateCompValue(key, value) {
        if (this.isDynamicTooltip && isNotNil(value)) {
            this.tooltip[key] = value;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Support faster tooltip mode: <a nz-tooltip="xxx"></a>. [NOTE] Used only under NzTooltipDirective currently.
        if (!this.tooltip) {
            this.tooltip = this.hostView.createComponent(this.factory).instance;
            this.isDynamicTooltip = true;
            const /** @type {?} */ properties = ['nzTitle', 'nzContent', 'nzOverlayClassName', 'nzOverlayStyle', 'nzMouseEnterDelay', 'nzMouseLeaveDelay', 'nzVisible', 'nzTrigger', 'nzPlacement'];
            properties.forEach(property => this.updateCompValue(property, this[property]));
            this.tooltip.nzVisibleChange.pipe(takeUntil(this.unsubscribe$), distinctUntilChanged()).subscribe(data => {
                this._visible = data;
                this.nzVisibleChange.emit(data);
            });
        }
        this.tooltip.setOverlayOrigin(this);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.tooltip.nzTrigger === 'hover') {
            let /** @type {?} */ overlayElement;
            this.renderer.listen(this.elementRef.nativeElement, 'mouseenter', () => this.delayEnterLeave(true, true, this.tooltip.nzMouseEnterDelay));
            this.renderer.listen(this.elementRef.nativeElement, 'mouseleave', () => {
                this.delayEnterLeave(true, false, this.tooltip.nzMouseLeaveDelay);
                if (this.tooltip.overlay.overlayRef && !overlayElement) {
                    // NOTE: we bind events under "mouseleave" due to the overlayRef is only created after the overlay was completely shown up
                    overlayElement = this.tooltip.overlay.overlayRef.overlayElement;
                    this.renderer.listen(overlayElement, 'mouseenter', () => this.delayEnterLeave(false, true));
                    this.renderer.listen(overlayElement, 'mouseleave', () => this.delayEnterLeave(false, false));
                }
            });
        }
        else if (this.tooltip.nzTrigger === 'focus') {
            this.renderer.listen(this.elementRef.nativeElement, 'focus', () => this.show());
            this.renderer.listen(this.elementRef.nativeElement, 'blur', () => this.hide());
        }
        else if (this.tooltip.nzTrigger === 'click') {
            this.renderer.listen(this.elementRef.nativeElement, 'click', (e) => {
                e.preventDefault();
                this.show();
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
}
NzTooltipDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-tooltip]'
            },] },
];
/** @nocollapse */
NzTooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: Renderer2 },
    { type: NzToolTipComponent, decorators: [{ type: Optional }] }
];
NzTooltipDirective.propDecorators = {
    nzVisibleChange: [{ type: Output }],
    nzTitle: [{ type: Input, args: ['nz-tooltip',] }],
    setTitle: [{ type: Input, args: ['nzTitle',] }],
    nzContent: [{ type: Input }],
    nzOverlayClassName: [{ type: Input }],
    nzOverlayStyle: [{ type: Input }],
    nzMouseEnterDelay: [{ type: Input }],
    nzMouseLeaveDelay: [{ type: Input }],
    nzVisible: [{ type: Input }],
    nzTrigger: [{ type: Input }],
    nzPlacement: [{ type: Input }],
    isOpen: [{ type: HostBinding, args: ['class.ant-tooltip-open',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzPopconfirmDirective extends NzTooltipDirective {
    /**
     * @param {?} elementRef
     * @param {?} hostView
     * @param {?} resolver
     * @param {?} renderer
     * @param {?} tooltip
     */
    constructor(elementRef, hostView, resolver, renderer, tooltip) {
        super(elementRef, hostView, resolver, renderer, tooltip);
        this.subclassUnsubscribe$ = new Subject();
        this.factory = this.resolver.resolveComponentFactory(NzPopconfirmComponent);
        this._condition = false;
        this._okType = 'primary';
        this.nzOnCancel = new EventEmitter();
        this.nzOnConfirm = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzOkText(value) {
        this._okText = value;
        this.updateCompValue('nzOkText', value);
    }
    /**
     * @return {?}
     */
    get nzOkText() {
        return this._okText;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzOkType(value) {
        this._okType = value;
        this.updateCompValue('nzOkType', value);
    }
    /**
     * @return {?}
     */
    get nzOkType() {
        return this._okType;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCancelText(value) {
        this._cancelText = value;
        this.updateCompValue('nzCancelText', value);
    }
    /**
     * @return {?}
     */
    get nzCancelText() {
        return this._cancelText;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCondition(value) {
        this._condition = toBoolean(value);
        this.updateCompValue('nzCondition', value);
    }
    /**
     * @return {?}
     */
    get nzCondition() {
        return this._condition;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.tooltip) {
            this.tooltip = this.hostView.createComponent(this.factory).instance;
            this.isDynamicTooltip = true;
            const /** @type {?} */ properties = [
                'nzTitle',
                'nzContent',
                'nzOverlayClassName',
                'nzOverlayStyle',
                'nzMouseEnterDelay',
                'nzMouseLeaveDelay',
                'nzVisible',
                'nzTrigger',
                'nzPlacement',
                'nzOkText',
                'nzOkType',
                'nzCancelText',
                'nzCondition'
            ];
            properties.forEach(property => this.updateCompValue(property, this[property]));
            this.tooltip.nzVisibleChange.pipe(takeUntil(this.subclassUnsubscribe$), distinctUntilChanged()).subscribe(data => {
                this._visible = data;
                this.nzVisibleChange.emit(data);
            });
            (/** @type {?} */ (this.tooltip)).nzOnCancel.pipe(takeUntil(this.subclassUnsubscribe$)).subscribe(data => {
                this.nzOnCancel.emit();
            });
            (/** @type {?} */ (this.tooltip)).nzOnConfirm.pipe(takeUntil(this.subclassUnsubscribe$)).subscribe(data => {
                this.nzOnConfirm.emit();
            });
        }
        this.tooltip.setOverlayOrigin(this);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subclassUnsubscribe$.next();
        this.subclassUnsubscribe$.complete();
    }
}
NzPopconfirmDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-popconfirm]'
            },] },
];
/** @nocollapse */
NzPopconfirmDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: Renderer2 },
    { type: NzPopconfirmComponent, decorators: [{ type: Optional }] }
];
NzPopconfirmDirective.propDecorators = {
    nzOnCancel: [{ type: Output }],
    nzOnConfirm: [{ type: Output }],
    nzOkText: [{ type: Input }],
    nzOkType: [{ type: Input }],
    nzCancelText: [{ type: Input }],
    nzCondition: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzPopconfirmModule {
}
NzPopconfirmModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzPopconfirmComponent, NzPopconfirmDirective],
                exports: [NzPopconfirmComponent, NzPopconfirmDirective],
                imports: [CommonModule, NzButtonModule, OverlayModule, NzI18nModule],
                entryComponents: [NzPopconfirmComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzPopoverComponent extends NzToolTipComponent {
    constructor() {
        super(...arguments);
        this._prefix = 'ant-popover-placement';
    }
}
NzPopoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-popover',
                animations: [fadeAnimation],
                template: `<ng-content></ng-content> <ng-template #overlay="cdkConnectedOverlay" cdkConnectedOverlay [cdkConnectedOverlayOrigin]="overlayOrigin" [cdkConnectedOverlayHasBackdrop]="_hasBackdrop" (backdropClick)="hide()" (detach)="hide()" (positionChange)="onPositionChange($event)" [cdkConnectedOverlayPositions]="_positions" [cdkConnectedOverlayOpen]="visible$ | async"> <div class="ant-popover" [ngClass]="_classMap" [ngStyle]="nzOverlayStyle" [@fadeAnimation]="''+(visible$ | async)" (@fadeAnimation.done)="_afterVisibilityAnimation($event)"> <div class="ant-popover-content"> <div class="ant-popover-arrow"></div> <div class="ant-popover-inner"> <div class="ant-popover-title" *ngIf="nzTitle"> <ng-container *ngIf="isTitleString; else titleTemplate">{{ nzTitle }}</ng-container> <ng-template #titleTemplate> <ng-template [ngTemplateOutlet]="nzTitle"></ng-template> </ng-template> </div> <div class="ant-popover-inner-content"> <ng-container *ngIf="isContentString; else contentTemplate">{{ nzContent }}</ng-container> <ng-template #contentTemplate> <ng-template [ngTemplateOutlet]="nzContent"></ng-template> </ng-template> </div> </div> </div> </div> </ng-template>`,
                preserveWhitespaces: false,
                styles: [`
    .ant-popover {
      position: relative;
    }
  `]
            },] },
];
NzPopoverComponent.propDecorators = {
    _title: [{ type: ContentChild, args: ['neverUsedTemplate',] }],
    _content: [{ type: ContentChild, args: ['nzTemplate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzPopoverDirective extends NzTooltipDirective {
    /**
     * @param {?} elementRef
     * @param {?} hostView
     * @param {?} resolver
     * @param {?} renderer
     * @param {?} tooltip
     */
    constructor(elementRef, hostView, resolver, renderer, tooltip) {
        super(elementRef, hostView, resolver, renderer, tooltip);
        this.factory = this.resolver.resolveComponentFactory(NzPopoverComponent);
    }
}
NzPopoverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-popover]'
            },] },
];
/** @nocollapse */
NzPopoverDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: Renderer2 },
    { type: NzPopoverComponent, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzPopoverModule {
}
NzPopoverModule.decorators = [
    { type: NgModule, args: [{
                entryComponents: [NzPopoverComponent],
                exports: [NzPopoverDirective, NzPopoverComponent],
                declarations: [NzPopoverDirective, NzPopoverComponent],
                imports: [CommonModule, OverlayModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzProgressComponent {
    constructor() {
        this._gapDegree = 0;
        this._gapPosition = 'top';
        this._percent = 0;
        this._status = 'normal';
        this._cacheStatus = 'normal';
        this._strokeWidth = 8;
        this._size = 'default';
        this._type = 'line';
        this._format = (percent) => `${percent}%`;
        this.isStatusSet = false;
        this.isStrokeWidthSet = false;
        this.isFormatSet = false;
        this.isGapDegreeSet = false;
        this.isGapPositionSet = false;
        this.statusColorMap = {
            normal: '#108ee9',
            exception: '#ff5500',
            success: '#87d068'
        };
        this.nzShowInfo = true;
        this.nzWidth = 132;
        this.nzSuccessPercent = 0;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this._size = value;
        if (this.nzSize === 'small' && !this.isStrokeWidthSet) {
            this._strokeWidth = 6;
        }
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzFormat(value) {
        if (isNotNil(value)) {
            this._format = value;
            this.isFormatSet = true;
        }
    }
    /**
     * @return {?}
     */
    get nzFormat() {
        return this._format;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPercent(value) {
        this._percent = value;
        if (isNotNil(value)) {
            const /** @type {?} */ fillAll = parseInt(value.toString(), 10) >= 100;
            if (fillAll && !this.isStatusSet) {
                this._status = 'success';
            }
            else {
                this._status = this._cacheStatus;
            }
            this.updatePathStyles();
            this.updateIconClassMap();
        }
    }
    /**
     * @return {?}
     */
    get nzPercent() {
        return this._percent;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzStrokeWidth(value) {
        if (isNotNil(value)) {
            this._strokeWidth = value;
            this.isStrokeWidthSet = true;
            this.updatePathStyles();
        }
    }
    /**
     * @return {?}
     */
    get nzStrokeWidth() {
        return this._strokeWidth;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzStatus(value) {
        if (isNotNil(value)) {
            this._status = value;
            this._cacheStatus = value;
            this.isStatusSet = true;
            this.updateIconClassMap();
        }
    }
    /**
     * @return {?}
     */
    get nzStatus() {
        return this._status;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzType(value) {
        this._type = value;
        if (!this.isStrokeWidthSet) {
            if (this.nzType !== 'line') {
                this._strokeWidth = 6;
            }
        }
        if (this.nzType === 'dashboard') {
            if (!this.isGapPositionSet) {
                this._gapPosition = 'bottom';
            }
            if (!this.isGapDegreeSet) {
                this._gapDegree = 75;
            }
        }
        this.updateIconClassMap();
        this.updatePathStyles();
    }
    /**
     * @return {?}
     */
    get nzType() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzGapDegree(value) {
        if (isNotNil(value)) {
            this._gapDegree = value;
            this.isGapDegreeSet = true;
            this.updatePathStyles();
        }
    }
    /**
     * @return {?}
     */
    get nzGapDegree() {
        return this._gapDegree;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzGapPosition(value) {
        if (isNotNil(value)) {
            this._gapPosition = value;
            this.isGapPositionSet = true;
            this.updatePathStyles();
        }
    }
    /**
     * @return {?}
     */
    get nzGapPosition() {
        return this._gapPosition;
    }
    /**
     * @return {?}
     */
    get isCirCleStyle() {
        return this.nzType === 'circle' || this.nzType === 'dashboard';
    }
    /**
     * @return {?}
     */
    updatePathStyles() {
        const /** @type {?} */ radius = 50 - (this.nzStrokeWidth / 2);
        let /** @type {?} */ beginPositionX = 0;
        let /** @type {?} */ beginPositionY = -radius;
        let /** @type {?} */ endPositionX = 0;
        let /** @type {?} */ endPositionY = radius * -2;
        switch (this.nzGapPosition) {
            case 'left':
                beginPositionX = -radius;
                beginPositionY = 0;
                endPositionX = radius * 2;
                endPositionY = 0;
                break;
            case 'right':
                beginPositionX = radius;
                beginPositionY = 0;
                endPositionX = radius * -2;
                endPositionY = 0;
                break;
            case 'bottom':
                beginPositionY = radius;
                endPositionY = radius * 2;
                break;
            default:
        }
        this.pathString = `M 50,50 m ${beginPositionX},${beginPositionY}
     a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
     a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
        const /** @type {?} */ len = Math.PI * 2 * radius;
        this.trailPathStyle = {
            strokeDasharray: `${len - this.nzGapDegree}px ${len}px`,
            strokeDashoffset: `-${this.nzGapDegree / 2}px`,
            transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s'
        };
        this.strokePathStyle = {
            strokeDasharray: `${(this.nzPercent / 100) * (len - this.nzGapDegree)}px ${len}px`,
            strokeDashoffset: `-${this.nzGapDegree / 2}px`,
            transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s' // eslint-disable-line
        };
    }
    /**
     * @return {?}
     */
    updateIconClassMap() {
        const /** @type {?} */ isCircle = (this.nzType === 'circle' || this.nzType === 'dashboard');
        this.iconClassMap = {
            'anticon-check': (this.nzStatus === 'success') && isCircle,
            'anticon-cross': (this.nzStatus === 'exception') && isCircle,
            'anticon-check-circle': (this.nzStatus === 'success') && !isCircle,
            'anticon-cross-circle': (this.nzStatus === 'exception') && !isCircle
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updatePathStyles();
        this.updateIconClassMap();
    }
}
NzProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-progress',
                preserveWhitespaces: false,
                template: `<ng-template #progressInfoTemplate> <span class="ant-progress-text" *ngIf="nzShowInfo"> <ng-container *ngIf="(nzStatus=='exception')||(nzStatus=='success')&&(!isFormatSet); else formatTemplate"> <i class="anticon" [ngClass]="iconClassMap"></i> </ng-container> <ng-template #formatTemplate> {{ nzFormat(nzPercent) }} </ng-template> </span> </ng-template> <div [ngClass]="'ant-progress ant-progress-status-'+nzStatus" [class.ant-progress-line]="nzType=='line'" [class.ant-progress-small]="nzSize=='small'" [class.ant-progress-show-info]="nzShowInfo" [class.ant-progress-circle]="isCirCleStyle"> <div *ngIf="nzType=='line'"> <div class="ant-progress-outer"> <div class="ant-progress-inner"> <div class="ant-progress-bg" [style.width.%]="nzPercent" [style.height.px]="nzStrokeWidth"></div> <div class="ant-progress-success-bg" [style.width.%]="nzSuccessPercent" [style.height.px]="nzStrokeWidth"></div> </div> </div> <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template> </div> <div [style.width.px]="this.nzWidth" [style.height.px]="this.nzWidth" [style.fontSize.px]="this.nzWidth*0.15+6" class="ant-progress-inner" *ngIf="isCirCleStyle"> <svg class="ant-progress-circle " viewBox="0 0 100 100"> <path class="ant-progress-circle-trail" stroke="#f3f3f3" fill-opacity="0" [attr.stroke-width]="nzStrokeWidth" [ngStyle]="trailPathStyle" [attr.d]="pathString"> </path> <path class="ant-progress-circle-path" [attr.d]="pathString" stroke-linecap="round" fill-opacity="0" [attr.stroke]="statusColorMap[nzStatus]" [attr.stroke-width]="nzPercent?nzStrokeWidth:0" [ngStyle]="strokePathStyle"> </path> </svg> <ng-template [ngTemplateOutlet]="progressInfoTemplate"></ng-template> </div> </div>`
            },] },
];
NzProgressComponent.propDecorators = {
    nzShowInfo: [{ type: Input }],
    nzWidth: [{ type: Input }],
    nzSuccessPercent: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzFormat: [{ type: Input }],
    nzPercent: [{ type: Input }],
    nzStrokeWidth: [{ type: Input }],
    nzStatus: [{ type: Input }],
    nzType: [{ type: Input }],
    nzGapDegree: [{ type: Input }],
    nzGapPosition: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzProgressModule {
}
NzProgressModule.decorators = [
    { type: NgModule, args: [{
                exports: [NzProgressComponent],
                declarations: [NzProgressComponent],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzRateComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this._allowClear = true;
        this._allowHalf = false;
        this._disabled = false;
        this._count = 5;
        this._value = 0;
        this._autoFocus = false;
        this.nzOnBlur = new EventEmitter();
        this.nzOnFocus = new EventEmitter();
        this.nzOnKeyDown = new EventEmitter();
        this.nzOnHoverChange = new EventEmitter();
        this.prefixCls = 'ant-rate';
        this.isInit = false;
        this.hasHalf = false;
        this.innerPrefixCls = `${this.prefixCls}-star`;
        this.starArray = [];
        this.hoverValue = 0;
        this.isFocused = false;
        this.floatReg = /^\d+(\.\d+)?$/;
        this.onChange = () => null;
        this.onTouched = () => null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAutoFocus(value) {
        this._autoFocus = toBoolean(value);
        this.updateAutoFocus();
    }
    /**
     * @return {?}
     */
    get nzAutoFocus() {
        return this._autoFocus;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCount(value) {
        if (this._count === value) {
            return;
        }
        this._count = value;
        this.updateStarArray();
    }
    /**
     * @return {?}
     */
    get nzCount() {
        return this._count;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAllowHalf(value) {
        this._allowHalf = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzAllowHalf() {
        return this._allowHalf;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAllowClear(value) {
        this._allowClear = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzAllowClear() {
        return this._allowClear;
    }
    /**
     * @return {?}
     */
    get nzValue() {
        return this._value;
    }
    /**
     * @param {?} input
     * @return {?}
     */
    set nzValue(input) {
        let /** @type {?} */ value = input;
        if (this._value === value) {
            return;
        }
        this._value = value;
        if (this.floatReg.test(value.toString())) {
            value += 0.5;
            this.hasHalf = true;
        }
        this.hoverValue = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-disabled`]: this.nzDisabled
        };
    }
    /**
     * @return {?}
     */
    updateAutoFocus() {
        if (this.isInit && !this.nzDisabled) {
            if (this.nzAutoFocus) {
                this.renderer.setAttribute(this.ulElement.nativeElement, 'autofocus', 'autofocus');
            }
            else {
                this.renderer.removeAttribute(this.ulElement.nativeElement, 'autofocus');
            }
        }
    }
    /**
     * @param {?} e
     * @param {?} index
     * @param {?} isFull
     * @return {?}
     */
    clickRate(e, index, isFull) {
        e.stopPropagation();
        if (this.nzDisabled) {
            return;
        }
        this.hasHalf = !isFull && this.nzAllowHalf;
        let /** @type {?} */ actualValue = index + 1;
        this.hoverValue = actualValue;
        if (this.hasHalf) {
            actualValue -= 0.5;
        }
        if (this.nzValue === actualValue) {
            if (this.nzAllowClear) {
                this.nzValue = 0;
                this.onChange(this.nzValue);
            }
        }
        else {
            this.nzValue = actualValue;
            this.onChange(this.nzValue);
        }
    }
    /**
     * @param {?} e
     * @param {?} index
     * @param {?} isFull
     * @return {?}
     */
    hoverRate(e, index, isFull) {
        e.stopPropagation();
        if (this.nzDisabled) {
            return;
        }
        const /** @type {?} */ isHalf = !isFull && this.nzAllowHalf;
        if (this.hoverValue === index + 1 && isHalf === this.hasHalf) {
            return;
        }
        this.hoverValue = index + 1;
        this.nzOnHoverChange.emit(this.hoverValue);
        this.hasHalf = isHalf;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    leaveRate(e) {
        e.stopPropagation();
        let /** @type {?} */ oldVal = this.nzValue;
        if (this.floatReg.test(oldVal.toString())) {
            oldVal += 0.5;
            this.hasHalf = true;
        }
        this.hoverValue = oldVal;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFocus(e) {
        this.isFocused = true;
        this.nzOnFocus.emit(e);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onBlur(e) {
        this.isFocused = false;
        this.nzOnBlur.emit(e);
    }
    /**
     * @return {?}
     */
    focus() {
        this.ulElement.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    blur() {
        this.ulElement.nativeElement.blur();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        const /** @type {?} */ code = e.code;
        if ((code === 'ArrowRight' || e.keyCode === 39) && (this.nzValue < this.nzCount)) {
            if (this.nzAllowHalf) {
                this.nzValue += 0.5;
            }
            else {
                this.nzValue += 1;
            }
            this.onChange(this.nzValue);
        }
        else if ((code === 'ArrowLeft' || e.keyCode === 37) && (this.nzValue > 0)) {
            if (this.nzAllowHalf) {
                this.nzValue -= 0.5;
            }
            else {
                this.nzValue -= 1;
            }
            this.onChange(this.nzValue);
        }
        this.nzOnKeyDown.emit(e);
        e.preventDefault();
    }
    /**
     * @param {?} i
     * @return {?}
     */
    setClasses(i) {
        return {
            [this.innerPrefixCls]: true,
            [`${this.innerPrefixCls}-full`]: (i + 1 < this.hoverValue) || (!this.hasHalf) && (i + 1 === this.hoverValue),
            [`${this.innerPrefixCls}-half`]: (this.hasHalf) && (i + 1 === this.hoverValue),
            [`${this.innerPrefixCls}-active`]: (this.hasHalf) && (i + 1 === this.hoverValue),
            [`${this.innerPrefixCls}-zero`]: (i + 1 > this.hoverValue),
            [`${this.innerPrefixCls}-focused`]: (this.hasHalf) && (i + 1 === this.hoverValue) && this.isFocused
        };
    }
    /**
     * @return {?}
     */
    updateStarArray() {
        let /** @type {?} */ index = 0;
        this.starArray = [];
        while (index < this.nzCount) {
            this.starArray.push(index++);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.nzValue = value || 0;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
        this.updateStarArray();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.isInit = true;
    }
}
NzRateComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-rate',
                preserveWhitespaces: false,
                template: `<ng-template #defaultCharacter><i class="anticon anticon-star"></i></ng-template> <ul #ulElement [ngClass]="classMap" (mouseleave)="leaveRate($event)" (focus)="onFocus($event)" (blur)="onBlur($event)" (keydown)="onKeyDown($event)" [tabindex]="nzDisabled?-1:1"> <li *ngFor="let star of starArray" [ngClass]="setClasses(star)" (mouseover)="hoverRate($event, star, true)" (click)="clickRate($event, star, true)"> <div class="ant-rate-star-first" (mouseover)="hoverRate($event, star, false)" (click)="clickRate($event, star, false)"> <ng-template [ngTemplateOutlet]="nzCharacter||defaultCharacter"></ng-template> </div> <div class="ant-rate-star-second" (mouseover)="hoverRate($event, star, true)" (click)="clickRate($event, star, true)"> <ng-template [ngTemplateOutlet]="nzCharacter||defaultCharacter"></ng-template> </div> </li> </ul>`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzRateComponent),
                        multi: true
                    }
                ]
            },] },
];
/** @nocollapse */
NzRateComponent.ctorParameters = () => [
    { type: Renderer2 }
];
NzRateComponent.propDecorators = {
    nzCharacter: [{ type: Input }],
    nzOnBlur: [{ type: Output }],
    nzOnFocus: [{ type: Output }],
    nzOnKeyDown: [{ type: Output }],
    nzOnHoverChange: [{ type: Output }],
    ulElement: [{ type: ViewChild, args: ['ulElement',] }],
    nzAutoFocus: [{ type: Input }],
    nzCount: [{ type: Input }],
    nzAllowHalf: [{ type: Input }],
    nzAllowClear: [{ type: Input }],
    nzDisabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzRateModule {
}
NzRateModule.decorators = [
    { type: NgModule, args: [{
                exports: [NzRateComponent],
                declarations: [NzRateComponent],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzToolTipModule {
}
NzToolTipModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzToolTipComponent, NzTooltipDirective],
                exports: [NzToolTipComponent, NzTooltipDirective],
                imports: [CommonModule, OverlayModule],
                entryComponents: [NzToolTipComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSliderMarksComponent {
    constructor() {
        this._vertical = false;
        this._included = false;
        // Dynamic properties
        this.nzLowerBound = null;
        this.nzUpperBound = null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzVertical(value) {
        // Required
        this._vertical = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzVertical() {
        return this._vertical;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzIncluded(value) {
        this._included = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzIncluded() {
        return this._included;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["nzMarksArray"]) {
            this.buildAttrs();
        }
        if (changes["nzMarksArray"] || changes["nzLowerBound"] || changes["nzUpperBound"]) {
            this.togglePointActive();
        }
    }
    /**
     * @param {?} index
     * @param {?} attr
     * @return {?}
     */
    trackById(index, attr) {
        return attr.id;
    }
    /**
     * @return {?}
     */
    buildAttrs() {
        const /** @type {?} */ range = this.nzMax - this.nzMin;
        this.attrs = this.nzMarksArray.map(mark => {
            const { value, offset, config } = mark;
            // calc styles
            let /** @type {?} */ label = config;
            let /** @type {?} */ style$$1;
            if (this.nzVertical) {
                style$$1 = {
                    marginBottom: '-50%',
                    bottom: `${(value - this.nzMin) / range * 100}%`
                };
            }
            else {
                const /** @type {?} */ marksCount = this.nzMarksArray.length;
                const /** @type {?} */ unit = 100 / (marksCount - 1);
                const /** @type {?} */ markWidth = unit * 0.9;
                style$$1 = {
                    width: `${markWidth}%`,
                    marginLeft: `${-markWidth / 2}%`,
                    left: `${(value - this.nzMin) / range * 100}%`
                };
            }
            // custom configuration
            if (typeof config === 'object') {
                label = config.label;
                if (config.style) {
                    style$$1 = Object.assign({}, style$$1, config.style);
                }
            }
            return {
                id: value,
                value,
                offset,
                classes: {
                    [`${this.nzClassName}-text`]: true
                },
                style: style$$1,
                label
            };
        }); // END - map
    }
    /**
     * @return {?}
     */
    togglePointActive() {
        if (this.attrs && this.nzLowerBound !== null && this.nzUpperBound !== null) {
            this.attrs.forEach(attr => {
                const /** @type {?} */ value = attr.value;
                const /** @type {?} */ isActive = (!this.nzIncluded && value === this.nzUpperBound) ||
                    (this.nzIncluded && value <= this.nzUpperBound && value >= this.nzLowerBound);
                attr.classes[`${this.nzClassName}-text-active`] = isActive;
            });
        }
    }
}
NzSliderMarksComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-slider-marks',
                preserveWhitespaces: false,
                template: `<div [class]="nzClassName"> <span *ngFor="let attr of attrs; trackBy: trackById" [ngClass]="attr.classes" [ngStyle]="attr.style" [innerHTML]="attr.label"></span> </div>`
            },] },
];
NzSliderMarksComponent.propDecorators = {
    nzLowerBound: [{ type: Input }],
    nzUpperBound: [{ type: Input }],
    nzMarksArray: [{ type: Input }],
    nzClassName: [{ type: Input }],
    nzMin: [{ type: Input }],
    nzMax: [{ type: Input }],
    nzVertical: [{ type: Input }],
    nzIncluded: [{ type: Input }]
};
class Marks {
}
class MarksArray extends Array {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSliderService {
    /**
     * @param {?} e
     * @return {?}
     */
    pauseEvent(e) {
        e.stopPropagation();
        e.preventDefault();
    }
    /**
     * @param {?} num
     * @return {?}
     */
    getPrecision(num) {
        const /** @type {?} */ numStr = num.toString();
        const /** @type {?} */ dotIndex = numStr.indexOf('.');
        return dotIndex >= 0 ? numStr.length - dotIndex - 1 : 0;
    }
    /**
     * @template T
     * @param {?} arr
     * @return {?}
     */
    cloneArray(arr) {
        return arr.slice();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    isNotTouchEvent(e) {
        return !e.touches || e.touches.length > 1 ||
            (e.type.toLowerCase() === 'touchend' && e.touches.length > 0);
    }
    /**
     * @param {?} min
     * @param {?} max
     * @param {?} value
     * @return {?}
     */
    valueToOffset(min, max, value) {
        return (value - min) / (max - min) * 100;
    }
    /**
     * @param {?} num
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    correctNumLimit(num, min, max) {
        let /** @type {?} */ res = +num;
        if (isNaN(res)) {
            return min;
        }
        if (num < min) {
            res = min;
        }
        else if (num > max) {
            res = max;
        }
        return res;
    }
    /**
     * get the offset of an element relative to the document (Reference from jquery's offset())
     * @param {?} elem HTMLElement ref
     * @return {?}
     */
    getElementOffset(elem) {
        // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
        // Support: IE <=11 only
        // Running getBoundingClientRect on a
        // disconnected node in IE throws an error
        if (!elem.getClientRects().length) {
            return { top: 0, left: 0 };
        }
        // Get document-relative position by adding viewport scroll to viewport-relative gBCR
        const /** @type {?} */ rect = elem.getBoundingClientRect();
        const /** @type {?} */ win = elem.ownerDocument.defaultView;
        return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
        };
    }
}
NzSliderService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SliderHandle {
}
class NzSliderComponent {
    /**
     * @param {?} utils
     */
    constructor(utils) {
        this.utils = utils;
        // Debugging
        this.nzDebugId = null;
        // Static configurations (properties that can only specify once)
        this.nzStep = 1;
        this.nzMarks = null;
        this.nzMin = 0;
        this.nzMax = 100;
        this.nzDefaultValue = null;
        this.nzOnAfterChange = new EventEmitter();
        this._disabled = false;
        this._dots = false;
        this._included = true;
        this._range = false;
        this._vertical = false;
        this.value = null;
        this.cacheSliderStart = null;
        this.cacheSliderLength = null;
        this.prefixCls = 'ant-slider';
        this.activeValueIndex = null;
        this.track = { offset: null, length: null };
        this.bounds = { lower: null, upper: null };
        this.onTouched = () => {
        };
        this.isDragging = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzVertical(value) {
        this._vertical = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzVertical() {
        return this._vertical;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzRange(value) {
        this._range = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzRange() {
        return this._range;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDots(value) {
        this._dots = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDots() {
        return this._dots;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzIncluded(value) {
        this._included = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzIncluded() {
        return this._included;
    }
    /**
     * @param {?} val
     * @param {?=} isWriteValue
     * @return {?}
     */
    setValue(val, isWriteValue = false) {
        if (isWriteValue) {
            // [ngModel-writeValue]: Formatting before setting value, always update current value, but trigger onValueChange ONLY when the "formatted value" not equals "input value"
            this.value = this.formatValue(val);
            this.log(`[ngModel:setValue/writeValue]Update track & handles`);
            this.updateTrackAndHandles();
            // if (!this.isValueEqual(this.value, val)) {
            //   this.log(`[ngModel:setValue/writeValue]onValueChange`, val);
            //   if (this.onValueChange) { // NOTE: onValueChange will be unavailable when writeValue() called at the first time
            //     this.onValueChange(this.value);
            //   }
            // }
        }
        else {
            // [Normal]: setting value, ONLY check changed, then update and trigger onValueChange
            if (!this.isValueEqual(this.value, val)) {
                this.value = val;
                this.log(`[Normal:setValue]Update track & handles`);
                this.updateTrackAndHandles();
                this.log(`[Normal:setValue]onValueChange`, val);
                if (this.onValueChange) {
                    // NOTE: onValueChange will be unavailable when writeValue() called at the first time
                    this.onValueChange(this.value);
                }
            }
        }
    }
    /**
     * @param {?=} cloneAndSort
     * @return {?}
     */
    getValue(cloneAndSort = false) {
        // TODO: using type guard, remove type cast
        if (cloneAndSort && this.nzRange) {
            // clone & sort range values
            return this.utils.cloneArray(/** @type {?} */ (this.value)).sort((a, b) => a - b);
        }
        return this.value;
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    getValueToOffset(value) {
        let /** @type {?} */ normalizedValue = value;
        if (typeof normalizedValue === 'undefined') {
            normalizedValue = this.getValue(true);
        }
        // TODO: using type guard, remove type cast
        return this.nzRange ?
            (/** @type {?} */ (normalizedValue)).map(val => this.valueToOffset(val)) :
            this.valueToOffset(/** @type {?} */ (normalizedValue));
    }
    /**
     * @param {?} val
     * @return {?}
     */
    writeValue(val) {
        this.log(`[ngModel/writeValue]current writing value = `, val);
        this.setValue(val, true);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onValueChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
        this.toggleDragDisabled(isDisabled);
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // initial checking
        this.checkValidValue(this.nzDefaultValue); // check nzDefaultValue
        // default handles
        this.handles = this._generateHandles(this.nzRange ? 2 : 1);
        // initialize
        this.sliderDOM = this.slider.nativeElement;
        if (this.getValue() === null) {
            this.setValue(this.formatValue(null));
        } // init with default value
        this.marksArray = this.nzMarks === null ? null : this.toMarksArray(this.nzMarks);
        // event bindings
        this.createDrag();
        // initialize drag's disabled status
        this.toggleDragDisabled(this.nzDisabled);
        // the first time to init classes
        this.setClassMap();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        const { nzDisabled, nzMarks, nzRange } = changes;
        if (nzDisabled && !nzDisabled.firstChange) {
            this.toggleDragDisabled(nzDisabled.currentValue);
            this.setClassMap();
        }
        else if (nzMarks && !nzMarks.firstChange) {
            this.marksArray = this.nzMarks ? this.toMarksArray(this.nzMarks) : null;
        }
        else if (nzRange && !nzRange.firstChange) {
            this.setValue(this.formatValue(null)); // Change to default value when nzRange changed
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribeDrag();
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-disabled`]: this.nzDisabled,
            [`${this.prefixCls}-vertical`]: this.nzVertical,
            [`${this.prefixCls}-with-marks`]: this.marksArray ? this.marksArray.length : 0
        };
    }
    /**
     * @param {?} pointerValue
     * @return {?}
     */
    setActiveValueIndex(pointerValue) {
        if (this.nzRange) {
            let /** @type {?} */ minimal = null;
            let /** @type {?} */ gap;
            let /** @type {?} */ activeIndex;
            // TODO: using type guard, remove type cast
            (/** @type {?} */ (this.getValue())).forEach((val, index) => {
                gap = Math.abs(pointerValue - val);
                if (minimal === null || gap < minimal) {
                    minimal = gap;
                    activeIndex = index;
                }
            });
            this.activeValueIndex = activeIndex;
        }
    }
    /**
     * @param {?} pointerValue
     * @return {?}
     */
    setActiveValue(pointerValue) {
        if (this.nzRange) {
            // TODO: using type guard, remove type cast
            const /** @type {?} */ newValue = this.utils.cloneArray(/** @type {?} */ (this.value));
            newValue[this.activeValueIndex] = pointerValue;
            this.setValue(newValue);
        }
        else {
            this.setValue(pointerValue);
        }
    }
    /**
     * @return {?}
     */
    updateTrackAndHandles() {
        const /** @type {?} */ value = this.getValue();
        const /** @type {?} */ offset = this.getValueToOffset(value);
        const /** @type {?} */ valueSorted = this.getValue(true);
        const /** @type {?} */ offsetSorted = this.getValueToOffset(valueSorted);
        const /** @type {?} */ boundParts = this.nzRange ? /** @type {?} */ (valueSorted) : [0, valueSorted];
        const /** @type {?} */ trackParts = this.nzRange ? [offsetSorted[0], offsetSorted[1] - offsetSorted[0]] : [0, offsetSorted];
        this.handles.forEach((handle, index) => {
            handle.offset = this.nzRange ? offset[index] : offset;
            handle.value = this.nzRange ? value[index] : value;
        });
        [this.bounds.lower, this.bounds.upper] = boundParts;
        [this.track.offset, this.track.length] = trackParts;
    }
    /**
     * @param {?} marks
     * @return {?}
     */
    toMarksArray(marks) {
        const /** @type {?} */ marksArray = [];
        for (const /** @type {?} */ key in marks) {
            const /** @type {?} */ mark = marks[key];
            const /** @type {?} */ val = typeof key === 'number' ? key : parseFloat(key);
            if (val < this.nzMin || val > this.nzMax) {
                continue;
            }
            marksArray.push({ value: val, offset: this.valueToOffset(val), config: mark });
        }
        return marksArray;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onDragStart(value) {
        this.log('[onDragStart]dragging value = ', value);
        this.toggleDragMoving(true);
        // cache DOM layout/reflow operations
        this.cacheSliderProperty();
        // trigger drag start
        this.setActiveValueIndex(value);
        this.setActiveValue(value);
        // Tooltip visibility of handles
        this._showHandleTooltip(this.nzRange ? this.activeValueIndex : 0);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onDragMove(value) {
        this.log('[onDragMove]dragging value = ', value);
        // trigger drag moving
        this.setActiveValue(value);
    }
    /**
     * @return {?}
     */
    onDragEnd() {
        this.log('[onDragEnd]');
        this.toggleDragMoving(false);
        this.nzOnAfterChange.emit(this.getValue(true));
        // remove cache DOM layout/reflow operations
        this.cacheSliderProperty(true);
        // Hide all tooltip
        this._hideAllHandleTooltip();
    }
    /**
     * @return {?}
     */
    createDrag() {
        const /** @type {?} */ sliderDOM = this.sliderDOM;
        const /** @type {?} */ orientField = this.nzVertical ? 'pageY' : 'pageX';
        const /** @type {?} */ mouse = {
            start: 'mousedown', move: 'mousemove', end: 'mouseup',
            pluckKey: [orientField]
        };
        const /** @type {?} */ touch = {
            start: 'touchstart', move: 'touchmove', end: 'touchend',
            pluckKey: ['touches', '0', orientField],
            filter: (e) => !this.utils.isNotTouchEvent(/** @type {?} */ (e))
        };
        // make observables
        [mouse, touch].forEach(source => {
            const { start, move, end, pluckKey, filter: filterFunc = (() => true) } = source;
            // start
            source.startPlucked$ = fromEvent(sliderDOM, start).pipe(filter(filterFunc), tap(this.utils.pauseEvent), pluck(...pluckKey), map((position) => this.findClosestValue(position)));
            // end
            source.end$ = fromEvent(document, end);
            // resolve move
            source.moveResolved$ = fromEvent(document, move).pipe(filter(filterFunc), tap(this.utils.pauseEvent), pluck(...pluckKey), distinctUntilChanged(), map((position) => this.findClosestValue(position)), distinctUntilChanged(), takeUntil(source.end$));
            // merge to become moving
            // source.move$ = source.startPlucked$.mergeMapTo(source.moveResolved$);
        });
        // merge mouse and touch observables
        this.dragstart$ = merge(mouse.startPlucked$, touch.startPlucked$);
        // this.dragmove$ = Observable.merge(mouse.move$, touch.move$);
        this.dragmove$ = merge(mouse.moveResolved$, touch.moveResolved$);
        this.dragend$ = merge(mouse.end$, touch.end$);
    }
    /**
     * @param {?=} periods
     * @return {?}
     */
    subscribeDrag(periods = ['start', 'move', 'end']) {
        this.log('[subscribeDrag]this.dragstart$ = ', this.dragstart$);
        if (periods.indexOf('start') !== -1 && this.dragstart$ && !this.dragstart_) {
            this.dragstart_ = this.dragstart$.subscribe(this.onDragStart.bind(this));
        }
        if (periods.indexOf('move') !== -1 && this.dragmove$ && !this.dragmove_) {
            this.dragmove_ = this.dragmove$.subscribe(this.onDragMove.bind(this));
        }
        if (periods.indexOf('end') !== -1 && this.dragend$ && !this.dragend_) {
            this.dragend_ = this.dragend$.subscribe(this.onDragEnd.bind(this));
        }
    }
    /**
     * @param {?=} periods
     * @return {?}
     */
    unsubscribeDrag(periods = ['start', 'move', 'end']) {
        this.log('[unsubscribeDrag]this.dragstart_ = ', this.dragstart_);
        if (periods.indexOf('start') !== -1 && this.dragstart_) {
            this.dragstart_.unsubscribe();
            this.dragstart_ = null;
        }
        if (periods.indexOf('move') !== -1 && this.dragmove_) {
            this.dragmove_.unsubscribe();
            this.dragmove_ = null;
        }
        if (periods.indexOf('end') !== -1 && this.dragend_) {
            this.dragend_.unsubscribe();
            this.dragend_ = null;
        }
    }
    /**
     * @param {?} movable
     * @return {?}
     */
    toggleDragMoving(movable) {
        const /** @type {?} */ periods = ['move', 'end'];
        if (movable) {
            this.isDragging = true;
            this.subscribeDrag(periods);
        }
        else {
            this.isDragging = false;
            this.unsubscribeDrag(periods);
        }
    }
    /**
     * @param {?} disabled
     * @return {?}
     */
    toggleDragDisabled(disabled) {
        if (disabled) {
            this.unsubscribeDrag();
        }
        else {
            this.subscribeDrag(['start']);
        }
    }
    /**
     * @param {?} position
     * @return {?}
     */
    findClosestValue(position) {
        const /** @type {?} */ sliderStart = this.getSliderStartPosition();
        const /** @type {?} */ sliderLength = this.getSliderLength();
        const /** @type {?} */ ratio = this.utils.correctNumLimit((position - sliderStart) / sliderLength, 0, 1);
        const /** @type {?} */ val = (this.nzMax - this.nzMin) * (this.nzVertical ? 1 - ratio : ratio) + this.nzMin;
        const /** @type {?} */ points = (this.nzMarks === null ? [] : Object.keys(this.nzMarks).map(parseFloat));
        // push closest step
        if (this.nzStep !== null && !this.nzDots) {
            const /** @type {?} */ closestOne = Math.round(val / this.nzStep) * this.nzStep;
            points.push(closestOne);
        }
        // calculate gaps
        const /** @type {?} */ gaps = points.map(point => Math.abs(val - point));
        const /** @type {?} */ closest = points[gaps.indexOf(Math.min(...gaps))];
        // return the fixed
        return this.nzStep === null ? closest :
            parseFloat(closest.toFixed(this.utils.getPrecision(this.nzStep)));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    valueToOffset(value) {
        return this.utils.valueToOffset(this.nzMin, this.nzMax, value);
    }
    /**
     * @return {?}
     */
    getSliderStartPosition() {
        if (this.cacheSliderStart !== null) {
            return this.cacheSliderStart;
        }
        const /** @type {?} */ offset = this.utils.getElementOffset(this.sliderDOM);
        return this.nzVertical ? offset.top : offset.left;
    }
    /**
     * @return {?}
     */
    getSliderLength() {
        if (this.cacheSliderLength !== null) {
            return this.cacheSliderLength;
        }
        const /** @type {?} */ sliderDOM = this.sliderDOM;
        return this.nzVertical ?
            sliderDOM.clientHeight : sliderDOM.clientWidth;
    }
    /**
     * @param {?=} remove
     * @return {?}
     */
    cacheSliderProperty(remove = false) {
        this.cacheSliderStart = remove ? null : this.getSliderStartPosition();
        this.cacheSliderLength = remove ? null : this.getSliderLength();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    formatValue(value) {
        // NOTE: will return new value
        let /** @type {?} */ res = value;
        if (!this.checkValidValue(value)) {
            // if empty, use default value
            res = this.nzDefaultValue === null ?
                (this.nzRange ? [this.nzMin, this.nzMax] : this.nzMin) : this.nzDefaultValue;
        }
        else {
            // format
            // TODO: using type guard, remove type cast
            res = this.nzRange ?
                (/** @type {?} */ (value)).map(val => this.utils.correctNumLimit(val, this.nzMin, this.nzMax)) :
                this.utils.correctNumLimit(/** @type {?} */ (value), this.nzMin, this.nzMax);
        }
        return res;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    checkValidValue(value) {
        const /** @type {?} */ range = this.nzRange;
        if (value === null || value === undefined) {
            return false;
        } // it's an invalid value, just return
        const /** @type {?} */ isArray = Array.isArray(value);
        if (!Array.isArray(value)) {
            let /** @type {?} */ parsedValue = value;
            if (typeof value !== 'number') {
                parsedValue = parseFloat(value);
            }
            if (isNaN(parsedValue)) {
                return false;
            } // it's an invalid value, just return
        }
        if (isArray !== !!range) {
            // value type not match
            throw new Error(`The "nzRange" can't match the "nzValue"'s type, please check these properties: "nzRange", "nzValue", "nzDefaultValue".`);
        }
        return true;
    }
    /**
     * @param {?} value
     * @param {?} val
     * @return {?}
     */
    isValueEqual(value, val) {
        if (typeof value !== typeof val) {
            return false;
        }
        if (Array.isArray(value)) {
            const /** @type {?} */ len = value.length;
            for (let /** @type {?} */ i = 0; i < len; i++) {
                if (value[i] !== val[i]) {
                    return false;
                }
            }
            return true;
        }
        else {
            return value === val;
        }
    }
    /**
     * @param {...?} messages
     * @return {?}
     */
    log(...messages) {
        if (this.nzDebugId !== null) {
            const /** @type {?} */ args = [`[nz-slider][#${this.nzDebugId}] `].concat(Array.prototype.slice.call(arguments));
            console.log.apply(null, args);
        }
    }
    /**
     * @param {?=} handleIndex
     * @return {?}
     */
    _showHandleTooltip(handleIndex = 0) {
        this.handles.forEach((handle, index) => {
            this.handles[index].active = index === handleIndex;
        });
    }
    /**
     * @return {?}
     */
    _hideAllHandleTooltip() {
        this.handles.forEach(handle => handle.active = false);
    }
    /**
     * @param {?} amount
     * @return {?}
     */
    _generateHandles(amount) {
        const /** @type {?} */ handles = [];
        for (let /** @type {?} */ i = 0; i < amount; i++) {
            handles.push({ offset: null, value: null, active: false });
        }
        return handles;
    }
}
NzSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-slider',
                preserveWhitespaces: false,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzSliderComponent),
                        multi: true
                    }],
                template: `<div #slider [ngClass]="classMap"> <div class="ant-slider-rail"></div> <nz-slider-track nzClassName="{{prefixCls}}-track" [nzVertical]="nzVertical" [nzIncluded]="nzIncluded" [nzOffset]="track.offset" [nzLength]="track.length" ></nz-slider-track> <nz-slider-step *ngIf="marksArray" nzPrefixCls="{{prefixCls}}" [nzVertical]="nzVertical" [nzLowerBound]="bounds.lower" [nzUpperBound]="bounds.upper" [nzMarksArray]="marksArray" [nzIncluded]="nzIncluded" ></nz-slider-step> <nz-slider-handle *ngFor="let handle of handles;" nzClassName="{{prefixCls}}-handle" [nzVertical]="nzVertical" [nzOffset]="handle.offset" [nzValue]="handle.value" [nzActive]="handle.active" [nzTipFormatter]="nzTipFormatter" ></nz-slider-handle> <nz-slider-marks *ngIf="marksArray" nzClassName="{{prefixCls}}-mark" [nzVertical]="nzVertical" [nzMin]="nzMin" [nzMax]="nzMax" [nzLowerBound]="bounds.lower" [nzUpperBound]="bounds.upper" [nzMarksArray]="marksArray" [nzIncluded]="nzIncluded" ></nz-slider-marks> </div>`
            },] },
];
/** @nocollapse */
NzSliderComponent.ctorParameters = () => [
    { type: NzSliderService }
];
NzSliderComponent.propDecorators = {
    nzDebugId: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzStep: [{ type: Input }],
    nzMarks: [{ type: Input }],
    nzMin: [{ type: Input }],
    nzMax: [{ type: Input }],
    nzDefaultValue: [{ type: Input }],
    nzTipFormatter: [{ type: Input }],
    nzOnAfterChange: [{ type: Output }],
    nzVertical: [{ type: Input }],
    nzRange: [{ type: Input }],
    nzDots: [{ type: Input }],
    nzIncluded: [{ type: Input }],
    slider: [{ type: ViewChild, args: ['slider',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSliderHandleComponent {
    /**
     * @param {?} _slider
     */
    constructor(_slider) {
        this._slider = _slider;
        this.style = {};
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzActive(value) {
        // [For tooltip]
        const /** @type {?} */ show = toBoolean(value);
        if (this.tooltip) {
            if (show) {
                this.tooltip.show();
            }
            else {
                this.tooltip.hide();
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["nzOffset"]) {
            this._updateStyle();
        }
        if (changes["nzValue"]) {
            this._updateTooltipTitle(); // [For tooltip]
            this._updateTooltipPosition(); // [For tooltip]
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onMouseEnter($event) {
        if (!this._slider.isDragging) {
            this.nzActive = true;
        }
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onMouseLeave($event) {
        if (!this._slider.isDragging) {
            this.nzActive = false;
        }
    }
    /**
     * @return {?}
     */
    _updateTooltipTitle() {
        // [For tooltip]
        this.tooltipTitle = this.nzTipFormatter ? this.nzTipFormatter(this.nzValue) : `${this.nzValue}`;
    }
    /**
     * @return {?}
     */
    _updateTooltipPosition() {
        // [For tooltip]
        if (this.tooltip) {
            window.setTimeout(() => this.tooltip.updatePosition(), 0); // MAY use ngAfterViewChecked? but this will be called so many times.
        }
    }
    /**
     * @return {?}
     */
    _updateStyle() {
        this.style[this.nzVertical ? 'bottom' : 'left'] = `${this.nzOffset}%`;
    }
}
NzSliderHandleComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-slider-handle',
                preserveWhitespaces: false,
                template: `<nz-tooltip *ngIf="nzTipFormatter !== null" #tooltip [nzTitle]="tooltipTitle" [nzTrigger]="null"> <div nz-tooltip [class]="nzClassName" [ngStyle]="style"></div> </nz-tooltip> <div *ngIf="nzTipFormatter === null" [class]="nzClassName" [ngStyle]="style"></div>`
            },] },
];
/** @nocollapse */
NzSliderHandleComponent.ctorParameters = () => [
    { type: NzSliderComponent }
];
NzSliderHandleComponent.propDecorators = {
    nzClassName: [{ type: Input }],
    nzVertical: [{ type: Input }],
    nzOffset: [{ type: Input }],
    nzValue: [{ type: Input }],
    nzTipFormatter: [{ type: Input }],
    nzActive: [{ type: Input }],
    tooltip: [{ type: ViewChild, args: ['tooltip',] }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter', ['$event'],] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSliderStepComponent {
    constructor() {
        this._vertical = false;
        this._included = false;
        // Dynamic properties
        this.nzLowerBound = null;
        this.nzUpperBound = null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzVertical(value) {
        // Required
        this._vertical = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzVertical() {
        return this._vertical;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzIncluded(value) {
        this._included = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzIncluded() {
        return this._included;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["nzMarksArray"]) {
            this.buildAttrs();
        }
        if (changes["nzMarksArray"] || changes["nzLowerBound"] || changes["nzUpperBound"]) {
            this.togglePointActive();
        }
    }
    /**
     * @param {?} index
     * @param {?} attr
     * @return {?}
     */
    trackById(index, attr) {
        return attr.id;
    }
    /**
     * @return {?}
     */
    buildAttrs() {
        const /** @type {?} */ orient = this.nzVertical ? 'bottom' : 'left';
        const /** @type {?} */ prefixCls = this.nzPrefixCls;
        this.attrs = this.nzMarksArray.map(mark => {
            const { value, offset } = mark;
            return {
                id: value,
                value,
                offset,
                style: {
                    [orient]: `${offset}%`
                },
                classes: {
                    [`${prefixCls}-dot`]: true,
                    [`${prefixCls}-dot-active`]: false
                }
            };
        });
    }
    /**
     * @return {?}
     */
    togglePointActive() {
        if (this.attrs && this.nzLowerBound !== null && this.nzUpperBound !== null) {
            this.attrs.forEach(attr => {
                const /** @type {?} */ value = attr.value;
                const /** @type {?} */ isActive = (!this.nzIncluded && value === this.nzUpperBound) ||
                    (this.nzIncluded && value <= this.nzUpperBound && value >= this.nzLowerBound);
                attr.classes[`${this.nzPrefixCls}-dot-active`] = isActive;
            });
        }
    }
}
NzSliderStepComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-slider-step',
                preserveWhitespaces: false,
                template: `<div class="{{nzPrefixCls}}-step"> <span *ngFor="let attr of attrs; trackBy: trackById" [ngClass]="attr.classes" [ngStyle]="attr.style"></span> </div>`
            },] },
];
NzSliderStepComponent.propDecorators = {
    nzLowerBound: [{ type: Input }],
    nzUpperBound: [{ type: Input }],
    nzMarksArray: [{ type: Input }],
    nzPrefixCls: [{ type: Input }],
    nzVertical: [{ type: Input }],
    nzIncluded: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSliderTrackComponent {
    constructor() {
        this._vertical = false;
        this._included = false;
        this.style = {};
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzVertical(value) {
        // Required
        this._vertical = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzVertical() {
        return this._vertical;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzIncluded(value) {
        this._included = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzIncluded() {
        return this._included;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["nzIncluded"]) {
            this.style.visibility = this.nzIncluded ? 'visible' : 'hidden';
        }
        if (changes["nzVertical"] || changes["nzOffset"] || changes["nzLength"]) {
            if (this.nzVertical) {
                this.style.bottom = `${this.nzOffset}%`;
                this.style.height = `${this.nzLength}%`;
            }
            else {
                this.style.left = `${this.nzOffset}%`;
                this.style.width = `${this.nzLength}%`;
            }
        }
    }
}
NzSliderTrackComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-slider-track',
                preserveWhitespaces: false,
                template: `<div [class]="nzClassName" [ngStyle]="style"></div>`
            },] },
];
NzSliderTrackComponent.propDecorators = {
    nzOffset: [{ type: Input }],
    nzLength: [{ type: Input }],
    nzClassName: [{ type: Input }],
    nzVertical: [{ type: Input }],
    nzIncluded: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSliderModule {
}
NzSliderModule.decorators = [
    { type: NgModule, args: [{
                exports: [NzSliderComponent, NzSliderTrackComponent, NzSliderHandleComponent, NzSliderStepComponent, NzSliderMarksComponent],
                declarations: [NzSliderComponent, NzSliderTrackComponent, NzSliderHandleComponent, NzSliderStepComponent, NzSliderMarksComponent],
                imports: [CommonModule, NzToolTipModule],
                providers: [NzSliderService]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzStepComponent {
    /**
     * @param {?} elementRef
     * @param {?} nzUpdateHostClassService
     */
    constructor(elementRef, nzUpdateHostClassService) {
        this.elementRef = elementRef;
        this.nzUpdateHostClassService = nzUpdateHostClassService;
        this._status = 'wait';
        this._currentIndex = 0;
        this.isCustomStatus = false;
        this.isDescriptionString = true;
        this.isTitleString = true;
        this.isIconString = true;
        this.last = false;
        this.showProcessDot = false;
        this.direction = 'horizontal';
        this.outStatus = 'process';
        this.index = 0;
        this.el = elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTitle(value) {
        this.isTitleString = !(value instanceof TemplateRef);
        this._title = value;
    }
    /**
     * @return {?}
     */
    get nzTitle() {
        return this._title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzIcon(value) {
        this.isIconString = !(value instanceof TemplateRef);
        this._icon = value;
    }
    /**
     * @return {?}
     */
    get nzIcon() {
        return this._icon;
    }
    /**
     * @param {?} status
     * @return {?}
     */
    set nzStatus(status) {
        this._status = status;
        this.isCustomStatus = true;
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    get nzStatus() {
        return this._status;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDescription(value) {
        this.isDescriptionString = !(value instanceof TemplateRef);
        this._description = value;
    }
    /**
     * @return {?}
     */
    get nzDescription() {
        return this._description;
    }
    /**
     * @return {?}
     */
    get currentIndex() {
        return this._currentIndex;
    }
    /**
     * @param {?} current
     * @return {?}
     */
    set currentIndex(current) {
        this._currentIndex = current;
        if (!this.isCustomStatus) {
            if (current > this.index) {
                this._status = 'finish';
            }
            else if (current === this.index) {
                if (this.outStatus) {
                    this._status = this.outStatus;
                }
            }
            else {
                this._status = 'wait';
            }
        }
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    updateClassMap() {
        const /** @type {?} */ classMap = {
            ['ant-steps-item']: true,
            [`ant-steps-item-wait`]: this.nzStatus === 'wait',
            [`ant-steps-item-process`]: this.nzStatus === 'process',
            [`ant-steps-item-finish`]: this.nzStatus === 'finish',
            [`ant-steps-item-error`]: this.nzStatus === 'error',
            ['ant-steps-custom']: !!this.nzIcon,
            ['ant-steps-next-error']: (this.outStatus === 'error') && (this.currentIndex === this.index + 1)
        };
        this.nzUpdateHostClassService.updateHostClass(this.el, classMap);
    }
}
NzStepComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-step',
                providers: [NzUpdateHostClassService],
                preserveWhitespaces: false,
                template: `<ng-template #titleTemplate> <ng-template [ngTemplateOutlet]="nzTitle"></ng-template> </ng-template> <ng-template #descriptionTemplate> <ng-template [ngTemplateOutlet]="nzDescription"></ng-template> </ng-template> <div class="ant-steps-item-tail" *ngIf="last !== true"></div> <div class="ant-steps-item-icon"> <ng-template [ngIf]="!showProcessDot"> <span class="ant-steps-icon anticon anticon-check" *ngIf="nzStatus === 'finish' && !nzIcon"></span> <span class="ant-steps-icon anticon anticon-cross" *ngIf="nzStatus === 'error'"></span> <span class="ant-steps-icon" *ngIf="(nzStatus === 'process' || nzStatus === 'wait') && !nzIcon">{{ index + 1 }}</span> <span class="ant-steps-icon" *ngIf="nzIcon"> <ng-container *ngIf="isIconString; else iconTemplate"> <i [ngClass]="nzIcon"></i> </ng-container> <ng-template #iconTemplate> <ng-template [ngTemplateOutlet]="nzIcon"></ng-template> </ng-template> </span> </ng-template> <ng-template [ngIf]="showProcessDot"> <span class="ant-steps-icon"> <ng-template #processDotTemplate> <span class="ant-steps-icon-dot"></span> </ng-template> <ng-template [ngTemplateOutlet]="customProcessTemplate||processDotTemplate" [ngTemplateOutletContext]="{ $implicit: processDotTemplate, status:nzStatus, index:index }"></ng-template> </span> </ng-template> </div> <div class="ant-steps-item-content"> <div class="ant-steps-item-title"> <ng-container *ngIf="isTitleString; else titleTemplate">{{ nzTitle }}</ng-container> </div> <div class="ant-steps-item-description"> <ng-container *ngIf="isDescriptionString; else descriptionTemplate">{{ nzDescription }}</ng-container> </div> </div>`
            },] },
];
/** @nocollapse */
NzStepComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NzUpdateHostClassService }
];
NzStepComponent.propDecorators = {
    processDotTemplate: [{ type: ViewChild, args: ['processDotTemplate',] }],
    nzTitle: [{ type: Input }],
    nzIcon: [{ type: Input }],
    nzStatus: [{ type: Input }],
    nzDescription: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzStepsComponent {
    constructor() {
        this._status = 'process';
        this._current = 0;
        this._size = 'default';
        this._direction = 'horizontal';
        this.unsubscribe$ = new Subject();
        this.showProcessDot = false;
        this.updateChildrenSteps = () => {
            if (this.steps) {
                this.steps.toArray().forEach((step, index, arr) => {
                    step.outStatus = this.nzStatus;
                    step.showProcessDot = this.showProcessDot;
                    if (this.customProcessDotTemplate) {
                        step.customProcessTemplate = this.customProcessDotTemplate;
                    }
                    step.direction = this.nzDirection;
                    step.index = index;
                    step.currentIndex = this.nzCurrent;
                    step.last = arr.length === index + 1;
                    step.updateClassMap();
                });
            }
        };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this._size = value;
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDirection(value) {
        this._direction = value;
        this.updateClassMap();
        this.updateChildrenSteps();
    }
    /**
     * @return {?}
     */
    get nzDirection() {
        return this._direction;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzProgressDot(value) {
        if (value instanceof TemplateRef) {
            this.showProcessDot = true;
            this.customProcessDotTemplate = value;
        }
        else {
            this.showProcessDot = toBoolean(value);
        }
        this.updateChildrenSteps();
        this.updateClassMap();
    }
    /**
     * @param {?} status
     * @return {?}
     */
    set nzStatus(status) {
        this._status = status;
        this.updateChildrenSteps();
    }
    /**
     * @return {?}
     */
    get nzStatus() {
        return this._status;
    }
    /**
     * @param {?} current
     * @return {?}
     */
    set nzCurrent(current) {
        this._current = current;
        this.updateChildrenSteps();
    }
    /**
     * @return {?}
     */
    get nzCurrent() {
        return this._current;
    }
    /**
     * @return {?}
     */
    updateClassMap() {
        this.stepsClassMap = {
            [`ant-steps-${this.nzDirection}`]: true,
            [`ant-steps-label-horizontal`]: this.nzDirection === 'horizontal',
            [`ant-steps-label-vertical`]: this.showProcessDot && (this.nzDirection === 'horizontal'),
            [`ant-steps-dot`]: this.showProcessDot,
            ['ant-steps-small']: this.nzSize === 'small'
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        Promise.resolve().then(() => this.updateChildrenSteps());
        if (this.steps) {
            this.steps.changes.pipe(takeUntil(this.unsubscribe$)).subscribe(this.updateChildrenSteps);
        }
    }
}
NzStepsComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-steps',
                preserveWhitespaces: false,
                template: `<div class="ant-steps" [ngClass]="stepsClassMap"> <ng-content></ng-content> </div>`
            },] },
];
NzStepsComponent.propDecorators = {
    steps: [{ type: ContentChildren, args: [NzStepComponent,] }],
    nzSize: [{ type: Input }],
    nzDirection: [{ type: Input }],
    nzProgressDot: [{ type: Input }],
    nzStatus: [{ type: Input }],
    nzCurrent: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzStepsModule {
}
NzStepsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [NzStepsComponent, NzStepComponent],
                declarations: [NzStepsComponent, NzStepComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSwitchComponent {
    constructor() {
        this._disabled = false;
        this._loading = false;
        this._control = false;
        this.prefixCls = 'ant-switch';
        this.checked = false;
        this.onChange = () => null;
        this.onTouched = () => null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzControl(value) {
        this._control = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzControl() {
        return this._control;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzCheckedChildren(value) {
        this.isCheckedChildrenString = !(value instanceof TemplateRef);
        this._checkedChildren = value;
    }
    /**
     * @return {?}
     */
    get nzCheckedChildren() {
        return this._checkedChildren;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzUnCheckedChildren(value) {
        this.isUnCheckedChildrenString = !(value instanceof TemplateRef);
        this._unCheckedChildren = value;
    }
    /**
     * @return {?}
     */
    get nzUnCheckedChildren() {
        return this._unCheckedChildren;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this._size = value;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzLoading(value) {
        this._loading = toBoolean(value);
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzLoading() {
        return this._loading;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
        e.preventDefault();
        if ((!this.nzDisabled) && (!this.nzLoading) && (!this.nzControl)) {
            this.updateValue(!this.checked, true);
        }
    }
    /**
     * @param {?} value
     * @param {?} emit
     * @return {?}
     */
    updateValue(value, emit) {
        if (this.checked === value) {
            return;
        }
        this.checked = value;
        this.setClassMap();
        if (emit) {
            this.onChange(this.checked);
        }
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-checked`]: this.checked,
            [`${this.prefixCls}-loading`]: this.nzLoading,
            [`${this.prefixCls}-disabled`]: this.nzDisabled,
            [`${this.prefixCls}-small`]: this.nzSize === 'small'
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        if (!this.nzControl) {
            if (e.keyCode === 37) {
                // Left
                this.updateValue(false, true);
                e.preventDefault();
            }
            else if (e.keyCode === 39) {
                // Right
                this.updateValue(true, true);
                e.preventDefault();
            }
            else if (e.keyCode === 32 || e.keyCode === 13) {
                // Space, Enter
                this.updateValue(!this.checked, true);
                e.preventDefault();
            }
        }
    }
    /**
     * @return {?}
     */
    focus() {
        this.switchElement.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    blur() {
        this.switchElement.nativeElement.blur();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.updateValue(value, false);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
    }
}
NzSwitchComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-switch',
                preserveWhitespaces: false,
                template: `<span [ngClass]="classMap" [tabindex]="nzDisabled?-1:0" #switchElement (keydown)="onKeyDown($event)"> <span class="ant-switch-inner"> <span *ngIf="checked"> <ng-container *ngIf="isCheckedChildrenString; else checkedChildrenTemplate">{{ nzCheckedChildren }}</ng-container> <ng-template #checkedChildrenTemplate> <ng-template [ngTemplateOutlet]="nzCheckedChildren"></ng-template> </ng-template> </span> <span *ngIf="!checked"> <ng-container *ngIf="isUnCheckedChildrenString; else unCheckedChildrenTemplate">{{ nzUnCheckedChildren }}</ng-container> <ng-template #unCheckedChildrenTemplate> <ng-template [ngTemplateOutlet]="nzUnCheckedChildren"></ng-template> </ng-template> </span> </span> </span>`,
                styles: [`
    :host {
      display: inline-block;
    }
  `],
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzSwitchComponent),
                        multi: true
                    }
                ]
            },] },
];
NzSwitchComponent.propDecorators = {
    switchElement: [{ type: ViewChild, args: ['switchElement',] }],
    nzControl: [{ type: Input }],
    nzCheckedChildren: [{ type: Input }],
    nzUnCheckedChildren: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzLoading: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzSwitchModule {
}
NzSwitchModule.decorators = [
    { type: NgModule, args: [{
                exports: [NzSwitchComponent],
                declarations: [NzSwitchComponent],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class NzThComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._sort = null;
        this._filters = [];
        this._showSort = false;
        this._showFilter = false;
        this._showCheckbox = false;
        this._showRowSelection = false;
        this.hasFilterValue = false;
        this.multipleFilterList = [];
        this.singleFilterList = [];
        /* tslint:disable-next-line:no-any */
        this.nzSelections = [];
        this.nzChecked = false;
        this.nzDisabled = false;
        this.nzIndeterminate = false;
        this.nzFilterMultiple = true;
        this.nzCheckedChange = new EventEmitter();
        this.nzSortChange = new EventEmitter();
        this.nzSortChangeWithKey = new EventEmitter();
        /* tslint:disable-next-line:no-any */
        this.nzFilterChange = new EventEmitter();
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    get hasFiltersClass() {
        return this.nzShowSort || this.nzShowFilter;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowSort(value) {
        this._showSort = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowSort() {
        return this._showSort;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowFilter(value) {
        this._showFilter = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowFilter() {
        return this._showFilter;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowRowSelection(value) {
        this._showRowSelection = toBoolean(value);
        if (this._showRowSelection) {
            this.renderer.addClass(this.el, 'ant-table-selection-column-custom');
        }
        else {
            this.renderer.removeClass(this.el, 'ant-table-selection-column-custom');
        }
    }
    /**
     * @return {?}
     */
    get nzShowRowSelection() {
        return this._showRowSelection;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzLeft(value) {
        if (isNotNil(value)) {
            this.renderer.addClass(this.el, 'ant-table-th-left-sticky');
            this.renderer.setStyle(this.el, 'left', value);
        }
        else {
            this.renderer.removeClass(this.el, 'ant-table-th-left-sticky');
            this.renderer.removeStyle(this.el, 'left');
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzRight(value) {
        if (isNotNil(value)) {
            this.renderer.addClass(this.el, 'ant-table-th-right-sticky');
            this.renderer.setStyle(this.el, 'right', value);
        }
        else {
            this.renderer.removeClass(this.el, 'ant-table-th-right-sticky');
            this.renderer.removeStyle(this.el, 'right');
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzExpand(value) {
        const /** @type {?} */ isExpand = toBoolean(value);
        if (isExpand) {
            this.renderer.addClass(this.el, 'ant-table-expand-icon-th');
        }
        else {
            this.renderer.removeClass(this.el, 'ant-table-expand-icon-th');
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowCheckbox(value) {
        this._showCheckbox = toBoolean(value);
        if (this._showCheckbox) {
            this.renderer.addClass(this.el, 'ant-table-selection-column');
        }
        else {
            this.renderer.removeClass(this.el, 'ant-table-selection-column');
        }
    }
    /**
     * @return {?}
     */
    get nzShowCheckbox() {
        return this._showCheckbox;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSort(value) {
        this._sort = value;
        if ((value !== 'ascend') && (value !== 'descend')) {
            this.renderer.removeClass(this.el, 'ant-table-column-sort');
        }
        else {
            this.renderer.addClass(this.el, 'ant-table-column-sort');
        }
    }
    /**
     * @return {?}
     */
    get nzSort() {
        return this._sort;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setSortValue(value) {
        if (this.nzSort === value) {
            this.nzSort = null;
        }
        else {
            this.nzSort = value;
        }
        this.nzSortChangeWithKey.emit({ key: this.nzSortKey, value: this.nzSort });
        this.nzSortChange.emit(this.nzSort);
    }
    /**
     * @return {?}
     */
    get filterList() {
        return this.multipleFilterList.filter(item => item.checked).map(item => item.value);
    }
    /**
     * @return {?}
     */
    get filterValue() {
        const /** @type {?} */ checkedFilter = this.singleFilterList.find(item => item.checked);
        return checkedFilter ? checkedFilter.value : null;
    }
    /**
     * @return {?}
     */
    updateFilterStatus() {
        if (this.nzFilterMultiple) {
            this.hasFilterValue = this.filterList.length > 0;
        }
        else {
            this.hasFilterValue = isNotNil(this.filterValue);
        }
    }
    /**
     * @return {?}
     */
    search() {
        this.updateFilterStatus();
        if (this.nzFilterMultiple) {
            this.nzFilterChange.emit(this.filterList);
        }
        else {
            this.nzFilterChange.emit(this.filterValue);
        }
        this.hideDropDown();
    }
    /**
     * @return {?}
     */
    reset() {
        this.initMultipleFilterList();
        this.initSingleFilterList();
        this.search();
        this.hideDropDown();
        this.hasFilterValue = false;
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    checkMultiple(filter$$1) {
        filter$$1.checked = !filter$$1.checked;
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    checkSingle(filter$$1) {
        this.singleFilterList.forEach(item => item.checked = item === filter$$1);
    }
    /**
     * @return {?}
     */
    hideDropDown() {
        this.nzDropDownComponent.nzVisible = false;
        this.nzDropDownComponent.hide();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    dropDownVisibleChange(value) {
        if (!value) {
            this.search();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzFilters(value) {
        if (Array.isArray(value)) {
            this._filters = value;
            this.initMultipleFilterList();
            this.initSingleFilterList();
            this.updateFilterStatus();
        }
        else {
            console.warn('nzFilters only accept type of Array<{ text: string; value: any }>');
        }
    }
    /**
     * @return {?}
     */
    get nzFilters() {
        return this._filters;
    }
    /**
     * @return {?}
     */
    initMultipleFilterList() {
        this.multipleFilterList = this.nzFilters.map(item => {
            return { text: item.text, value: item.value, checked: false };
        });
    }
    /**
     * @return {?}
     */
    initSingleFilterList() {
        this.singleFilterList = this.nzFilters.map(item => {
            return { text: item.text, value: item.value, checked: false };
        });
    }
}
NzThComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'th:not(.nz-disable-th)',
                preserveWhitespaces: false,
                template: `<ng-template #checkboxTemplate> <label [class.ant-table-selection-select-all-custom]="nzShowRowSelection" nz-checkbox [(ngModel)]="nzChecked" [nzDisabled]="nzDisabled" [nzIndeterminate]="nzIndeterminate" (ngModelChange)="nzCheckedChange.emit($event)"> </label> </ng-template> <div class="ant-table-selection" *ngIf="nzShowRowSelection"> <ng-container *ngIf="nzShowCheckbox"> <ng-template [ngTemplateOutlet]="checkboxTemplate"></ng-template> </ng-container> <nz-dropdown nzPlacement="bottomLeft"> <div nz-dropdown class="ant-table-selection-down"> <i class="anticon anticon-down"></i> </div> <ul nz-menu class="ant-table-selection-menu"> <li nz-menu-item *ngFor="let selection of nzSelections" (click)="selection.onSelect()">{{selection.text}}</li> </ul> </nz-dropdown> </div> <ng-container *ngIf="nzShowCheckbox && !nzShowRowSelection"> <ng-template [ngTemplateOutlet]="checkboxTemplate"></ng-template> </ng-container> <ng-content></ng-content> <div class="ant-table-column-sorter" *ngIf="nzShowSort"> <span class="ant-table-column-sorter-up" [class.on]="nzSort == 'ascend'" [class.off]="nzSort != 'ascend'" title="↑" (click)="setSortValue('ascend')"> <i class="anticon anticon-caret-up"></i> </span> <span class="ant-table-column-sorter-down" [class.on]="nzSort == 'descend'" [class.off]="nzSort != 'descend'" title="↓" (click)="setSortValue('descend')"> <i class="anticon anticon-caret-down"></i> </span> </div> <nz-dropdown nzTrigger="click" *ngIf="nzShowFilter" [nzClickHide]="false" [hasFilterButton]="true" (nzVisibleChange)="dropDownVisibleChange($event)"> <i class="anticon anticon-filter" [class.ant-table-filter-selected]="hasFilterValue" nz-dropdown></i> <ul nz-menu> <ng-container *ngIf="nzFilterMultiple"> <li nz-menu-item *ngFor="let filter of multipleFilterList" (click)="checkMultiple(filter)"> <label nz-checkbox [ngModel]="filter.checked"></label><span>{{filter.text}}</span> </li> </ng-container> <ng-container *ngIf="!nzFilterMultiple"> <li nz-menu-item *ngFor="let filter of singleFilterList" (click)="checkSingle(filter)"> <label nz-radio [ngModel]="filter.checked">{{filter.text}}</label> </li> </ng-container> </ul> <div class="ant-table-filter-dropdown-btns"> <a class="ant-table-filter-dropdown-link confirm" (click)="hideDropDown()"> <span (click)="search()">{{'Table.filterConfirm' | nzI18n}}</span> </a> <a class="ant-table-filter-dropdown-link clear" (click)="hideDropDown()"> <span (click)="reset()">{{'Table.filterReset' | nzI18n}}</span> </a> </div> </nz-dropdown>`
            },] },
];
/** @nocollapse */
NzThComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NzThComponent.propDecorators = {
    nzSelections: [{ type: Input }],
    nzChecked: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzIndeterminate: [{ type: Input }],
    nzSortKey: [{ type: Input }],
    nzFilterMultiple: [{ type: Input }],
    nzWidth: [{ type: Input }],
    nzCheckedChange: [{ type: Output }],
    nzDropDownComponent: [{ type: ViewChild, args: [NzDropDownComponent,] }],
    nzSortChange: [{ type: Output }],
    nzSortChangeWithKey: [{ type: Output }],
    nzFilterChange: [{ type: Output }],
    hasFiltersClass: [{ type: HostBinding, args: ['class.ant-table-column-has-filters',] }],
    nzShowSort: [{ type: Input }],
    nzShowFilter: [{ type: Input }],
    nzShowRowSelection: [{ type: Input }],
    nzLeft: [{ type: Input }],
    nzRight: [{ type: Input }],
    nzExpand: [{ type: Input }],
    nzShowCheckbox: [{ type: Input }],
    nzSort: [{ type: Input }],
    nzFilters: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTableComponent {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     * @param {?} overlay
     * @param {?} nzMeasureScrollbarService
     * @param {?} i18n
     */
    constructor(elementRef, cdr, overlay, nzMeasureScrollbarService, i18n) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlay = overlay;
        this.nzMeasureScrollbarService = nzMeasureScrollbarService;
        this.i18n = i18n;
        this.unsubscribe$ = new Subject();
        this._bordered = false;
        this._showPagination = true;
        this._loading = false;
        this._showSizeChanger = false;
        this._showQuickJumper = false;
        this._hideOnSinglePage = false;
        this._scroll = { x: null, y: null };
        this._pageIndex = 1;
        this._pageSize = 10;
        this._widthConfig = [];
        this._frontPagination = true;
        this._simple = false;
        /* tslint:disable-next-line:no-any */
        this.locale = {};
        this.lastScrollLeft = 0;
        /* tslint:disable-next-line:no-any */
        this.rawData = [];
        /* tslint:disable-next-line:no-any */
        this.syncData = [];
        /**
         * public data for ngFor tr
         */
        this.data = [];
        this.isWidthConfigSet = false;
        this.nzPageSizeChange = new EventEmitter();
        this.nzPageIndexChange = new EventEmitter();
        /* tslint:disable-next-line:no-any */
        this.nzCurrentPageDataChange = new EventEmitter();
        this.nzSize = 'default';
        /**
         * page size changer select values
         */
        this.nzPageSizeOptions = [10, 20, 30, 40, 50];
        this.nzLoadingDelay = 0;
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSimple(value) {
        this._simple = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzSimple() {
        return this._simple;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzFrontPagination(value) {
        this._frontPagination = toBoolean(value);
        this.parseInputData();
    }
    /**
     * @return {?}
     */
    get nzFrontPagination() {
        return this._frontPagination;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzWidthConfig(value) {
        this.isWidthConfigSet = true;
        this._widthConfig = value;
    }
    /**
     * @return {?}
     */
    get nzWidthConfig() {
        return this._widthConfig;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTitle(value) {
        this.isTitleString = !(value instanceof TemplateRef);
        this._title = value;
    }
    /**
     * @return {?}
     */
    get nzTitle() {
        return this._title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzFooter(value) {
        this.isFooterString = !(value instanceof TemplateRef);
        this._footer = value;
    }
    /**
     * @return {?}
     */
    get nzFooter() {
        return this._footer;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzNoResult(value) {
        this.isNoResultString = !(value instanceof TemplateRef);
        this._noResult = value;
    }
    /**
     * @return {?}
     */
    get nzNoResult() {
        return this._noResult;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzBordered(value) {
        this._bordered = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzBordered() {
        return this._bordered;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowPagination(value) {
        this._showPagination = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowPagination() {
        return this._showPagination;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzLoading(value) {
        this._loading = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzLoading() {
        return this._loading;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowSizeChanger(value) {
        this._showSizeChanger = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowSizeChanger() {
        return this._showSizeChanger;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzHideOnSinglePage(value) {
        this._hideOnSinglePage = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzHideOnSinglePage() {
        return this._hideOnSinglePage;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowQuickJumper(value) {
        this._showQuickJumper = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowQuickJumper() {
        return this._showQuickJumper;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzScroll(value) {
        if (isNotNil(value)) {
            this._scroll = value;
        }
        else {
            this._scroll = { x: null, y: null };
        }
        this.cdr.detectChanges();
        this.setScrollPositionClassName();
    }
    /**
     * @return {?}
     */
    get nzScroll() {
        return this._scroll;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set nzData(data) {
        if (Array.isArray(data)) {
            this.rawData = data;
            this.parseInputData();
        }
        else {
            console.warn('nzData only accept array');
        }
    }
    /**
     * @return {?}
     */
    parseInputData() {
        if (this.nzFrontPagination) {
            this.syncData = this.rawData;
            this.nzTotal = this.syncData.length;
            this.checkPageIndexBounding();
            this.generateSyncDisplayData();
        }
        else {
            this.data = this.rawData;
            this.nzCurrentPageDataChange.emit(this.data);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPageIndex(value) {
        if (this._pageIndex === value) {
            return;
        }
        this._pageIndex = value;
        if (this.nzFrontPagination) {
            this.generateSyncDisplayData();
        }
    }
    /**
     * @return {?}
     */
    get nzPageIndex() {
        return this._pageIndex;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    emitPageIndex(index) {
        this.nzPageIndex = index;
        this.nzPageIndexChange.emit(this.nzPageIndex);
    }
    /**
     * @param {?} size
     * @return {?}
     */
    emitPageSize(size) {
        this.nzPageSize = size;
        this.nzPageSizeChange.emit(this.nzPageSize);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPageSize(value) {
        if (this._pageSize === value) {
            return;
        }
        this._pageSize = value;
        if (this.nzFrontPagination) {
            this.checkPageIndexBounding();
            this.generateSyncDisplayData();
        }
    }
    /**
     * @return {?}
     */
    get nzPageSize() {
        return this._pageSize;
    }
    /**
     * @return {?}
     */
    checkPageIndexBounding() {
        if (this.nzFrontPagination) {
            const /** @type {?} */ maxPageIndex = Math.ceil(this.syncData.length / this.nzPageSize);
            const /** @type {?} */ pageIndex = !this.nzPageIndex ? 1 : (this.nzPageIndex > maxPageIndex ? maxPageIndex : this.nzPageIndex);
            if (pageIndex !== this.nzPageIndex) {
                this._pageIndex = pageIndex;
                Promise.resolve().then(() => this.nzPageIndexChange.emit(pageIndex));
            }
        }
    }
    /**
     * @return {?}
     */
    generateSyncDisplayData() {
        this.data = this.syncData.slice((this.nzPageIndex - 1) * this.nzPageSize, this.nzPageIndex * this.nzPageSize);
        this.nzCurrentPageDataChange.emit(this.data);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    syncScrollTable(e) {
        if (e.currentTarget === e.target) {
            const /** @type {?} */ target = /** @type {?} */ (e.target);
            if (target.scrollLeft !== this.lastScrollLeft && this.nzScroll && this.nzScroll.x) {
                if (target === this.tableBodyElement.nativeElement && this.tableHeaderElement) {
                    this.tableHeaderElement.nativeElement.scrollLeft = target.scrollLeft;
                }
                else if (target === this.tableHeaderElement.nativeElement && this.tableBodyElement) {
                    this.tableBodyElement.nativeElement.scrollLeft = target.scrollLeft;
                }
                this.setScrollPositionClassName();
            }
            this.lastScrollLeft = target.scrollLeft;
        }
    }
    /**
     * @return {?}
     */
    setScrollPositionClassName() {
        if (this.tableBodyElement && this.nzScroll && this.nzScroll.x) {
            if ((this.tableBodyElement.nativeElement.scrollWidth === this.tableBodyElement.nativeElement.clientWidth) && (this.tableBodyElement.nativeElement.scrollWidth !== 0)) {
                this.scrollPosition = 'default';
            }
            else if (this.tableBodyElement.nativeElement.scrollLeft === 0) {
                this.scrollPosition = 'left';
            }
            else if (this.tableBodyElement.nativeElement.scrollWidth === (this.tableBodyElement.nativeElement.scrollLeft + this.tableBodyElement.nativeElement.clientWidth)) {
                this.scrollPosition = 'right';
            }
            else {
                this.scrollPosition = 'middle';
            }
        }
    }
    /**
     * @return {?}
     */
    fitScrollBar() {
        const /** @type {?} */ scrollbarWidth = this.nzMeasureScrollbarService.scrollBarWidth;
        if (scrollbarWidth) {
            this.headerBottomStyle = {
                marginBottom: `-${scrollbarWidth}px`,
                paddingBottom: `0px`
            };
        }
    }
    /**
     * @return {?}
     */
    onWindowResize() {
        this.fitScrollBar();
        this.setScrollPositionClassName();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.i18n.localeChange.pipe(takeUntil(this.unsubscribe$)).subscribe(() => this.locale = this.i18n.getLocaleData('Table'));
        this.fitScrollBar();
        if (this.nzScroll && this.nzScroll.x && this.nzScroll.y) {
            /**
             * magic code to sync scroll *
             */
            const /** @type {?} */ overlay = this.overlay.create();
            overlay.dispose();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout(() => this.setScrollPositionClassName());
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
}
NzTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-table',
                preserveWhitespaces: false,
                template: `<ng-template #colGroupTemplate> <colgroup *ngIf="!isWidthConfigSet"> <col [style.width]="th.nzWidth" [style.minWidth]="th.nzWidth" *ngFor="let th of listOfNzThComponent"> </colgroup> <colgroup *ngIf="isWidthConfigSet"> <col [style.width]="width" [style.minWidth]="width" *ngFor="let width of nzWidthConfig"> </colgroup> </ng-template> <ng-template #tableInnerTemplate> <div #tableHeaderElement *ngIf="nzScroll.x || nzScroll.y" class="ant-table-header" (scroll)="syncScrollTable($event)" [ngStyle]="headerBottomStyle"> <table [class.ant-table-fixed]="nzScroll.x" [style.width]="nzScroll.x"> <ng-template [ngTemplateOutlet]="colGroupTemplate"></ng-template> <thead class="ant-table-thead" *ngIf="nzScroll.y"> <ng-template [ngTemplateOutlet]="nzTheadComponent?.template"></ng-template> </thead> </table> </div> <div #tableBodyElement class="ant-table-body" (scroll)="syncScrollTable($event)" [style.maxHeight]="nzScroll.y" [style.overflow-y]="nzScroll.y?'scroll':''" [style.overflow-x]="nzScroll.x?'auto':''"> <table [class.ant-table-fixed]="nzScroll.x" [style.width]="nzScroll.x"> <ng-template [ngTemplateOutlet]="colGroupTemplate"></ng-template> <thead class="ant-table-thead" *ngIf="!nzScroll.y"> <ng-template [ngTemplateOutlet]="nzTheadComponent?.template"></ng-template> </thead> <ng-content></ng-content> </table> </div> <div class="ant-table-placeholder" *ngIf="(data.length==0)&&!nzLoading"> <span *ngIf="!nzNoResult">{{ locale.emptyText }}</span> <ng-container *ngIf="nzNoResult"> <ng-container *ngIf="isNoResultString; else noResultTemplate">{{ nzNoResult }}</ng-container> <ng-template #noResultTemplate> <ng-template [ngTemplateOutlet]="nzNoResult"></ng-template> </ng-template> </ng-container> </div> <div class="ant-table-footer" *ngIf="nzFooter"> <ng-container *ngIf="isFooterString; else footerTemplate">{{ nzFooter }}</ng-container> <ng-template #footerTemplate> <ng-template [ngTemplateOutlet]="nzFooter"></ng-template> </ng-template> </div> </ng-template> <div class="ant-table-wrapper" [class.ant-table-empty]="data.length==0"> <nz-spin [nzDelay]="nzLoadingDelay" [nzSpinning]="nzLoading"> <div> <div class="ant-table" [class.ant-table-fixed-header]="nzScroll.x || nzScroll.y" [class.ant-table-scroll-position-left]="scrollPosition==='left'" [class.ant-table-scroll-position-right]="scrollPosition==='right'" [class.ant-table-scroll-position-middle]="scrollPosition==='middle'" [class.ant-table-bordered]="nzBordered" [class.ant-table-large]="nzSize=='default'" [class.ant-table-middle]="nzSize=='middle'" [class.ant-table-small]="nzSize=='small'"> <div class="ant-table-title" *ngIf="nzTitle"> <ng-container *ngIf="isTitleString; else titleTemplate">{{ nzTitle }}</ng-container> <ng-template #titleTemplate> <ng-template [ngTemplateOutlet]="nzTitle"></ng-template> </ng-template> </div> <div class="ant-table-content"> <ng-container *ngIf="nzScroll.x || nzScroll.y; else tableInnerTemplate"> <div class="ant-table-scroll"> <ng-template [ngTemplateOutlet]="tableInnerTemplate"></ng-template> </div> </ng-container> </div> </div> </div> <nz-pagination *ngIf="nzShowPagination&&data.length" [nzInTable]="true" [nzShowSizeChanger]="nzShowSizeChanger" [nzPageSizeOptions]="nzPageSizeOptions" [nzShowQuickJumper]="nzShowQuickJumper" [nzHideOnSinglePage]="nzHideOnSinglePage" [nzShowTotal]="nzShowTotal" [nzSize]="(nzSize=='middle'||nzSize=='small')?'small':''" [nzPageSize]="nzPageSize" (nzPageSizeChange)="emitPageSize($event)" [nzTotal]="nzTotal" [nzSimple]="nzSimple" [nzPageIndex]="nzPageIndex" (nzPageIndexChange)="emitPageIndex($event)"> </nz-pagination> </nz-spin> </div>`
            },] },
];
/** @nocollapse */
NzTableComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Overlay },
    { type: NzMeasureScrollbarService },
    { type: NzI18nService }
];
NzTableComponent.propDecorators = {
    tableHeaderElement: [{ type: ViewChild, args: ['tableHeaderElement',] }],
    tableBodyElement: [{ type: ViewChild, args: ['tableBodyElement',] }],
    listOfNzThComponent: [{ type: ContentChildren, args: [NzThComponent, { descendants: true },] }],
    nzPageSizeChange: [{ type: Output }],
    nzPageIndexChange: [{ type: Output }],
    nzShowTotal: [{ type: Input }],
    nzCurrentPageDataChange: [{ type: Output }],
    nzSize: [{ type: Input }],
    nzPageSizeOptions: [{ type: Input }],
    nzLoadingDelay: [{ type: Input }],
    nzTotal: [{ type: Input }],
    nzSimple: [{ type: Input }],
    nzFrontPagination: [{ type: Input }],
    nzWidthConfig: [{ type: Input }],
    nzTitle: [{ type: Input }],
    nzFooter: [{ type: Input }],
    nzNoResult: [{ type: Input }],
    nzBordered: [{ type: Input }],
    nzShowPagination: [{ type: Input }],
    nzLoading: [{ type: Input }],
    nzShowSizeChanger: [{ type: Input }],
    nzHideOnSinglePage: [{ type: Input }],
    nzShowQuickJumper: [{ type: Input }],
    nzScroll: [{ type: Input }],
    nzData: [{ type: Input }],
    nzPageIndex: [{ type: Input }],
    nzPageSize: [{ type: Input }],
    onWindowResize: [{ type: HostListener, args: ['window:resize',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTbodyDirective {
    /**
     * @param {?} nzTableComponent
     */
    constructor(nzTableComponent) {
        this.nzTableComponent = nzTableComponent;
    }
}
NzTbodyDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'tbody',
                host: {
                    '[class.ant-table-tbody]': 'nzTableComponent'
                }
            },] },
];
/** @nocollapse */
NzTbodyDirective.ctorParameters = () => [
    { type: NzTableComponent, decorators: [{ type: Host }, { type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTdComponent {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._showExpand = false;
        this._expand = false;
        this._showCheckbox = false;
        this.isIndentSizeSet = false;
        this.nzChecked = false;
        this.nzDisabled = false;
        this.nzIndeterminate = false;
        this.nzCheckedChange = new EventEmitter();
        this.nzExpandChange = new EventEmitter();
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzIndentSize(value) {
        this._indentSize = value;
        this.isIndentSizeSet = isNotNil(value);
        this.updateExpandIconClass();
    }
    /**
     * @return {?}
     */
    get nzIndentSize() {
        return this._indentSize;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzExpand(value) {
        this._expand = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzExpand() {
        return this._expand;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowExpand(value) {
        this._showExpand = toBoolean(value);
        this.updateExpandIconClass();
    }
    /**
     * @return {?}
     */
    get nzShowExpand() {
        return this._showExpand;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowCheckbox(value) {
        this._showCheckbox = toBoolean(value);
        if (this._showCheckbox) {
            this.renderer.addClass(this.el, 'ant-table-selection-column');
        }
        else {
            this.renderer.removeClass(this.el, 'ant-table-selection-column');
        }
    }
    /**
     * @return {?}
     */
    get nzShowCheckbox() {
        return this._showCheckbox;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzLeft(value) {
        if (isNotNil(value)) {
            this.renderer.addClass(this.el, 'ant-table-td-left-sticky');
            this.renderer.setStyle(this.el, 'left', value);
        }
        else {
            this.renderer.removeClass(this.el, 'ant-table-td-left-sticky');
            this.renderer.removeStyle(this.el, 'left');
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzRight(value) {
        if (isNotNil(value)) {
            this.renderer.addClass(this.el, 'ant-table-td-right-sticky');
            this.renderer.setStyle(this.el, 'right', value);
        }
        else {
            this.renderer.removeClass(this.el, 'ant-table-td-right-sticky');
            this.renderer.removeStyle(this.el, 'right');
        }
    }
    /**
     * @return {?}
     */
    updateExpandIconClass() {
        if (this.nzShowExpand && !this.isIndentSizeSet) {
            this.renderer.addClass(this.el, 'ant-table-row-expand-icon-cell');
        }
        else {
            this.renderer.removeClass(this.el, 'ant-table-row-expand-icon-cell');
        }
    }
    /**
     * @return {?}
     */
    expandChange() {
        this.nzExpand = !this.nzExpand;
        this.nzExpandChange.emit(this.nzExpand);
    }
}
NzTdComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'td:not(.nz-disable-td)',
                template: `<span class="ant-table-row-indent" *ngIf="nzIndentSize" [style.padding-left.px]="nzIndentSize"></span> <label *ngIf="nzShowCheckbox" nz-checkbox [nzDisabled]="nzDisabled" [(ngModel)]="nzChecked" [nzIndeterminate]="nzIndeterminate" (ngModelChange)="nzCheckedChange.emit($event)"> </label> <span *ngIf="nzShowExpand" class="ant-table-row-expand-icon" (click)="expandChange()" [class.ant-table-row-expanded]="nzExpand" [class.ant-table-row-collapsed]="!nzExpand"></span> <ng-content></ng-content>`
            },] },
];
/** @nocollapse */
NzTdComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NzTdComponent.propDecorators = {
    nzChecked: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzIndeterminate: [{ type: Input }],
    nzCheckedChange: [{ type: Output }],
    nzExpandChange: [{ type: Output }],
    nzIndentSize: [{ type: Input }],
    nzExpand: [{ type: Input }],
    nzShowExpand: [{ type: Input }],
    nzShowCheckbox: [{ type: Input }],
    nzLeft: [{ type: Input }],
    nzRight: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTheadComponent {
    /**
     * @param {?} nzTableComponent
     */
    constructor(nzTableComponent) {
        this.nzTableComponent = nzTableComponent;
        this._singleSort = false;
        this.unsubscribe$ = new Subject();
        this.nzSortChange = new EventEmitter();
        if (this.nzTableComponent) {
            this.nzTableComponent.nzTheadComponent = this;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSingleSort(value) {
        this._singleSort = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzSingleSort() {
        return this._singleSort;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        let /** @type {?} */ sortChange = new Subject().asObservable();
        const /** @type {?} */ listOfTh = this.listOfNzThComponent.toArray();
        const /** @type {?} */ sortChangeArray = listOfTh.map(th => th.nzSortChangeWithKey);
        if (sortChangeArray.length) {
            sortChangeArray.forEach(sort => {
                sortChange = merge(sort.asObservable(), sortChange);
            });
        }
        sortChange.pipe(takeUntil(this.unsubscribe$)).subscribe(data => {
            this.nzSortChange.emit(data);
            if (this.nzSingleSort) {
                listOfTh.forEach(th => th.nzSort = (th.nzSortKey === data.key ? th.nzSort : null));
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
}
NzTheadComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'thead:not(.ant-table-thead)',
                template: `<ng-template #contentTemplate> <ng-content></ng-content> </ng-template> <ng-container *ngIf="!nzTableComponent"> <ng-template [ngTemplateOutlet]="contentTemplate"></ng-template> </ng-container>`
            },] },
];
/** @nocollapse */
NzTheadComponent.ctorParameters = () => [
    { type: NzTableComponent, decorators: [{ type: Host }, { type: Optional }] }
];
NzTheadComponent.propDecorators = {
    template: [{ type: ViewChild, args: ['contentTemplate',] }],
    listOfNzThComponent: [{ type: ContentChildren, args: [NzThComponent, { descendants: true },] }],
    nzSortChange: [{ type: Output }],
    nzSingleSort: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTrDirective {
    /**
     * @param {?} elementRef
     * @param {?} renderer
     * @param {?} nzTableComponent
     */
    constructor(elementRef, renderer, nzTableComponent) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.nzTableComponent = nzTableComponent;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzExpand(value) {
        if (toBoolean(value)) {
            this.renderer.removeStyle(this.elementRef.nativeElement, 'display');
            this.renderer.addClass(this.elementRef.nativeElement, 'ant-table-expanded-row');
        }
        else {
            this.renderer.setStyle(this.elementRef.nativeElement, 'display', 'none');
            this.renderer.removeClass(this.elementRef.nativeElement, 'ant-table-expanded-row');
        }
    }
}
NzTrDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'tr',
                host: {
                    '[class.ant-table-row]': 'nzTableComponent'
                }
            },] },
];
/** @nocollapse */
NzTrDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NzTableComponent, decorators: [{ type: Host }, { type: Optional }] }
];
NzTrDirective.propDecorators = {
    nzExpand: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTableModule {
}
NzTableModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzTableComponent, NzThComponent, NzTdComponent, NzTheadComponent, NzTbodyDirective, NzTrDirective],
                exports: [NzTableComponent, NzThComponent, NzTdComponent, NzTheadComponent, NzTbodyDirective, NzTrDirective],
                imports: [NzMenuModule, FormsModule, NzRadioModule, NzCheckboxModule, NzDropDownModule, CommonModule, NzPaginationModule, NzSpinModule, NzI18nModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTabBodyComponent {
}
NzTabBodyComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-tab-body]',
                preserveWhitespaces: false,
                template: `<ng-template [ngTemplateOutlet]="content"></ng-template>`
            },] },
];
NzTabBodyComponent.propDecorators = {
    content: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTabLabelDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this._disabled = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @return {?}
     */
    getOffsetLeft() {
        return this.elementRef.nativeElement.offsetLeft;
    }
    /**
     * @return {?}
     */
    getOffsetWidth() {
        return this.elementRef.nativeElement.offsetWidth;
    }
    /**
     * @return {?}
     */
    getOffsetTop() {
        return this.elementRef.nativeElement.offsetTop;
    }
    /**
     * @return {?}
     */
    getOffsetHeight() {
        return this.elementRef.nativeElement.offsetHeight;
    }
}
NzTabLabelDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-tab-label]',
                host: {
                    '[class.ant-tabs-tab]': 'true'
                }
            },] },
];
/** @nocollapse */
NzTabLabelDirective.ctorParameters = () => [
    { type: ElementRef }
];
NzTabLabelDirective.propDecorators = {
    disabled: [{ type: Input }, { type: HostBinding, args: ['class.ant-tabs-tab-disabled',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTabsInkBarDirective {
    /**
     * @param {?} renderer
     * @param {?} elementRef
     * @param {?} ngZone
     */
    constructor(renderer, elementRef, ngZone) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this._animated = false;
        this.nzPositionMode = 'horizontal';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAnimated(value) {
        this._animated = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzAnimated() {
        return this._animated;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    alignToElement(element) {
        this.show();
        this.ngZone.runOutsideAngular(() => {
            reqAnimFrame(() => {
                /** when horizontal remove height style and add transform left **/
                if (this.nzPositionMode === 'horizontal') {
                    this.renderer.removeStyle(this.elementRef.nativeElement, 'height');
                    this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translate3d(${this.getLeftPosition(element)}, 0px, 0px)`);
                    this.renderer.setStyle(this.elementRef.nativeElement, 'width', this.getElementWidth(element));
                }
                else {
                    /** when vertical remove width style and add transform top **/
                    this.renderer.removeStyle(this.elementRef.nativeElement, 'width');
                    this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translate3d(0px, ${this.getTopPosition(element)}, 0px)`);
                    this.renderer.setStyle(this.elementRef.nativeElement, 'height', this.getElementHeight(element));
                }
            });
        });
    }
    /**
     * @return {?}
     */
    show() {
        this.renderer.setStyle(this.elementRef.nativeElement, 'visibility', 'visible');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setDisplay(value) {
        this.renderer.setStyle(this.elementRef.nativeElement, 'display', value);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getLeftPosition(element) {
        return element ? element.offsetLeft + 'px' : '0';
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getElementWidth(element) {
        return element ? element.offsetWidth + 'px' : '0';
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getTopPosition(element) {
        return element ? element.offsetTop + 'px' : '0';
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getElementHeight(element) {
        return element ? element.offsetHeight + 'px' : '0';
    }
}
NzTabsInkBarDirective.decorators = [
    { type: Directive, args: [{
                selector: '[nz-tabs-ink-bar]',
                host: {
                    '[class.ant-tabs-ink-bar]': 'true',
                    '[class.ant-tabs-ink-bar-animated]': 'nzAnimated',
                    '[class.ant-tabs-ink-bar-no-animated]': '!nzAnimated'
                }
            },] },
];
/** @nocollapse */
NzTabsInkBarDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgZone }
];
NzTabsInkBarDirective.propDecorators = {
    nzAnimated: [{ type: Input }],
    nzPositionMode: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const EXAGGERATED_OVERSCROLL = 64;
class NzTabsNavComponent {
    /**
     * @param {?} elementRef
     * @param {?} ngZone
     * @param {?} renderer
     * @param {?} dir
     */
    constructor(elementRef, ngZone, renderer, dir) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.dir = dir;
        this._animated = true;
        this._hideBar = false;
        this._showPagination = true;
        this._type = 'line';
        this._tabPositionMode = 'horizontal';
        this._scrollDistance = 0;
        this._selectedIndex = 0;
        this.showPaginationControls = false;
        this.disableScrollAfter = true;
        this.disableScrollBefore = true;
        this.selectedIndexChanged = false;
        this.realignInkBar = null;
        this.nzOnNextClick = new EventEmitter();
        this.nzOnPrevClick = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAnimated(value) {
        this._animated = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzAnimated() {
        return this._animated;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzHideBar(value) {
        this._hideBar = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzHideBar() {
        return this._hideBar;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzType(value) {
        this._type = value;
        if (this._type !== 'line') {
            this.nzTabsInkBarDirective.setDisplay('none');
        }
        else {
            this.nzTabsInkBarDirective.setDisplay('block');
        }
    }
    /**
     * @return {?}
     */
    get nzType() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowPagination(value) {
        this._showPagination = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowPagination() {
        return this._showPagination;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPositionMode(value) {
        this._tabPositionMode = value;
        this.alignInkBarToSelectedTab();
        if (this.nzShowPagination) {
            this.updatePagination();
        }
    }
    /**
     * @return {?}
     */
    get nzPositionMode() {
        return this._tabPositionMode;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this.selectedIndexChanged = this._selectedIndex !== value;
        this._selectedIndex = value;
    }
    /**
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @return {?}
     */
    onContentChanges() {
        if (this.nzShowPagination) {
            this.updatePagination();
        }
        this.alignInkBarToSelectedTab();
    }
    /**
     * @param {?} scrollDir
     * @return {?}
     */
    scrollHeader(scrollDir) {
        if (scrollDir === 'before' && !this.disableScrollBefore) {
            this.nzOnPrevClick.emit();
        }
        else if (scrollDir === 'after' && !this.disableScrollAfter) {
            this.nzOnNextClick.emit();
        }
        // Move the scroll distance one-third the length of the tab list's viewport.
        this.scrollDistance += (scrollDir === 'before' ? -1 : 1) * this.viewWidthHeightPix / 3;
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        if (this.tabLabelCount !== this.listOfNzTabLabelDirective.length) {
            if (this.nzShowPagination) {
                this.updatePagination();
            }
            this.tabLabelCount = this.listOfNzTabLabelDirective.length;
        }
        if (this.selectedIndexChanged) {
            this.scrollToLabel(this._selectedIndex);
            if (this.nzShowPagination) {
                this.checkScrollingControls();
            }
            this.alignInkBarToSelectedTab();
            this.selectedIndexChanged = false;
        }
        if (this.scrollDistanceChanged) {
            if (this.nzShowPagination) {
                this.updateTabScrollPosition();
            }
            this.scrollDistanceChanged = false;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.realignInkBar = this.ngZone.runOutsideAngular(() => {
            const /** @type {?} */ dirChange = this.dir ? this.dir.change : of(null);
            const /** @type {?} */ resize = typeof window !== 'undefined' ?
                fromEvent(window, 'resize').pipe(auditTime(10)) :
                of(null);
            return merge(dirChange, resize).pipe(startWith(null)).subscribe(() => {
                if (this.nzShowPagination) {
                    this.updatePagination();
                }
                this.alignInkBarToSelectedTab();
            });
        });
    }
    /**
     * @return {?}
     */
    updateTabScrollPosition() {
        const /** @type {?} */ scrollDistance = this.scrollDistance;
        if (this.nzPositionMode === 'horizontal') {
            const /** @type {?} */ translateX = this.getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;
            this.renderer.setStyle(this.navListElement.nativeElement, 'transform', `translate3d(${translateX}px, 0, 0)`);
        }
        else {
            this.renderer.setStyle(this.navListElement.nativeElement, 'transform', `translate3d(0,${-scrollDistance}px, 0)`);
        }
    }
    /**
     * @return {?}
     */
    updatePagination() {
        this.checkPaginationEnabled();
        this.checkScrollingControls();
        this.updateTabScrollPosition();
    }
    /**
     * @return {?}
     */
    checkPaginationEnabled() {
        this.showPaginationControls =
            this.tabListScrollWidthHeightPix > this.elementRefOffSetWidthHeight;
        if (!this.showPaginationControls) {
            this.scrollDistance = 0;
        }
    }
    /**
     * @param {?} labelIndex
     * @return {?}
     */
    scrollToLabel(labelIndex) {
        const /** @type {?} */ selectedLabel = this.listOfNzTabLabelDirective
            ? this.listOfNzTabLabelDirective.toArray()[labelIndex]
            : null;
        if (selectedLabel) {
            // The view length is the visible width of the tab labels.
            let /** @type {?} */ labelBeforePos;
            let /** @type {?} */ labelAfterPos;
            if (this.nzPositionMode === 'horizontal') {
                if (this.getLayoutDirection() === 'ltr') {
                    labelBeforePos = selectedLabel.getOffsetLeft();
                    labelAfterPos = labelBeforePos + selectedLabel.getOffsetWidth();
                }
                else {
                    labelAfterPos = this.navListElement.nativeElement.offsetWidth - selectedLabel.getOffsetLeft();
                    labelBeforePos = labelAfterPos - selectedLabel.getOffsetWidth();
                }
            }
            else {
                labelBeforePos = selectedLabel.getOffsetTop();
                labelAfterPos = labelBeforePos + selectedLabel.getOffsetHeight();
            }
            const /** @type {?} */ beforeVisiblePos = this.scrollDistance;
            const /** @type {?} */ afterVisiblePos = this.scrollDistance + this.viewWidthHeightPix;
            if (labelBeforePos < beforeVisiblePos) {
                // Scroll header to move label to the before direction
                this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;
            }
            else if (labelAfterPos > afterVisiblePos) {
                // Scroll header to move label to the after direction
                this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;
            }
        }
    }
    /**
     * @return {?}
     */
    checkScrollingControls() {
        // Check if the pagination arrows should be activated.
        this.disableScrollBefore = this.scrollDistance === 0;
        this.disableScrollAfter = this.scrollDistance === this.getMaxScrollDistance();
    }
    /**
     * Determines what is the maximum length in pixels that can be set for the scroll distance. This
     * is equal to the difference in width between the tab list container and tab header container.
     *
     * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
     * should be called sparingly.
     * @return {?}
     */
    getMaxScrollDistance() {
        return (this.tabListScrollWidthHeightPix - this.viewWidthHeightPix) || 0;
    }
    /**
     * Sets the distance in pixels that the tab header should be transformed in the X-axis.
     * @param {?} v
     * @return {?}
     */
    set scrollDistance(v) {
        this._scrollDistance = Math.max(0, Math.min(this.getMaxScrollDistance(), v));
        // Mark that the scroll distance has changed so that after the view is checked, the CSS
        // transformation can move the header.
        this.scrollDistanceChanged = true;
        this.checkScrollingControls();
    }
    /**
     * @return {?}
     */
    get scrollDistance() {
        return this._scrollDistance;
    }
    /**
     * @return {?}
     */
    get viewWidthHeightPix() {
        let /** @type {?} */ PAGINATION_PIX = 0;
        if (this.showPaginationControls) {
            PAGINATION_PIX = 64;
        }
        if (this.nzPositionMode === 'horizontal') {
            return this.navContainerElement.nativeElement.offsetWidth - PAGINATION_PIX;
        }
        else {
            return this.navContainerElement.nativeElement.offsetHeight - PAGINATION_PIX;
        }
    }
    /**
     * @return {?}
     */
    get tabListScrollWidthHeightPix() {
        if (this.nzPositionMode === 'horizontal') {
            return this.navListElement.nativeElement.scrollWidth;
        }
        else {
            return this.navListElement.nativeElement.scrollHeight;
        }
    }
    /**
     * @return {?}
     */
    get elementRefOffSetWidthHeight() {
        if (this.nzPositionMode === 'horizontal') {
            return this.elementRef.nativeElement.offsetWidth;
        }
        else {
            return this.elementRef.nativeElement.offsetHeight;
        }
    }
    /**
     * @return {?}
     */
    getLayoutDirection() {
        return this.dir && this.dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * @return {?}
     */
    alignInkBarToSelectedTab() {
        if (this.nzType === 'line') {
            const /** @type {?} */ selectedLabelWrapper = this.listOfNzTabLabelDirective && this.listOfNzTabLabelDirective.length
                ? this.listOfNzTabLabelDirective.toArray()[this.selectedIndex].elementRef.nativeElement
                : null;
            if (this.nzTabsInkBarDirective) {
                this.nzTabsInkBarDirective.alignToElement(selectedLabelWrapper);
            }
        }
    }
}
NzTabsNavComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-tabs-nav]',
                preserveWhitespaces: false,
                template: `<div style="float:right;" *ngIf="nzTabBarExtraContent" class="ant-tabs-extra-content"> <ng-template [ngTemplateOutlet]="nzTabBarExtraContent"></ng-template> </div> <div class="ant-tabs-nav-container" [class.ant-tabs-nav-container-scrolling]="showPaginationControls" #navContainerElement> <span class="ant-tabs-tab-prev" (click)="scrollHeader('before')" [class.ant-tabs-tab-btn-disabled]="disableScrollBefore" [class.ant-tabs-tab-arrow-show]="showPaginationControls"> <span class="ant-tabs-tab-prev-icon"></span> </span> <span class="ant-tabs-tab-next" (click)="scrollHeader('after')" [class.ant-tabs-tab-btn-disabled]="disableScrollAfter" [class.ant-tabs-tab-arrow-show]="showPaginationControls"> <span class="ant-tabs-tab-next-icon"></span> </span> <div class="ant-tabs-nav-wrap"> <div class="ant-tabs-nav-scroll"> <div class="ant-tabs-nav" [class.ant-tabs-nav-animated]="nzAnimated" #navListElement (cdkObserveContent)="onContentChanges()"> <div nz-tabs-ink-bar [hidden]="nzHideBar" [nzAnimated]="nzAnimated" [nzPositionMode]="nzPositionMode" style="display: block;"></div> <ng-content></ng-content> </div> </div> </div> </div>`,
                host: {
                    '[class.ant-tabs-bar]': 'true'
                }
            },] },
];
/** @nocollapse */
NzTabsNavComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 },
    { type: Directionality, decorators: [{ type: Optional }] }
];
NzTabsNavComponent.propDecorators = {
    listOfNzTabLabelDirective: [{ type: ContentChildren, args: [NzTabLabelDirective,] }],
    nzTabsInkBarDirective: [{ type: ViewChild, args: [NzTabsInkBarDirective,] }],
    navContainerElement: [{ type: ViewChild, args: ['navContainerElement',] }],
    navListElement: [{ type: ViewChild, args: ['navListElement',] }],
    nzOnNextClick: [{ type: Output }],
    nzOnPrevClick: [{ type: Output }],
    nzTabBarExtraContent: [{ type: Input }],
    nzAnimated: [{ type: Input }],
    nzHideBar: [{ type: Input }],
    nzType: [{ type: Input }],
    nzShowPagination: [{ type: Input }],
    nzPositionMode: [{ type: Input }],
    selectedIndex: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** get some code from https://github.com/angular/material2 */
/**
 * @record
 */

class NzTabChangeEvent {
}
class NzTabSetComponent {
    /**
     * @param {?} renderer
     * @param {?} nzUpdateHostClassService
     * @param {?} elementRef
     */
    constructor(renderer, nzUpdateHostClassService, elementRef) {
        this.renderer = renderer;
        this.nzUpdateHostClassService = nzUpdateHostClassService;
        this.elementRef = elementRef;
        this._tabPosition = 'top';
        this._indexToSelect = 0;
        this._selectedIndex = null;
        this._type = 'line';
        this._size = 'default';
        this._animated = true;
        this.prefixCls = 'ant-tabs';
        this.tabPositionMode = 'horizontal';
        this.inkBarAnimated = true;
        this.tabPaneAnimated = true;
        this.isViewInit = false;
        this.listOfNzTabComponent = [];
        this.nzShowPagination = true;
        this.nzHideAll = false;
        this.nzOnNextClick = new EventEmitter();
        this.nzOnPrevClick = new EventEmitter();
        this.nzSelectChange = new EventEmitter(true);
        this.el = this.elementRef.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzAnimated(value) {
        this._animated = value;
        this.setClassMap();
        this.inkBarAnimated = (this.nzAnimated === true) || ((/** @type {?} */ (this.nzAnimated)).inkBar === true);
        this.tabPaneAnimated = (this.nzAnimated === true) || ((/** @type {?} */ (this.nzAnimated)).tabPane === true);
    }
    /**
     * @return {?}
     */
    get nzAnimated() {
        return this._animated;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSelectedIndex(value) {
        this._indexToSelect = toNumber(value, null);
    }
    /**
     * @return {?}
     */
    get nzSelectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @return {?}
     */
    get nzSelectedIndexChange() {
        return this.nzSelectChange.pipe(map(event => event.index));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this._size = value;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTabPosition(value) {
        if (this._tabPosition === value) {
            return;
        }
        this._tabPosition = value;
        if ((this._tabPosition === 'top') || (this._tabPosition === 'bottom')) {
            this.tabPositionMode = 'horizontal';
        }
        else {
            this.tabPositionMode = 'vertical';
        }
        this.setPosition(value);
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzTabPosition() {
        return this._tabPosition;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzType(value) {
        if (this._type === value) {
            return;
        }
        this._type = value;
        if (this._type === 'card') {
            this.nzAnimated = false;
        }
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzType() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setPosition(value) {
        if (this.isViewInit) {
            if (value === 'bottom') {
                this.renderer.insertBefore(this.el, this.tabContent.nativeElement, this.nzTabsNavComponent.elementRef.nativeElement);
            }
            else {
                this.renderer.insertBefore(this.el, this.nzTabsNavComponent.elementRef.nativeElement, this.tabContent.nativeElement);
            }
        }
    }
    /**
     * @return {?}
     */
    setClassMap() {
        const /** @type {?} */ classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-vertical`]: (this.nzTabPosition === 'left') || (this.nzTabPosition === 'right'),
            [`${this.prefixCls}-${this.nzTabPosition}`]: this.nzTabPosition,
            [`${this.prefixCls}-no-animation`]: (this.nzAnimated === false) || ((/** @type {?} */ (this.nzAnimated)).tabPane === false),
            [`${this.prefixCls}-${this.nzType}`]: this.nzType,
            [`${this.prefixCls}-large`]: this.nzSize === 'large',
            [`${this.prefixCls}-small`]: this.nzSize === 'small'
        };
        this.nzUpdateHostClassService.updateHostClass(this.el, classMap);
    }
    /**
     * @param {?} index
     * @param {?} disabled
     * @return {?}
     */
    clickLabel(index, disabled) {
        if (!disabled) {
            this.nzSelectedIndex = index;
            this.listOfNzTabComponent[index].nzClick.emit();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        // Clamp the next selected index to the bounds of 0 and the tabs length. Note the `|| 0`, which
        // ensures that values like NaN can't get through and which would otherwise throw the
        // component into an infinite loop (since Math.max(NaN, 0) === NaN).
        const /** @type {?} */ indexToSelect = this._indexToSelect =
            Math.min(this.listOfNzTabComponent.length - 1, Math.max(this._indexToSelect || 0, 0));
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect && isNotNil(this._selectedIndex)) {
            this.nzSelectChange.emit(this.createChangeEvent(indexToSelect));
        }
        // Setup the position for each tab and optionally setup an origin on the next selected tab.
        this.listOfNzTabComponent.forEach((tab, index) => {
            tab.position = index - indexToSelect;
            // If there is already a selected tab, then set up an origin for the next selected tab
            // if it doesn't have one already.
            if (isNotNil(this._selectedIndex) && tab.position === 0 && !tab.origin) {
                tab.origin = indexToSelect - this._selectedIndex;
            }
        });
        this._selectedIndex = indexToSelect;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    createChangeEvent(index) {
        const /** @type {?} */ event = new NzTabChangeEvent();
        event.index = index;
        if (this.listOfNzTabComponent && this.listOfNzTabComponent.length) {
            event.tab = this.listOfNzTabComponent[index];
            this.listOfNzTabComponent.forEach((item, i) => {
                if (i !== index) {
                    item.nzDeselect.emit();
                }
            });
            event.tab.nzSelect.emit();
        }
        return event;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    addTab(value) {
        this.listOfNzTabComponent.push(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    removeTab(value) {
        this.listOfNzTabComponent.splice(this.listOfNzTabComponent.indexOf(value), 1);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.isViewInit = true;
        this.setPosition(this.nzTabPosition);
    }
}
NzTabSetComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-tabset',
                preserveWhitespaces: false,
                providers: [NzUpdateHostClassService],
                template: `<div nz-tabs-nav role="tablist" tabindex="0" [nzType]="nzType" [nzShowPagination]="nzShowPagination" [nzPositionMode]="tabPositionMode" [nzAnimated]="inkBarAnimated" [ngStyle]="nzTabBarStyle" [nzHideBar]="nzHideAll" [nzTabBarExtraContent]="nzTabBarExtraContent" [selectedIndex]="nzSelectedIndex" (nzOnNextClick)="nzOnNextClick.emit()" (nzOnPrevClick)="nzOnPrevClick.emit()"> <div nz-tab-label role="tab" [style.margin-right.px]="nzTabBarGutter" [class.ant-tabs-tab-active]="(nzSelectedIndex == i) && !nzHideAll" [disabled]="tab.nzDisabled" (click)="clickLabel(i,tab.nzDisabled)" *ngFor="let tab of listOfNzTabComponent; let i = index"> <ng-container *ngIf="tab.isTitleString; else titleTemplate">{{ tab.nzTitle }}</ng-container> <ng-template #titleTemplate> <ng-template [ngTemplateOutlet]="tab.nzTitle"></ng-template> </ng-template> </div> </div> <div class="ant-tabs-content" #tabContent [class.ant-tabs-content-animated]="tabPaneAnimated" [class.ant-tabs-content-no-animated]="!tabPaneAnimated" [style.margin-left.%]="tabPaneAnimated&&(-nzSelectedIndex*100)"> <div nz-tab-body class="ant-tabs-tabpane" [class.ant-tabs-tabpane-active]="(nzSelectedIndex == i) && !nzHideAll" [class.ant-tabs-tabpane-inactive]="(nzSelectedIndex != i) || nzHideAll" [content]="tab.content" *ngFor="let tab of listOfNzTabComponent; let i = index"> </div> </div>`,
                styles: [`
    :host {
      display: block;
    }
  `]
            },] },
];
/** @nocollapse */
NzTabSetComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: NzUpdateHostClassService },
    { type: ElementRef }
];
NzTabSetComponent.propDecorators = {
    nzTabBarExtraContent: [{ type: Input }],
    nzTabsNavComponent: [{ type: ViewChild, args: [NzTabsNavComponent,] }],
    tabContent: [{ type: ViewChild, args: ['tabContent',] }],
    nzShowPagination: [{ type: Input }],
    nzHideAll: [{ type: Input }],
    nzTabBarGutter: [{ type: Input }],
    nzTabBarStyle: [{ type: Input }],
    nzOnNextClick: [{ type: Output }],
    nzOnPrevClick: [{ type: Output }],
    nzAnimated: [{ type: Input }],
    nzSelectedIndex: [{ type: Input }],
    nzSelectedIndexChange: [{ type: Output }],
    nzSelectChange: [{ type: Output }],
    nzSize: [{ type: Input }],
    nzTabPosition: [{ type: Input }],
    nzType: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTabComponent {
    /**
     * @param {?} nzTabSetComponent
     */
    constructor(nzTabSetComponent) {
        this.nzTabSetComponent = nzTabSetComponent;
        this._disabled = false;
        this.position = null;
        this.origin = null;
        this.nzClick = new EventEmitter();
        this.nzSelect = new EventEmitter();
        this.nzDeselect = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzTitle(value) {
        this.isTitleString = !(value instanceof TemplateRef);
        this._title = value;
    }
    /**
     * @return {?}
     */
    get nzTitle() {
        return this._title;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.nzTabSetComponent.addTab(this);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.nzTabSetComponent.removeTab(this);
    }
}
NzTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-tab',
                preserveWhitespaces: false,
                template: `<ng-template> <ng-content></ng-content> </ng-template>`,
                host: {
                    '[class.ant-tabs-tabpane]': 'true'
                }
            },] },
];
/** @nocollapse */
NzTabComponent.ctorParameters = () => [
    { type: NzTabSetComponent }
];
NzTabComponent.propDecorators = {
    nzDisabled: [{ type: Input }],
    nzClick: [{ type: Output }],
    nzSelect: [{ type: Output }],
    nzDeselect: [{ type: Output }],
    content: [{ type: ViewChild, args: [TemplateRef,] }],
    nzTitle: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTabsModule {
}
NzTabsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzTabComponent, NzTabSetComponent, NzTabsNavComponent, NzTabLabelDirective, NzTabsInkBarDirective, NzTabBodyComponent],
                exports: [NzTabComponent, NzTabSetComponent, NzTabsNavComponent, NzTabLabelDirective, NzTabsInkBarDirective, NzTabBodyComponent],
                imports: [CommonModule, ObserversModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTagComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this._checked = false;
        this._mode = 'default';
        this.closed = false;
        this.nzAfterClose = new EventEmitter();
        this.nzOnClose = new EventEmitter();
        this.nzCheckedChange = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzMode(value) {
        this._mode = value;
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    get nzMode() {
        return this._mode;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzColor(value) {
        this._color = value;
        this.isPreset = this.isPresetColor(value);
        this.updateClassMap();
        this.updateColorStatus();
    }
    /**
     * @return {?}
     */
    get nzColor() {
        return this._color;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzChecked(value) {
        this._checked = toBoolean(value);
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    get nzChecked() {
        return this._checked;
    }
    /**
     * @param {?=} color
     * @return {?}
     */
    isPresetColor(color) {
        if (!color) {
            return false;
        }
        return (/^(pink|red|yellow|orange|cyan|green|blue|purple|geekblue|magenta|volcano|gold|lime)(-inverse)?$/
            .test(color));
    }
    /**
     * @return {?}
     */
    updateCheckedStatus() {
        if (this.nzMode === 'checkable') {
            this.nzChecked = !this.nzChecked;
            this.nzCheckedChange.emit(this.nzChecked);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    closeTag(e) {
        this.nzOnClose.emit(e);
        if (!e.defaultPrevented) {
            this.closed = true;
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    afterAnimation(e) {
        if (this.closed && !e.fromState) {
            this.nzAfterClose.emit();
        }
    }
    /**
     * @return {?}
     */
    updateClassMap() {
        const /** @type {?} */ isPresetColor = this.isPresetColor(this.nzColor);
        this.classMap = {
            [`ant-tag`]: true,
            [`ant-tag-has-color`]: this.nzColor && !isPresetColor,
            [`ant-tag-${this.nzColor}`]: isPresetColor,
            [`ant-tag-checkable`]: this.nzMode === 'checkable',
            [`ant-tag-checkable-checked`]: this.nzChecked
        };
    }
    /**
     * @return {?}
     */
    updateColorStatus() {
        if (this.wrapperElement && this.nzColor) {
            if (this.isPreset) {
                this.renderer.removeStyle(this.wrapperElement.nativeElement, 'background-color');
            }
            else {
                this.renderer.setStyle(this.wrapperElement.nativeElement, 'background-color', this.nzColor);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.updateColorStatus();
    }
}
NzTagComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-tag',
                preserveWhitespaces: false,
                animations: [trigger('tagAnimation', [
                        state('*', style({ opacity: 1 })),
                        transition('void => *', [
                            style({ opacity: 0 }),
                            animate('300ms cubic-bezier(0.78, 0.14, 0.15, 0.86)')
                        ]),
                        state('void', style({ opacity: 0 })),
                        transition('* => void', [
                            style({ opacity: 1 }),
                            animate('300ms cubic-bezier(0.78, 0.14, 0.15, 0.86)')
                        ])
                    ])],
                template: `<div *ngIf="!closed" [ngClass]="classMap" #wrapperElement [@tagAnimation] (@tagAnimation.done)="afterAnimation($event)" (click)="updateCheckedStatus()"> <ng-content></ng-content> <i class="anticon anticon-cross" *ngIf="nzMode==='closeable'" (click)="closeTag($event)"></i> </div>`
            },] },
];
/** @nocollapse */
NzTagComponent.ctorParameters = () => [
    { type: Renderer2 }
];
NzTagComponent.propDecorators = {
    wrapperElement: [{ type: ViewChild, args: ['wrapperElement',] }],
    nzAfterClose: [{ type: Output }],
    nzOnClose: [{ type: Output }],
    nzCheckedChange: [{ type: Output }],
    nzMode: [{ type: Input }],
    nzColor: [{ type: Input }],
    nzChecked: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTagModule {
}
NzTagModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                declarations: [
                    NzTagComponent
                ],
                exports: [
                    NzTagComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTimelineItemComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this._color = 'blue';
        this._isLast = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isLast(value) {
        this._isLast = value;
        if (this.isLast) {
            this.renderer.addClass(this.liTemplate.nativeElement, 'ant-timeline-item-last');
        }
        else {
            this.renderer.removeClass(this.liTemplate.nativeElement, 'ant-timeline-item-last');
        }
    }
    /**
     * @return {?}
     */
    get isLast() {
        return this._isLast;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDot(value) {
        this.isDotString = !(value instanceof TemplateRef);
        this._dot = value;
    }
    /**
     * @return {?}
     */
    get nzDot() {
        return this._dot;
    }
    /**
     * @param {?} color
     * @return {?}
     */
    set nzColor(color) {
        this._color = color;
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    get nzColor() {
        return this._color;
    }
    /**
     * @return {?}
     */
    updateClassMap() {
        this.classMap = {
            ['ant-timeline-item-head-green']: this.nzColor === 'green',
            ['ant-timeline-item-head-red']: this.nzColor === 'red',
            ['ant-timeline-item-head-blue']: this.nzColor === 'blue'
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateClassMap();
    }
}
NzTimelineItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-timeline-item',
                preserveWhitespaces: false,
                template: `<li class="ant-timeline-item" #liTemplate> <div class="ant-timeline-item-tail"></div> <div class="ant-timeline-item-head" [class.ant-timeline-item-head-custom]="nzDot" [ngClass]="classMap"> <ng-container *ngIf="isDotString; else dotTemplate">{{ nzDot }}</ng-container> <ng-template #dotTemplate> <ng-template [ngTemplateOutlet]="nzDot"></ng-template> </ng-template> </div> <div class="ant-timeline-item-content"> <ng-content></ng-content> </div> </li>`
            },] },
];
/** @nocollapse */
NzTimelineItemComponent.ctorParameters = () => [
    { type: Renderer2 }
];
NzTimelineItemComponent.propDecorators = {
    liTemplate: [{ type: ViewChild, args: ['liTemplate',] }],
    nzDot: [{ type: Input }],
    nzColor: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTimelineComponent {
    constructor() {
        this.unsubscribe$ = new Subject();
        this.isPendingBoolean = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzPending(value) {
        this.isPendingString = !(value instanceof TemplateRef);
        this.isPendingBoolean = value === true;
        this._pending = value;
    }
    /**
     * @return {?}
     */
    get nzPending() {
        return this._pending;
    }
    /**
     * @return {?}
     */
    updateChildrenTimeLine() {
        if (this.listOfTimeLine && this.listOfTimeLine.length) {
            this.listOfTimeLine.toArray().forEach((item, index) => item.isLast = index === this.listOfTimeLine.length - 1);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.updateChildrenTimeLine();
        if (this.listOfTimeLine) {
            this.listOfTimeLine.changes.pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
                this.updateChildrenTimeLine();
            });
        }
    }
}
NzTimelineComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-timeline',
                preserveWhitespaces: false,
                template: `<ul class="ant-timeline" [class.ant-timeline-pending]="nzPending"> <ng-content></ng-content> <li *ngIf="nzPending" class="ant-timeline-item ant-timeline-item-pending"> <div class="ant-timeline-item-tail"></div> <div class="ant-timeline-item-head ant-timeline-item-head-custom ant-timeline-item-head-blue"> <i class="anticon anticon-spin anticon-loading"></i> </div> <div class="ant-timeline-item-content"> <ng-container *ngIf="isPendingString; else pendingTemplate">{{ isPendingBoolean ? '' : nzPending }}</ng-container> <ng-template #pendingTemplate> <ng-template [ngTemplateOutlet]="nzPending"></ng-template> </ng-template> </div> </li> </ul>`
            },] },
];
NzTimelineComponent.propDecorators = {
    nzPending: [{ type: Input }],
    listOfTimeLine: [{ type: ContentChildren, args: [NzTimelineItemComponent,] }],
    _pendingContent: [{ type: ContentChild, args: ['pending',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTimelineModule {
}
NzTimelineModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NzTimelineItemComponent, NzTimelineComponent],
                exports: [NzTimelineItemComponent, NzTimelineComponent],
                imports: [CommonModule]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTransferListComponent {
    /**
     * @param {?} el
     * @param {?} updateHostClassService
     * @param {?} differs
     */
    constructor(el, updateHostClassService, differs) {
        this.el = el;
        this.updateHostClassService = updateHostClassService;
        this._showSearch = false;
        // region: fields
        this.direction = '';
        this.titleText = '';
        this.dataSource = [];
        this.itemUnit = '';
        this.itemsUnit = '';
        this.filter = '';
        // events
        this.handleSelectAll = new EventEmitter();
        this.handleSelect = new EventEmitter();
        this.filterChange = new EventEmitter();
        // endregion
        // region: styles
        this.prefixCls = 'ant-transfer-list';
        // endregion
        // region: select all
        this.stat = {
            checkAll: false,
            checkHalf: false,
            checkCount: 0,
            shownCount: 0
        };
        this.listDiffer = differs.find([]).create(null);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set showSearch(value) {
        this._showSearch = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get showSearch() {
        return this._showSearch;
    }
    /**
     * @return {?}
     */
    setClassMap() {
        const /** @type {?} */ classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-with-footer`]: !!this.footer
        };
        this.updateHostClassService.updateHostClass(this.el.nativeElement, classMap);
    }
    /**
     * @param {?} status
     * @return {?}
     */
    onHandleSelectAll(status) {
        this.dataSource.forEach(item => {
            if (!item.disabled && !item._hiden) {
                item.checked = status;
            }
        });
        this.updateCheckStatus();
        this.handleSelectAll.emit(status);
    }
    /**
     * @return {?}
     */
    updateCheckStatus() {
        const /** @type {?} */ validCount = this.dataSource.filter(w => !w.disabled).length;
        this.stat.checkCount = this.dataSource.filter(w => w.checked && !w.disabled).length;
        this.stat.shownCount = this.dataSource.filter(w => !w._hiden).length;
        this.stat.checkAll = validCount > 0 && validCount === this.stat.checkCount;
        this.stat.checkHalf = this.stat.checkCount > 0 && !this.stat.checkAll;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    handleFilter(value) {
        this.filter = value;
        this.dataSource.forEach(item => {
            item._hiden = value.length > 0 && !this.matchFilter(value, item);
        });
        this.stat.shownCount = this.dataSource.filter(w => !w._hiden).length;
        this.filterChange.emit({ direction: this.direction, value });
    }
    /**
     * @return {?}
     */
    handleClear() {
        this.handleFilter('');
    }
    /**
     * @param {?} text
     * @param {?} item
     * @return {?}
     */
    matchFilter(text, item) {
        if (this.filterOption) {
            return this.filterOption(text, item);
        }
        return item.title.includes(text);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('footer' in changes) {
            this.setClassMap();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        const /** @type {?} */ change = this.listDiffer.diff(this.dataSource);
        if (change) {
            this.updateCheckStatus();
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    _handleSelect(item) {
        if (item.disabled) {
            return;
        }
        item.checked = !item.checked;
        this.updateCheckStatus();
        this.handleSelect.emit(item);
    }
}
NzTransferListComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-transfer-list',
                preserveWhitespaces: false,
                providers: [NzUpdateHostClassService],
                template: `<div class="ant-transfer-list-header"> <label nz-checkbox [ngModel]="stat.checkAll" (ngModelChange)="onHandleSelectAll($event)" [nzIndeterminate]="stat.checkHalf"> </label> <span class="ant-transfer-list-header-selected"> <span>{{ (stat.checkCount > 0 ? stat.checkCount + '/' : '') + stat.shownCount }} {{ dataSource.length > 1 ? itemsUnit : itemUnit }}</span> <span *ngIf="titleText" class="ant-transfer-list-header-title">{{ titleText }}</span> </span> </div> <div class="{{showSearch ? 'ant-transfer-list-body ant-transfer-list-body-with-search' : 'ant-transfer-list-body'}}" [ngClass]="{'ant-transfer__nodata': stat.shownCount === 0}"> <div *ngIf="showSearch" class="ant-transfer-list-body-search-wrapper"> <div nz-transfer-search (valueChanged)="handleFilter($event)" (valueClear)="handleClear()" [placeholder]="searchPlaceholder" [value]="filter"></div> </div> <ul class="ant-transfer-list-content"> <ng-container *ngFor="let item of dataSource"> <li *ngIf="!item._hiden" (click)="_handleSelect(item)" class="ant-transfer-list-content-item"> <label nz-checkbox [ngModel]="item.checked" [nzDisabled]="item.disabled"> <ng-container *ngIf="!render; else renderContainer">{{ item.title }}</ng-container> <ng-template #renderContainer [ngTemplateOutlet]="render" [ngTemplateOutletContext]="{ $implicit: item }"></ng-template> </label> </li> </ng-container> </ul> <div class="ant-transfer-list-body-not-found">{{ notFoundContent }}</div> </div> <div *ngIf="footer" class="ant-transfer-list-footer"> <ng-template [ngTemplateOutlet]="footer" [ngTemplateOutletContext]="{ $implicit: direction }"></ng-template> </div>`
            },] },
];
/** @nocollapse */
NzTransferListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NzUpdateHostClassService },
    { type: IterableDiffers }
];
NzTransferListComponent.propDecorators = {
    direction: [{ type: Input }],
    titleText: [{ type: Input }],
    dataSource: [{ type: Input }],
    itemUnit: [{ type: Input }],
    itemsUnit: [{ type: Input }],
    filter: [{ type: Input }],
    showSearch: [{ type: Input }],
    searchPlaceholder: [{ type: Input }],
    notFoundContent: [{ type: Input }],
    filterOption: [{ type: Input }],
    render: [{ type: Input }],
    footer: [{ type: Input }],
    handleSelectAll: [{ type: Output }],
    handleSelect: [{ type: Output }],
    filterChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTransferSearchComponent {
    constructor() {
        this.valueChanged = new EventEmitter();
        this.valueClear = new EventEmitter();
    }
    /**
     * @return {?}
     */
    _handle() {
        this.valueChanged.emit(this.value);
    }
    /**
     * @return {?}
     */
    _clear() {
        this.value = '';
        this.valueClear.emit();
    }
}
NzTransferSearchComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-transfer-search]',
                preserveWhitespaces: false,
                template: `<input nz-input [(ngModel)]="value" (ngModelChange)="_handle()" [placeholder]="placeholder" class="ant-transfer-list-search"> <a *ngIf="value && value.length > 0; else def" class="ant-transfer-list-search-action" (click)="_clear()"> <i class="anticon anticon-cross-circle"></i> </a> <ng-template #def> <span class="ant-transfer-list-search-action"><i class="anticon anticon-search"></i></span> </ng-template>`
            },] },
];
NzTransferSearchComponent.propDecorators = {
    placeholder: [{ type: Input }],
    value: [{ type: Input }],
    valueChanged: [{ type: Output }],
    valueClear: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTransferComponent {
    /**
     * @param {?} i18n
     * @param {?} el
     */
    constructor(i18n, el) {
        this.i18n = i18n;
        this.el = el;
        this.unsubscribe$ = new Subject();
        // tslint:disable-next-line:no-any
        this.locale = {};
        this._showSearch = false;
        this.leftFilter = '';
        this.rightFilter = '';
        // region: fields
        this.nzDataSource = [];
        this.nzTitles = ['', ''];
        this.nzOperations = [];
        this.nzCanMove = (arg) => of(arg.list);
        // events
        this.nzChange = new EventEmitter();
        this.nzSearchChange = new EventEmitter();
        this.nzSelectChange = new EventEmitter();
        // endregion
        // region: process data
        // left
        this.leftDataSource = [];
        // right
        this.rightDataSource = [];
        this.handleLeftSelectAll = (checked) => this.handleSelect('left', checked);
        this.handleRightSelectAll = (checked) => this.handleSelect('right', checked);
        this.handleLeftSelect = (item) => this.handleSelect('left', item.checked, item);
        this.handleRightSelect = (item) => this.handleSelect('right', item.checked, item);
        // endregion
        // region: operation
        this.leftActive = false;
        this.rightActive = false;
        this.moveToLeft = () => this.moveTo('left');
        this.moveToRight = () => this.moveTo('right');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowSearch(value) {
        this._showSearch = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowSearch() {
        return this._showSearch;
    }
    /**
     * @return {?}
     */
    splitDataSource() {
        this.leftDataSource = [];
        this.rightDataSource = [];
        this.nzDataSource.forEach(record => {
            if (record.direction === 'right') {
                this.rightDataSource.push(record);
            }
            else {
                this.leftDataSource.push(record);
            }
        });
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    getCheckedData(direction) {
        return this[direction === 'left' ? 'leftDataSource' : 'rightDataSource'].filter(w => w.checked);
    }
    /**
     * @param {?} direction
     * @param {?} checked
     * @param {?=} item
     * @return {?}
     */
    handleSelect(direction, checked, item) {
        const /** @type {?} */ list = this.getCheckedData(direction);
        this.updateOperationStatus(direction, list.length);
        this.nzSelectChange.emit({ direction, checked, list, item });
    }
    /**
     * @param {?} ret
     * @return {?}
     */
    handleFilterChange(ret) {
        this.nzSearchChange.emit(ret);
    }
    /**
     * @param {?} direction
     * @param {?=} count
     * @return {?}
     */
    updateOperationStatus(direction, count) {
        this[direction === 'right' ? 'leftActive' : 'rightActive'] = (typeof count === 'undefined' ? this.getCheckedData(direction).filter(w => !w.disabled).length : count) > 0;
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    moveTo(direction) {
        const /** @type {?} */ oppositeDirection = direction === 'left' ? 'right' : 'left';
        this.updateOperationStatus(oppositeDirection, 0);
        const /** @type {?} */ datasource = direction === 'left' ? this.rightDataSource : this.leftDataSource;
        const /** @type {?} */ moveList = datasource.filter(item => item.checked === true && !item.disabled);
        this.nzCanMove({ direction, list: moveList })
            .subscribe(newMoveList => this.truthMoveTo(direction, newMoveList.filter(i => !!i)), () => moveList.forEach(i => i.checked = false));
    }
    /**
     * @param {?} direction
     * @param {?} list
     * @return {?}
     */
    truthMoveTo(direction, list) {
        const /** @type {?} */ oppositeDirection = direction === 'left' ? 'right' : 'left';
        const /** @type {?} */ datasource = direction === 'left' ? this.rightDataSource : this.leftDataSource;
        const /** @type {?} */ targetDatasource = direction === 'left' ? this.leftDataSource : this.rightDataSource;
        for (const /** @type {?} */ item of list) {
            item.checked = false;
            targetDatasource.push(item);
            datasource.splice(datasource.indexOf(item), 1);
        }
        this.updateOperationStatus(oppositeDirection);
        this.nzChange.emit({
            from: oppositeDirection,
            to: direction,
            list
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.i18n.localeChange.pipe(takeUntil(this.unsubscribe$)).subscribe(() => this.locale = this.i18n.getLocaleData('Transfer'));
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('nzDataSource' in changes) {
            this.splitDataSource();
            this.updateOperationStatus('left');
            this.updateOperationStatus('right');
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
}
NzTransferComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-transfer',
                preserveWhitespaces: false,
                template: `<nz-transfer-list class="ant-transfer-list" [ngStyle]="nzListStyle" data-direction="left" [titleText]="nzTitles[0]" [dataSource]="leftDataSource" [filter]="leftFilter" [filterOption]="nzFilterOption" (filterChange)="handleFilterChange($event)" [render]="nzRender" [showSearch]="nzShowSearch" [searchPlaceholder]="nzSearchPlaceholder || locale.searchPlaceholder" [notFoundContent]="nzNotFoundContent || locale.notFoundContent" [itemUnit]="nzItemUnit || locale.itemUnit" [itemsUnit]="nzItemsUnit || locale.itemsUnit" [footer]="nzFooter" (handleSelect)="handleLeftSelect($event)" (handleSelectAll)="handleLeftSelectAll($event)"></nz-transfer-list> <div class="ant-transfer-operation"> <button nz-button (click)="moveToLeft()" [disabled]="!leftActive" [nzType]="'primary'" [nzSize]="'small'"> <i class="anticon anticon-left"></i><span *ngIf="nzOperations[1]">{{ nzOperations[1] }}</span> </button> <button nz-button (click)="moveToRight()" [disabled]="!rightActive" [nzType]="'primary'" [nzSize]="'small'"> <i class="anticon anticon-right"></i><span *ngIf="nzOperations[0]">{{ nzOperations[0] }}</span> </button> </div> <nz-transfer-list class="ant-transfer-list" [ngStyle]="nzListStyle" data-direction="right" [titleText]="nzTitles[1]" [dataSource]="rightDataSource" [filter]="rightFilter" [filterOption]="nzFilterOption" (filterChange)="handleFilterChange($event)" [render]="nzRender" [showSearch]="nzShowSearch" [searchPlaceholder]="nzSearchPlaceholder || locale.searchPlaceholder" [notFoundContent]="nzNotFoundContent || locale.notFoundContent" [itemUnit]="nzItemUnit || locale.itemUnit" [itemsUnit]="nzItemsUnit || locale.itemsUnit" [footer]="nzFooter" (handleSelect)="handleRightSelect($event)" (handleSelectAll)="handleRightSelectAll($event)"></nz-transfer-list>`,
                host: {
                    '[class.ant-transfer]': 'true'
                }
            },] },
];
/** @nocollapse */
NzTransferComponent.ctorParameters = () => [
    { type: NzI18nService },
    { type: ElementRef }
];
NzTransferComponent.propDecorators = {
    nzDataSource: [{ type: Input }],
    nzTitles: [{ type: Input }],
    nzOperations: [{ type: Input }],
    nzListStyle: [{ type: Input }],
    nzItemUnit: [{ type: Input }],
    nzItemsUnit: [{ type: Input }],
    nzCanMove: [{ type: Input }],
    nzRender: [{ type: Input }],
    nzFooter: [{ type: Input }],
    nzShowSearch: [{ type: Input }],
    nzFilterOption: [{ type: Input }],
    nzSearchPlaceholder: [{ type: Input }],
    nzNotFoundContent: [{ type: Input }],
    nzChange: [{ type: Output }],
    nzSearchChange: [{ type: Output }],
    nzSelectChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTransferModule {
}
NzTransferModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, NzCheckboxModule, NzButtonModule, NzInputModule, NzI18nModule],
                declarations: [NzTransferComponent, NzTransferListComponent, NzTransferSearchComponent],
                exports: [NzTransferComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class NzTreeNode {
    /**
     * @param {?} option
     * @param {?=} parent
     */
    constructor(option, parent = null) {
        this.level = 0;
        this.title = option.title || '---';
        this.key = option.key || null;
        this.isLeaf = option.isLeaf || false;
        this.origin = option;
        this.children = [];
        this.parentNode = parent;
        // option params
        this.isChecked = option.checked || false;
        this.isSelectable = option.disabled || (option.selectable === false ? false : true);
        this.isDisabled = option.disabled || false;
        this.isDisableCheckbox = option.disableCheckbox || false;
        this.isExpanded = option.expanded || false;
        this.isAllChecked = option.checked || false;
        this.isHalfChecked = false;
        this.isSelected = option.selected || false;
        this.isLoading = false;
        this.isMatched = false;
        /**
             * 初始化时父节点checked状态影响全部子节点
             */
        if (parent) {
            this.level = parent.level + 1;
        }
        else {
            this.level = 0;
        }
        if (typeof (option.children) !== 'undefined' && option.children !== null) {
            option.children.forEach((nodeOptions) => {
                if (option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {
                    nodeOptions.checked = option.checked;
                }
                this.children.push(new NzTreeNode(nodeOptions, this));
            });
        }
    }
    /**
     * @return {?}
     */
    getParentNode() {
        return this.parentNode;
    }
    /**
     * @return {?}
     */
    getChildren() {
        return this.children;
    }
    /**
     * 支持按索引位置插入,叶子节点不可添加
     * @param {?} children
     * @param {?=} childPos
     * @return {?}
     */
    addChildren(children, childPos = -1) {
        if (this.isLeaf) {
            // remove loading state
            this.isLoading = false;
        }
        else {
            children.forEach((node) => {
                let /** @type {?} */ tNode = node;
                if (tNode instanceof NzTreeNode) {
                    tNode = new NzTreeNode(Object.assign({ checked: !tNode.origin.disabled && !tNode.origin.disableCheckbox && this.isChecked }, (/** @type {?} */ (tNode.origin))), this);
                }
                else {
                    node.checked = !node.disabled && !node.disableCheckbox && this.isChecked;
                    tNode = new NzTreeNode(node, this);
                }
                tNode.level = this.level + 1;
                try {
                    childPos === -1 ? this.children.push(tNode) : this.children.splice(childPos, 0, tNode);
                }
                catch (/** @type {?} */ e) {
                }
            });
            // remove loading state
            this.isLoading = false;
        }
    }
    /**
     * @return {?}
     */
    clearChildren() {
        this.children = [];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTreeService {
    constructor() {
        this.DRAG_SIDE_RANGE = 0.25;
        this.DRAG_MIN_GAP = 2;
        this.rootNodes = [];
        this.selectedNodeList = [];
        this.checkedNodeList = [];
        this.halfCheckedNodeList = [];
        this.matchedNodeList = [];
    }
    /**
     * init data to NzTreeNode
     * @param {?} childNode
     * @param {?} defaultCheckedKeys
     * @param {?} nzCheckStrictly
     * @return {?}
     */
    initCheckedStatus(childNode, defaultCheckedKeys, nzCheckStrictly) {
        if (defaultCheckedKeys.indexOf(childNode.key) > -1) {
            childNode.isChecked = true;
            childNode.isAllChecked = true;
            childNode.isHalfChecked = false;
        }
        if (childNode.getChildren()) {
            childNode.getChildren().forEach((child) => {
                // will change child status
                if (!nzCheckStrictly && childNode.isChecked && !child.isDisabled && !child.isDisableCheckbox) {
                    child.isChecked = true;
                    child.isAllChecked = true;
                    child.isHalfChecked = false;
                }
                this.initCheckedStatus(child, defaultCheckedKeys, nzCheckStrictly);
            });
        }
    }
    /**
     * @param {?} root
     * @param {?=} defaultCheckedKeys
     * @param {?=} nzCheckStrictly
     * @return {?}
     */
    initTreeNodes(root, defaultCheckedKeys = [], nzCheckStrictly = false) {
        this.rootNodes = root;
        if (root.length > 0) {
            root.forEach((node) => {
                this.initCheckedStatus(node, defaultCheckedKeys, nzCheckStrictly);
            });
            if (!nzCheckStrictly) {
                root.forEach((node) => {
                    this.initParentNode(node);
                });
                // should reset node status
            }
        }
        return this.rootNodes;
    }
    /**
     * init checkBox state
     * @param {?} node
     * @return {?}
     */
    initParentNode(node) {
        if (node.getChildren().length === 0) {
            // until root
            this.checkTreeNodeParents(node);
        }
        else {
            node.children.forEach((child) => {
                this.initParentNode(child);
            });
        }
    }
    /**
     * 1、children half checked
     * 2、children all checked, parent checked
     * 3、no children checked
     * @param {?} node
     * @return {?}
     */
    checkTreeNodeParents(node) {
        const /** @type {?} */ parentNode = node.getParentNode();
        // 全禁用节点不选中
        if (parentNode && (parentNode.isDisabled || parentNode.isDisableCheckbox)) {
            if (parentNode.children.every(child => child.isDisabled || child.isDisableCheckbox)) {
                return;
            }
        }
        if (parentNode) {
            if (parentNode.children.every(child => child.isDisabled || child.isDisableCheckbox || (!child.isHalfChecked && child.isAllChecked))) {
                if (!(parentNode.isDisabled || parentNode.isDisableCheckbox)) {
                    parentNode.isChecked = true;
                    parentNode.isAllChecked = true;
                    parentNode.isHalfChecked = false;
                }
            }
            else if (parentNode.children.some(child => child.isHalfChecked || child.isAllChecked)) {
                if (!(parentNode.isDisabled || parentNode.isDisableCheckbox)) {
                    parentNode.isChecked = false;
                    parentNode.isAllChecked = false;
                    parentNode.isHalfChecked = true;
                }
            }
            else {
                parentNode.isChecked = false;
                parentNode.isAllChecked = false;
                parentNode.isHalfChecked = false;
            }
            this.checkTreeNodeParents(parentNode);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    setSelectedNode(node) {
        this.selectedNode = node;
    }
    /**
     * @return {?}
     */
    getSelectedNode() {
        return this.selectedNode;
    }
    /**
     * @param {?} node
     * @param {?} isMultiple
     * @return {?}
     */
    setSelectedNodeList(node, isMultiple) {
        if (isMultiple) {
            const /** @type {?} */ sIndex = this.selectedNodeList.findIndex(cNode => node.key === cNode.key);
            if (node.isSelected && sIndex === -1) {
                this.selectedNodeList.push(node);
            }
            else if (sIndex > -1 && !node.isSelected) {
                this.selectedNodeList.splice(sIndex, 1);
            }
        }
        else {
            if (node.isSelected) {
                this.selectedNodeList = [node];
            }
            else {
                this.selectedNodeList = [];
            }
        }
    }
    /**
     * @return {?}
     */
    getSelectedNodeList() {
        return this.selectedNodeList;
    }
    /**
     * merge checked nodes
     * @param {?} node
     * @return {?}
     */
    setCheckedNodeListStrict(node) {
        if (node.isChecked && this.checkedNodeList.findIndex(cNode => (node.key === cNode.key)) === -1) {
            this.checkedNodeList.push(node);
        }
        else if (!node.isChecked && this.checkedNodeList.findIndex(cNode => (node.key === cNode.key)) > -1) {
            // cancel checked
            this.checkedNodeList.splice(this.checkedNodeList.findIndex(cNode => (node.key === cNode.key)), 1);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    setCheckedNodeList(node) {
        if (node.isChecked && this.checkedNodeList.findIndex(cNode => (node.key === cNode.key)) === -1) {
            this.checkedNodeList.push(node);
        }
        const /** @type {?} */ removeChild = (rNode) => {
            const /** @type {?} */ rIndex = this.checkedNodeList.findIndex(cNode => (rNode.key === cNode.key));
            if (rIndex > -1) {
                this.checkedNodeList.splice(rIndex, 1);
            }
            rNode.children.forEach(child => {
                removeChild(child);
            });
        };
        // refresh tree nodes check state, merge child node checked
        this.rootNodes.forEach((rNode) => {
            const /** @type {?} */ loopNode = (lNode) => {
                const /** @type {?} */ cIndex = this.checkedNodeList.findIndex(cNode => (lNode.key === cNode.key));
                if (lNode.isChecked) {
                    if (cIndex === -1) {
                        this.checkedNodeList.push(lNode);
                    }
                    // reset child state
                    lNode.children.forEach((child) => {
                        removeChild(child);
                    });
                }
                else {
                    if (cIndex > -1) {
                        this.checkedNodeList.splice(cIndex, 1);
                    }
                    lNode.children.forEach(child => {
                        loopNode(child);
                    });
                }
            };
            loopNode(rNode);
        });
    }
    /**
     * return checked nodes
     * @return {?}
     */
    getCheckedNodeList() {
        return this.checkedNodeList;
    }
    /**
     * return half checked nodes
     * @return {?}
     */
    getHalfCheckedNodeList() {
        this.halfCheckedNodeList = [];
        this.rootNodes.forEach((rNode) => {
            const /** @type {?} */ loopNode = (lNode) => {
                const /** @type {?} */ cIndex = this.halfCheckedNodeList.findIndex(cNode => (lNode.key === cNode.key));
                if (lNode.isHalfChecked) {
                    if (cIndex === -1) {
                        this.halfCheckedNodeList.push(lNode);
                    }
                    // reset child state
                    lNode.children.forEach((child) => {
                        loopNode(child);
                    });
                }
            };
            loopNode(rNode);
        });
        return this.halfCheckedNodeList;
    }
    /**
     * return search matched nodes
     * @return {?}
     */
    getMatchedNodeList() {
        return this.matchedNodeList;
    }
    /**
     * keep selected state if isMultiple is true
     * @param {?} node
     * @param {?=} isMultiple
     * @return {?}
     */
    initNodeActive(node, isMultiple = false) {
        if (node.isDisabled) {
            return;
        }
        const /** @type {?} */ isSelected = node.isSelected;
        if (!isMultiple) {
            this.rootNodes.forEach((child) => {
                this.resetNodeActive(child);
            });
        }
        node.isSelected = !isSelected;
        this.setSelectedNodeList(node, isMultiple);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    resetNodeActive(node) {
        node.isSelected = false;
        node.children.forEach((child) => {
            this.resetNodeActive(child);
        });
    }
    /**
     * click checkbox
     * @param {?} node
     * @return {?}
     */
    checkTreeNode(node) {
        this.checkTreeNodeChildren(node, node.isChecked);
        this.checkTreeNodeParents(node);
    }
    /**
     * reset child check state
     * @param {?} node
     * @param {?} value
     * @return {?}
     */
    checkTreeNodeChildren(node, value) {
        if (!node.isDisabled && !node.isDisableCheckbox) {
            node.isChecked = value;
            node.isAllChecked = value;
            if (node.isChecked) {
                node.isHalfChecked = false;
            }
        }
        // 遍历全部子节点
        for (const /** @type {?} */ n of node.children) {
            this.checkTreeNodeChildren(n, value);
        }
    }
    /**
     * search & expand node
     * @param {?} value
     * @return {?}
     */
    searchExpand(value) {
        this.matchedNodeList = [];
        if (!value) {
            return;
        }
        const /** @type {?} */ loopParent = (node) => {
            // expand parent node
            if (node.getParentNode()) {
                node.getParentNode().isExpanded = true;
                loopParent(node.getParentNode());
            }
        };
        const /** @type {?} */ loopChild = (node) => {
            if (value && node.title.includes(value)) {
                // match the node
                this.matchedNodeList.push(node);
                // expand parentNode
                loopParent(node);
            }
            else {
                node.isExpanded = false;
            }
            node.children.forEach(cNode => {
                loopChild(cNode);
            });
        };
        this.rootNodes.forEach(node => {
            loopChild(node);
        });
    }
    /**
     * drop
     * 0: inner -1: pre 1: next
     * @param {?} targetNode
     * @param {?=} dragPos
     * @return {?}
     */
    dropAndApply(targetNode, dragPos = -1) {
        if (!targetNode || dragPos > 1) {
            return;
        }
        const /** @type {?} */ targetParent = targetNode.getParentNode();
        const /** @type {?} */ isSelectedRootNode = this.selectedNode.getParentNode();
        // remove the dragNode
        if (isSelectedRootNode) {
            isSelectedRootNode.getChildren().splice(isSelectedRootNode.getChildren().indexOf(this.selectedNode), 1);
        }
        else {
            this.rootNodes.splice(this.rootNodes.indexOf(this.selectedNode), 1);
        }
        switch (dragPos) {
            case 0:
                targetNode.addChildren([this.selectedNode]);
                this.resetNodeLevel(targetNode);
                break;
            case -1:
            case 1:
                const /** @type {?} */ tIndex = dragPos === 1 ? 1 : 0;
                if (targetParent) {
                    targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);
                    this.resetNodeLevel(this.selectedNode.getParentNode());
                }
                else {
                    const /** @type {?} */ targetIndex = this.rootNodes.indexOf(targetNode) + tIndex;
                    // 根节点插入
                    this.rootNodes.splice(targetIndex, 0, this.selectedNode);
                    this.rootNodes[targetIndex].parentNode = null;
                    this.rootNodes[targetIndex].level = 0;
                }
                break;
        }
        // flush all nodes
        this.rootNodes.forEach((child) => {
            this.initParentNode(child);
        });
    }
    /**
     * @param {?} node
     * @return {?}
     */
    resetNodeLevel(node) {
        if (node.getParentNode()) {
            node.level = node.getParentNode().level + 1;
        }
        else {
            node.level = 0;
        }
        for (const /** @type {?} */ child of node.getChildren()) {
            this.resetNodeLevel(child);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    calcDropPosition(e) {
        const { clientY } = e;
        const { top, bottom, height } = e.srcElement.getBoundingClientRect();
        const /** @type {?} */ des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);
        if (clientY <= top + des) {
            return -1;
        }
        else if (clientY >= bottom - des) {
            return 1;
        }
        return 0;
    }
    /**
     * emit Structure
     * eventName
     * node
     * event: MouseEvent / DragEvent
     * dragNode
     * @param {?} eventName
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    formatEvent(eventName, node, event) {
        const /** @type {?} */ emitStructure = {
            'eventName': eventName,
            'node': node,
            'event': event
        };
        switch (eventName) {
            case 'dragstart':
            case 'dragenter':
            case 'dragover':
            case 'dragleave':
            case 'drop':
            case 'dragend':
                Object.assign(emitStructure, { 'dragNode': this.getSelectedNode() });
                break;
            case 'click':
                Object.assign(emitStructure, { 'selectedKeys': this.getSelectedNodeList() });
                break;
            case 'check':
                Object.assign(emitStructure, { 'checkedKeys': this.getCheckedNodeList() });
                break;
            case 'search':
                Object.assign(emitStructure, { 'matchedKeys': this.getMatchedNodeList() });
                break;
        }
        return emitStructure;
    }
}
NzTreeService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTreeNodeComponent {
    /**
     * @param {?} nzTreeService
     * @param {?} ngZone
     * @param {?} renderer
     */
    constructor(nzTreeService, ngZone, renderer) {
        this.nzTreeService = nzTreeService;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.dragPos = 2;
        this.prefixCls = 'ant-tree';
        this._expandAll = false;
        this._defaultCheckedKeys = [];
        this._defaultExpandedKeys = [];
        this._defaultSelectedKeys = [];
        this._searchValue = '';
        this.matchValue = [];
        // 拖动划过状态
        this.dragPosClass = {
            '0': 'drag-over',
            '1': 'drag-over-gap-bottom',
            '-1': 'drag-over-gap-top'
        };
        this.clickNode = new EventEmitter();
        this.dblClick = new EventEmitter();
        this.contextMenu = new EventEmitter();
        this.clickCheckBox = new EventEmitter();
        this.clickExpand = new EventEmitter();
        this.nzDragStart = new EventEmitter();
        this.nzDragEnter = new EventEmitter();
        this.nzDragOver = new EventEmitter();
        this.nzDragLeave = new EventEmitter();
        this.nzDrop = new EventEmitter();
        this.nzDragEnd = new EventEmitter();
    }
    /**
     * @param {?} node
     * @return {?}
     */
    set nzTreeNode(node) {
        this._treeNode = node;
    }
    /**
     * @return {?}
     */
    get nzTreeNode() {
        return this._treeNode;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDefaultExpandAll(value) {
        if (value && this.nzTreeNode) {
            this.nzTreeNode.isExpanded = value;
        }
        this._expandAll = value;
    }
    /**
     * @return {?}
     */
    get nzDefaultExpandAll() {
        return this._expandAll;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDefaultExpandedKeys(value) {
        this._defaultExpandedKeys = value;
        if (value && value.indexOf(this.nzTreeNode.key) > -1) {
            this.nzTreeNode.isExpanded = true;
        }
    }
    /**
     * @return {?}
     */
    get nzDefaultExpandedKeys() {
        return this._defaultExpandedKeys;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDefaultSelectedKeys(value) {
        this._defaultSelectedKeys = value;
        if (value && !this.nzTreeNode.isDisabled && value.indexOf(this.nzTreeNode.key) > -1) {
            this.nzTreeNode.isSelected = true;
            this.nzTreeService.setSelectedNodeList(this.nzTreeNode, this.nzMultiple);
        }
    }
    /**
     * @return {?}
     */
    get nzDefaultSelectedKeys() {
        return this._defaultSelectedKeys;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSearchValue(value) {
        if (value && this.nzTreeNode.title.includes(value)) {
            this.nzTreeNode.isMatched = true;
            this.matchValue = [];
            // match the search value
            const /** @type {?} */ index = this.nzTreeNode.title.indexOf(value);
            this.matchValue.push(this.nzTreeNode.title.slice(0, index));
            this.matchValue.push(this.nzTreeNode.title.slice(index + value.length, this.nzTreeNode.title.length));
        }
        else {
            // close the node if title does't contain search value
            this.nzTreeNode.isMatched = false;
            this.matchValue = [];
        }
        this._searchValue = value;
    }
    /**
     * @return {?}
     */
    get nzSearchValue() {
        return this._searchValue;
    }
    /**
     * @return {?}
     */
    get loadingStyle() {
        const /** @type {?} */ isLoading = this.nzTreeNode.isLoading && !this.nzTreeNode.isLeaf;
        return {
            position: isLoading ? 'relative' : '',
            transform: isLoading ? 'translateX(0%)' : ''
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.nzTreeNode.isChecked) {
            // associate nodes
            if (this.nzCheckStrictly) {
                this.nzTreeService.setCheckedNodeListStrict(this.nzTreeNode);
            }
            else {
                this.nzTreeService.setCheckedNodeList(this.nzTreeNode);
            }
        }
        // add select list
        if (this.nzTreeNode.isSelected) {
            this.nzTreeService.setSelectedNodeList(this.nzTreeNode, this.nzMultiple);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    handleDragStart(e) {
        e.stopPropagation();
        this.nzTreeService.setSelectedNode(this.nzTreeNode);
        this.nzTreeNode.isExpanded = false;
        this.nzDragStart.emit(this.nzTreeService.formatEvent('dragstart', null, e));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    handleDragEnter(e) {
        e.preventDefault();
        e.stopPropagation();
        this.ngZone.run(() => {
            this.nzTreeService.targetNode = this.nzTreeNode;
            if ((this.nzTreeNode !== this.nzTreeService.getSelectedNode()) && !this.nzTreeNode.isLeaf) {
                this.nzTreeNode.isExpanded = true;
            }
        });
        this.nzDragEnter.emit(this.nzTreeService.formatEvent('dragenter', this.nzTreeNode, e));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.dragPos !== this.nzTreeService.calcDropPosition(e)) {
            this._clearDragClass();
            this.dragPos = this.nzTreeService.calcDropPosition(e);
            if (!(this.dragPos === 0 && this.nzTreeNode.isLeaf)) {
                // leaf node can not be inserted
                this.renderer.addClass(this.dragElement.nativeElement, this.dragPosClass[this.dragPos]);
            }
        }
        this.nzDragOver.emit(this.nzTreeService.formatEvent('dragover', this.nzTreeNode, e));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    handleDragLeave(e) {
        e.stopPropagation();
        this.ngZone.run(() => {
            this._clearDragClass();
        });
        this.nzDragLeave.emit(this.nzTreeService.formatEvent('dragleave', this.nzTreeNode, e));
    }
    /**
     * @param {?} e
     * @return {?}
     */
    handleDragDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        this.dragPos = this.nzTreeService.calcDropPosition(e);
        this.ngZone.run(() => {
            // pass if node is leafNo
            if (this.nzTreeNode !== this.nzTreeService.getSelectedNode() && !(this.dragPos === 0 && this.nzTreeNode.isLeaf)) {
                if (this.nzBeforeDrop) {
                    this.nzBeforeDrop({
                        dragNode: this.nzTreeService.getSelectedNode(),
                        node: this.nzTreeNode,
                        pos: this.dragPos
                    }).subscribe((canDrop) => {
                        if (canDrop) {
                            this.nzTreeService.dropAndApply(this.nzTreeNode, this.dragPos);
                        }
                        this.nzDrop.emit(this.nzTreeService.formatEvent('drop', this.nzTreeNode, e));
                        this.nzDragEnd.emit(this.nzTreeService.formatEvent('dragend', this.nzTreeNode, e));
                    });
                }
                else {
                    this.nzTreeService.dropAndApply(this.nzTreeNode, this.dragPos);
                    this.nzDrop.emit(this.nzTreeService.formatEvent('drop', this.nzTreeNode, e));
                }
            }
            this._clearDragClass();
        });
    }
    /**
     * @param {?} e
     * @return {?}
     */
    handleDragEnd(e) {
        e.stopPropagation();
        this.ngZone.run(() => {
            // if user do not custom beforeDrop
            if (!this.nzBeforeDrop) {
                this.nzTreeService.setSelectedNode(null);
                this.nzDragEnd.emit(this.nzTreeService.formatEvent('dragend', this.nzTreeNode, e));
            }
        });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.nzDraggable) {
            this.ngZone.runOutsideAngular(() => {
                fromEvent(this.dragElement.nativeElement, 'dragstart').subscribe((e) => this.handleDragStart(e));
                fromEvent(this.dragElement.nativeElement, 'dragenter').subscribe((e) => this.handleDragEnter(e));
                fromEvent(this.dragElement.nativeElement, 'dragover').subscribe((e) => this.handleDragOver(e));
                fromEvent(this.dragElement.nativeElement, 'dragleave').subscribe((e) => this.handleDragLeave(e));
                fromEvent(this.dragElement.nativeElement, 'drop').subscribe((e) => this.handleDragDrop(e));
                fromEvent(this.dragElement.nativeElement, 'dragend').subscribe((e) => this.handleDragEnd(e));
            });
        }
    }
    /**
     * @return {?}
     */
    _clearDragClass() {
        const /** @type {?} */ dragClass = ['drag-over-gap-top', 'drag-over-gap-bottom', 'drag-over'];
        dragClass.forEach(e => {
            this.renderer.removeClass(this.dragElement.nativeElement, e);
        });
    }
    /**
     * @param {?} $event
     * @param {?} node
     * @return {?}
     */
    _clickNode($event, node) {
        $event.preventDefault();
        $event.stopPropagation();
        if (this.nzTreeNode.isSelectable && !this.nzTreeNode.isDisabled) {
            this.nzTreeService.initNodeActive(this.nzTreeNode, this.nzMultiple);
        }
        this.clickNode.emit(this.nzTreeService.formatEvent('click', node, $event));
    }
    /**
     * @param {?} $event
     * @param {?} node
     * @return {?}
     */
    _dblClickNode($event, node) {
        $event.preventDefault();
        $event.stopPropagation();
        this.dblClick.emit(this.nzTreeService.formatEvent('dblclick', node, $event));
    }
    /**
     * @param {?} $event
     * @param {?} node
     * @return {?}
     */
    _contextMenuNode($event, node) {
        $event.preventDefault();
        $event.stopPropagation();
        this.contextMenu.emit(this.nzTreeService.formatEvent('contextmenu', node, $event));
    }
    /**
     * @param {?} $event
     * @param {?} node
     * @return {?}
     */
    _clickCheckBox($event, node) {
        $event.preventDefault();
        $event.stopPropagation();
        // return if node is disabled
        if (node.isDisableCheckbox || node.isDisabled) {
            return;
        }
        node.isChecked = !node.isChecked;
        if (this.nzCheckStrictly) {
            node.isAllChecked = node.isChecked;
            node.isHalfChecked = false;
            this.nzTreeService.setCheckedNodeListStrict(this.nzTreeNode);
        }
        else {
            this.nzTreeService.checkTreeNode(node);
            this.nzTreeService.setCheckedNodeList(this.nzTreeNode);
        }
        this.clickCheckBox.emit(this.nzTreeService.formatEvent('check', node, $event));
    }
    /**
     * @param {?} $event
     * @param {?} node
     * @return {?}
     */
    _clickExpand($event, node) {
        $event.preventDefault();
        $event.stopPropagation();
        if (!this.nzTreeNode.isLoading) {
            if (!node.isLeaf) {
                // set async state
                if (this.nzAsyncData && this.nzTreeNode.getChildren().length === 0 && !this.nzTreeNode.isExpanded) {
                    this.nzTreeNode.isLoading = true;
                }
                node.isExpanded = !this.nzTreeNode.isExpanded;
            }
            if (!this.nzTreeNode.isLeaf) {
                this.clickExpand.emit(this.nzTreeService.formatEvent('expand', node, $event));
            }
        }
    }
}
NzTreeNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-tree-node',
                template: `<li #dragElement [class.ant-tree-treenode-disabled]="nzTreeNode.isDisabled" (dblclick)="_dblClickNode($event,nzTreeNode)" (click)="_clickNode($event,nzTreeNode)" (contextmenu)="_contextMenuNode($event,nzTreeNode)"> <ng-container *ngIf="nzShowExpand"> <span class="ant-tree-switcher" [ngStyle]="loadingStyle" [class.ant-tree-switcher_open]="nzTreeNode.isExpanded && !nzTreeNode.isLeaf && !nzTreeNode.isLoading" [class.ant-tree-switcher_close]="!nzTreeNode.isExpanded && !nzTreeNode.isLeaf && !nzTreeNode.isLoading" [class.ant-tree-switcher-noop]="nzTreeNode.isLeaf && !nzTreeNode.isLoading" [class.ant-tree-switcher-disabled]="nzTreeNode.isDisabled && !nzTreeNode.isLoading" [class.ant-tree-iconEle]="nzTreeNode.isLoading && !nzTreeNode.isLeaf" [class.ant-tree-icon_loading]="nzTreeNode.isLoading && !nzTreeNode.isLeaf" [class.ant-tree-icon__open]="nzTreeNode.isLoading && nzTreeNode.isExpanded && !nzTreeNode.isLeaf" [class.ant-tree-icon__close]="nzTreeNode.isLoading && !nzTreeNode.isExpanded && !nzTreeNode.isLeaf" (click)="_clickExpand($event, nzTreeNode)"> </span> </ng-container> <ng-container #checkbox *ngIf="nzCheckable"> <span class="ant-tree-checkbox" [class.ant-tree-checkbox-checked]="nzTreeNode.isChecked && nzTreeNode.isAllChecked" [class.ant-tree-checkbox-disabled]="nzTreeNode.isDisabled || nzTreeNode.isDisableCheckbox" [class.ant-tree-checkbox-indeterminate]="nzTreeNode.isHalfChecked" (click)="_clickCheckBox($event, nzTreeNode)"> <span class="ant-tree-checkbox-inner"></span> </span> </ng-container> <ng-container *ngIf="!nzTreeTemplate"> <span title="{{nzTreeNode.title}}" class="ant-tree-node-content-wrapper" [class.ant-tree-node-selected]="nzTreeNode.isSelected" [class.ant-tree-node-content-wrapper-open]="nzTreeNode.isExpanded && nzTreeNode.getChildren().length>0" [class.ant-tree-node-content-wrapper-close]="!nzTreeNode.isExpanded && nzTreeNode.getChildren().length>0" [class.ant-tree-node-content-wrapper-normal]="nzTreeNode.getChildren().length>0" [attr.draggable]="nzDraggable" [attr.aria-grabbed]="nzDraggable"> <span class="ant-tree-title"> <ng-container *ngIf="matchValue.length==2"> <span> {{matchValue[0]}}<span class="font-highlight">{{nzSearchValue}}</span>{{matchValue[1]}} </span> </ng-container> <ng-container *ngIf="matchValue.length!=2"> {{nzTreeNode.title}} </ng-container> </span> </span> </ng-container> <ng-template [ngTemplateOutlet]="nzTreeTemplate" [ngTemplateOutletContext]="{ $implicit: nzTreeNode }"> </ng-template> <ul class="ant-tree-child-tree ant-tree-child-tree-open" [attr.data-expanded]="nzTreeNode.isExpanded" [@expandState]="(nzTreeNode.getChildren().length>0 && nzTreeNode.isExpanded)?'active':'inactive'"> <nz-tree-node *ngFor="let node of nzTreeNode.children" [nzTreeNode]="node" [nzShowLine]="nzShowLine" [nzDraggable]="nzDraggable" [nzCheckable]="nzCheckable" [nzShowExpand]="nzShowExpand" [nzSearchValue]="nzSearchValue" [nzAsyncData]="nzAsyncData" [nzMultiple]="nzMultiple" [nzBeforeDrop]="nzBeforeDrop" [nzCheckStrictly]="nzCheckStrictly" [nzDefaultExpandAll]="nzDefaultExpandAll" [nzDefaultExpandedKeys]="nzDefaultExpandedKeys" [nzDefaultSelectedKeys]="nzDefaultSelectedKeys" [nzTreeTemplate]="nzTreeTemplate" (clickNode)="clickNode.emit($event)" (dblClick)="dblClick.emit($event)" (contextMenu)="contextMenu.emit($event)" (clickCheckBox)="clickCheckBox.emit($event)" (clickExpand)="clickExpand.emit($event)" (nzDragStart)="nzDragStart.emit($event)" (nzDragEnter)="nzDragEnter.emit($event)" (nzDragOver)="nzDragOver.emit($event)" (nzDragLeave)="nzDragLeave.emit($event)" (nzDrop)="nzDrop.emit($event)" (nzDragEnd)="nzDragEnd.emit($event)"> </nz-tree-node> </ul> </li> `,
                animations: [
                    trigger('expandState', [
                        state('inactive', style({
                            opacity: '0',
                            height: 0,
                            display: 'none'
                        })),
                        state('active', style({
                            opacity: '1',
                            height: '*'
                        })),
                        transition('inactive => active', animate('150ms ease-in')),
                        transition('active => inactive', animate('150ms ease-out'))
                    ])
                ]
            },] },
];
/** @nocollapse */
NzTreeNodeComponent.ctorParameters = () => [
    { type: NzTreeService },
    { type: NgZone },
    { type: Renderer2 }
];
NzTreeNodeComponent.propDecorators = {
    dragElement: [{ type: ViewChild, args: ['dragElement',] }],
    nzShowLine: [{ type: Input }],
    nzShowExpand: [{ type: Input }],
    nzDraggable: [{ type: Input }],
    nzMultiple: [{ type: Input }],
    nzCheckable: [{ type: Input }],
    nzAsyncData: [{ type: Input }],
    nzCheckStrictly: [{ type: Input }],
    nzTreeTemplate: [{ type: Input }],
    nzBeforeDrop: [{ type: Input }],
    nzTreeNode: [{ type: Input }],
    nzDefaultExpandAll: [{ type: Input }],
    nzDefaultExpandedKeys: [{ type: Input }],
    nzDefaultSelectedKeys: [{ type: Input }],
    nzSearchValue: [{ type: Input }],
    clickNode: [{ type: Output }],
    dblClick: [{ type: Output }],
    contextMenu: [{ type: Output }],
    clickCheckBox: [{ type: Output }],
    clickExpand: [{ type: Output }],
    nzDragStart: [{ type: Output }],
    nzDragEnter: [{ type: Output }],
    nzDragOver: [{ type: Output }],
    nzDragLeave: [{ type: Output }],
    nzDrop: [{ type: Output }],
    nzDragEnd: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTreeComponent {
    /**
     * @param {?} nzTreeService
     */
    constructor(nzTreeService) {
        this.nzTreeService = nzTreeService;
        this._showLine = false;
        this._prefixCls = 'ant-tree';
        this.classMap = {
            [this._prefixCls]: true,
            [this._prefixCls + '-show-line']: false,
            ['draggable-tree']: false
        };
        this.ngModelNodes = [];
        this.defaultCheckedKeys = [];
        this.nzCheckStrictly = false;
        this.nzShowExpand = true;
        this.nzAsyncData = false;
        this.nzDefaultExpandAll = false;
        this.nzDefaultExpandedKeys = [];
        this.nzDefaultSelectedKeys = [];
        this.nzOnSearchNode = new EventEmitter();
        this.nzClick = new EventEmitter();
        this.nzDblClick = new EventEmitter();
        this.nzContextMenu = new EventEmitter();
        this.nzCheckBoxChange = new EventEmitter();
        this.nzExpandChange = new EventEmitter();
        this.nzOnDragStart = new EventEmitter();
        this.nzOnDragEnter = new EventEmitter();
        this.nzOnDragOver = new EventEmitter();
        this.nzOnDragLeave = new EventEmitter();
        this.nzOnDrop = new EventEmitter();
        this.nzOnDragEnd = new EventEmitter();
        this.onChange = () => null;
        this.onTouched = () => null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDefaultCheckedKeys(value) {
        this.defaultCheckedKeys = value;
        this.nzTreeService.initTreeNodes(this.ngModelNodes, this.nzDefaultCheckedKeys, this.nzCheckStrictly);
    }
    /**
     * @return {?}
     */
    get nzDefaultCheckedKeys() {
        return this.defaultCheckedKeys;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowLine(value) {
        this._showLine = value;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get nzShowLine() {
        return this._showLine;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSearchValue(value) {
        this._searchValue = value;
        this.nzTreeService.searchExpand(value);
        this.nzOnSearchNode.emit(this.nzTreeService.formatEvent('search', null, null));
    }
    /**
     * @return {?}
     */
    get nzSearchValue() {
        return this._searchValue;
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.classMap = {
            [this._prefixCls]: true,
            [this._prefixCls + '-show-line']: this.nzShowLine,
            ['draggable-tree']: this.nzDraggable
        };
    }
    /**
     * public function
     * @return {?}
     */
    getCheckedNodeList() {
        return this.nzTreeService.getCheckedNodeList();
    }
    /**
     * @return {?}
     */
    getSelectedNodeList() {
        return this.nzTreeService.getSelectedNodeList();
    }
    /**
     * @return {?}
     */
    getHalfCheckedNodeList() {
        return this.nzTreeService.getHalfCheckedNodeList();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            this.ngModelNodes = value;
            this.nzTreeService.initTreeNodes(this.ngModelNodes, this.nzDefaultCheckedKeys, this.nzCheckStrictly);
            this.onChange(value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
NzTreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-tree',
                template: `<ul class="ant-tree" [ngClass]="classMap" role="tree-node" unselectable="on"> <nz-tree-node *ngFor="let node of ngModelNodes" [nzTreeNode]="node" [nzShowLine]="nzShowLine" [nzTreeTemplate]="nzTreeTemplate" [nzShowExpand]="nzShowExpand" [nzSearchValue]="nzSearchValue" [nzAsyncData]="nzAsyncData" [nzMultiple]="nzMultiple" [nzDraggable]="nzDraggable" [nzCheckable]="nzCheckable" [nzBeforeDrop]="nzBeforeDrop" [nzCheckStrictly]="nzCheckStrictly" [nzDefaultExpandAll]="nzDefaultExpandAll" [nzDefaultExpandedKeys]="nzDefaultExpandedKeys" [nzDefaultSelectedKeys]="nzDefaultSelectedKeys" (clickCheckBox)="nzCheckBoxChange.emit($event)" (clickExpand)="nzExpandChange.emit($event)" (clickNode)="nzClick.emit($event)" (dblClick)="nzDblClick.emit($event)" (contextMenu)="nzContextMenu.emit($event)" (nzDragStart)="nzOnDragStart.emit($event)" (nzDragEnter)="nzOnDragEnter.emit($event)" (nzDragOver)="nzOnDragOver.emit($event)" (nzDragLeave)="nzOnDragLeave.emit($event)" (nzDrop)="nzOnDrop.emit($event)" (nzDragEnd)="nzOnDragEnd.emit($event)" ></nz-tree-node> </ul>`,
                providers: [
                    NzTreeService,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzTreeComponent),
                        multi: true
                    }
                ]
            },] },
];
/** @nocollapse */
NzTreeComponent.ctorParameters = () => [
    { type: NzTreeService }
];
NzTreeComponent.propDecorators = {
    nzTreeTemplate: [{ type: ContentChild, args: ['nzTreeTemplate',] }],
    nzCheckStrictly: [{ type: Input }],
    nzCheckable: [{ type: Input }],
    nzShowExpand: [{ type: Input }],
    nzAsyncData: [{ type: Input }],
    nzDraggable: [{ type: Input }],
    nzMultiple: [{ type: Input }],
    nzDefaultExpandAll: [{ type: Input }],
    nzDefaultExpandedKeys: [{ type: Input }],
    nzDefaultSelectedKeys: [{ type: Input }],
    nzBeforeDrop: [{ type: Input }],
    nzDefaultCheckedKeys: [{ type: Input }],
    nzShowLine: [{ type: Input }],
    nzSearchValue: [{ type: Input }],
    nzOnSearchNode: [{ type: Output }],
    nzClick: [{ type: Output }],
    nzDblClick: [{ type: Output }],
    nzContextMenu: [{ type: Output }],
    nzCheckBoxChange: [{ type: Output }],
    nzExpandChange: [{ type: Output }],
    nzOnDragStart: [{ type: Output }],
    nzOnDragEnter: [{ type: Output }],
    nzOnDragOver: [{ type: Output }],
    nzOnDragLeave: [{ type: Output }],
    nzOnDrop: [{ type: Output }],
    nzOnDragEnd: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTreeModule {
}
NzTreeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NzTreeComponent, NzTreeNodeComponent],
                exports: [NzTreeComponent, NzTreeNodeComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const selectDropDownAnimation = trigger('selectDropDownAnimation', [
    state('hidden', style({
        opacity: 0,
        display: 'none'
    })),
    state('bottom', style({
        opacity: 1,
        transform: 'scaleY(1)',
        transformOrigin: '0% 0%'
    })),
    state('top', style({
        opacity: 1,
        transform: 'scaleY(1)',
        transformOrigin: '0% 100%'
    })),
    transition('hidden => bottom', [
        style({
            opacity: 0,
            transform: 'scaleY(0.8)',
            transformOrigin: '0% 0%'
        }),
        animate('100ms cubic-bezier(0.755, 0.05, 0.855, 0.06)')
    ]),
    transition('bottom => hidden', [
        animate('100ms cubic-bezier(0.755, 0.05, 0.855, 0.06)', style({
            opacity: 0,
            transform: 'scaleY(0.8)',
            transformOrigin: '0% 0%'
        }))
    ]),
    transition('hidden => top', [
        style({
            opacity: 0,
            transform: 'scaleY(0.8)',
            transformOrigin: '0% 100%'
        }),
        animate('100ms cubic-bezier(0.755, 0.05, 0.855, 0.06)')
    ]),
    transition('top => hidden', [
        animate('100ms cubic-bezier(0.755, 0.05, 0.855, 0.06)', style({
            opacity: 0,
            transform: 'scaleY(0.8)',
            transformOrigin: '0% 100%'
        }))
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const selectTagAnimation = trigger('selectTagAnimation', [
    state('*', style({ opacity: 1, transform: 'scale(1)' })),
    transition('void => *', [
        style({ opacity: 0, transform: 'scale(0)' }),
        animate('150ms linear')
    ]),
    state('void', style({ opacity: 0, transform: 'scale(0)' })),
    transition('* => void', [
        style({ opacity: 1, transform: 'scale(1)' }),
        animate('150ms linear')
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTreeSelectComponent {
    /**
     * @param {?} document
     * @param {?} element
     * @param {?} renderer
     * @param {?} overlay
     * @param {?} viewContainerRef
     */
    constructor(document, // tslint:disable-line:no-any
    // tslint:disable-line:no-any
    element, renderer, overlay, viewContainerRef) {
        this.document = document;
        this.element = element;
        this.renderer = renderer;
        this.overlay = overlay;
        this.viewContainerRef = viewContainerRef;
        this.isInit = false;
        this.isComposing = false;
        this.isDestroy = true;
        this.inputValue = '';
        this.dropDownPosition = 'bottom';
        this.selectedNodes = [];
        this.value = [];
        this.nzOpen = false;
        this.nzAllowClear = true;
        this.nzSize = 'default';
        this.nzDropdownMatchSelectWidth = true;
        this.nzPlaceHolder = '';
        this.nzShowSearch = true;
        this.nzDisabled = false;
        this.nzCheckable = false;
        this.nzShowExpand = true;
        this.nzShowLine = false;
        this.nzAsyncData = false;
        this.nzMultiple = false;
        this.nzDefaultExpandAll = false;
        this.nzDefaultExpandedKeys = [];
        this.nzNodes = [];
        this.nzOpenChange = new EventEmitter();
        this.nzCleared = new EventEmitter();
        this.nzRemoved = new EventEmitter();
        this.nzExpandChange = new EventEmitter();
        this.nzTreeClick = new EventEmitter();
        this.nzTreeCheckBoxChange = new EventEmitter();
        this.onTouched = () => null;
    }
    /**
     * @return {?}
     */
    get placeHolderDisplay() {
        return this.inputValue || this.isComposing || this.selectedNodes.length ? 'none' : 'block';
    }
    /**
     * @return {?}
     */
    get searchDisplay() {
        return this.nzOpen ? 'block' : 'none';
    }
    /**
     * @return {?}
     */
    get isMultiple() {
        return this.nzMultiple || this.nzCheckable;
    }
    /**
     * @return {?}
     */
    get selectedValueDisplay() {
        let /** @type {?} */ showSelectedValue = false;
        let /** @type {?} */ opacity = 1;
        if (!this.nzShowSearch) {
            showSelectedValue = true;
        }
        else {
            if (this.nzOpen) {
                showSelectedValue = !(this.inputValue || this.isComposing);
                if (showSelectedValue) {
                    opacity = 0.4;
                }
            }
            else {
                showSelectedValue = true;
            }
        }
        return {
            display: showSelectedValue ? 'block' : 'none',
            opacity: `${opacity}`
        };
    }
    /**
     * @return {?}
     */
    trigger() {
        if (this.nzDisabled || (!this.nzDisabled && this.nzOpen)) {
            this.closeDropDown();
        }
        else {
            this.openDropdown();
            if (this.nzShowSearch) {
                this.focusOnInput();
            }
        }
    }
    /**
     * @return {?}
     */
    openDropdown() {
        if (!this.nzDisabled) {
            this.nzOpen = true;
            this.nzOpenChange.emit(this.nzOpen);
            this.updateCdkConnectedOverlayStatus();
            this.updatePosition();
            this.updateDropDownClassMap();
        }
    }
    /**
     * @return {?}
     */
    closeDropDown() {
        this.onTouched();
        this.nzOpen = false;
        this.nzOpenChange.emit(this.nzOpen);
        this.updateCdkConnectedOverlayStatus();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDownInput(e) {
        const /** @type {?} */ keyCode = e.keyCode;
        const /** @type {?} */ eventTarget = /** @type {?} */ (e.target);
        if (this.isMultiple &&
            !eventTarget.value &&
            keyCode === BACKSPACE) {
            e.preventDefault();
            if (this.selectedNodes.length) {
                this.removeSelected(this.selectedNodes[this.selectedNodes.length - 1]);
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setInputValue(value) {
        this.inputValue = value;
        this.updateInputWidth();
        this.updatePosition();
    }
    /**
     * @return {?}
     */
    detachOverlay() {
        if (this.overlayRef && this.overlayRef.hasAttached()) {
            this.overlayRef.detach();
            this.overlayBackdropClickSubscription.unsubscribe();
            this.onTouched();
            this.nzOpen = false;
            this.nzOpenChange.emit(this.nzOpen);
        }
    }
    /**
     * @param {?} node
     * @param {?=} emit
     * @return {?}
     */
    removeSelected(node, emit = true) {
        node.isSelected = false;
        node.isChecked = false;
        if (this.nzCheckable) {
            this.treeRef.nzTreeService.checkTreeNode(node);
            this.treeRef.nzTreeService.setCheckedNodeList(node);
        }
        else {
            this.treeRef.nzTreeService.setSelectedNodeList(node, this.nzMultiple);
        }
        if (emit) {
            this.nzRemoved.emit(node);
        }
    }
    /**
     * @return {?}
     */
    focusOnInput() {
        setTimeout(() => {
            if (this.inputElement) {
                this.inputElement.nativeElement.focus();
            }
        });
    }
    /**
     * @return {?}
     */
    attachOverlay() {
        this.portal = new TemplatePortal(this.dropdownTemplate, this.viewContainerRef);
        this.overlayRef = this.overlay.create(this.getOverlayConfig());
        this.overlayRef.attach(this.portal);
        this.overlayBackdropClickSubscription = this.subscribeOverlayBackdropClick();
    }
    /**
     * @return {?}
     */
    getOverlayConfig() {
        const /** @type {?} */ overlayWidth = this.treeSelect.nativeElement.getBoundingClientRect().width;
        return new OverlayConfig({
            positionStrategy: this.getOverlayPosition(),
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
            [this.nzDropdownMatchSelectWidth ? 'width' : 'minWidth']: overlayWidth,
            hasBackdrop: true
        });
    }
    /**
     * @return {?}
     */
    getOverlayPosition() {
        const /** @type {?} */ positions = [
            new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),
            new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
        ];
        this.positionStrategy = this.overlay.position()
            .flexibleConnectedTo(this.treeSelect)
            .withPositions(positions)
            .withFlexibleDimensions(false)
            .withPush(false);
        return this.positionStrategy;
    }
    /**
     * @return {?}
     */
    subscribeOverlayBackdropClick() {
        return this.overlayRef.backdropClick()
            .subscribe(() => {
            this.closeDropDown();
        });
    }
    /**
     * @return {?}
     */
    subscribeSelectionChange() {
        return merge(this.nzTreeClick.pipe(tap((event) => {
            const /** @type {?} */ node = event.node;
            if (this.nzCheckable && !node.isDisabled && !node.isDisableCheckbox) {
                node.isChecked = !node.isChecked;
                this.treeRef.nzTreeService.checkTreeNode(node);
                this.treeRef.nzTreeService.setCheckedNodeList(node);
            }
            if (this.nzCheckable) {
                node.isSelected = false;
            }
        }), filter((event) => {
            return this.nzCheckable ? (!event.node.isDisabled && !event.node.isDisableCheckbox) : !event.node.isDisabled;
        })), this.nzCheckable ? this.nzTreeCheckBoxChange : of(), this.nzCleared, this.nzRemoved).subscribe(() => {
            this.updateSelectedNodes();
            const /** @type {?} */ value = this.selectedNodes.map(node => node.key);
            this.value = [...value];
            if (this.nzShowSearch) {
                this.inputValue = '';
            }
            if (this.isMultiple) {
                this.onChange(value);
                if (this.nzShowSearch) {
                    this.focusOnInput();
                }
            }
            else {
                this.closeDropDown();
                this.onChange(value.length ? value[0] : null);
            }
        });
    }
    /**
     * @return {?}
     */
    updateSelectedNodes() {
        this.selectedNodes = [...(this.nzCheckable ? this.treeRef.getCheckedNodeList() : this.treeRef.getSelectedNodeList())];
    }
    /**
     * @return {?}
     */
    updatePosition() {
        this.overlayRef.updatePosition();
    }
    /**
     * @return {?}
     */
    updateInputWidth() {
        if (this.isMultiple && this.inputElement) {
            if (this.inputValue || this.isComposing) {
                this.renderer.setStyle(this.inputElement.nativeElement, 'width', `${this.inputElement.nativeElement.scrollWidth}px`);
            }
            else {
                this.renderer.removeStyle(this.inputElement.nativeElement, 'width');
            }
        }
    }
    /**
     * @return {?}
     */
    onClearSelection() {
        this.selectedNodes.forEach(node => {
            this.removeSelected(node, false);
        });
        this.nzCleared.emit();
        this.closeDropDown();
    }
    /**
     * @return {?}
     */
    updateDropDownClassMap() {
        if (this.treeRef && !this.treeRef.classMap['ant-select-tree']) {
            this.treeRef.classMap = Object.assign({}, this.treeRef.classMap, { ['ant-select-tree']: true });
        }
        this.dropDownClassMap = {
            ['ant-select-dropdown']: true,
            ['ant-select-tree-dropdown']: true,
            [`ant-select-dropdown--single`]: !this.nzMultiple,
            [`ant-select-dropdown--multiple`]: this.nzMultiple,
            [`ant-select-dropdown-placement-bottomLeft`]: this.dropDownPosition === 'bottom',
            [`ant-select-dropdown-placement-topLeft`]: this.dropDownPosition === 'top'
        };
    }
    /**
     * @return {?}
     */
    updateCdkConnectedOverlayStatus() {
        const /** @type {?} */ overlayWidth = this.treeSelect.nativeElement.getBoundingClientRect().width;
        if (this.nzDropdownMatchSelectWidth) {
            this.overlayRef.updateSize({ width: overlayWidth });
        }
        else {
            this.overlayRef.updateSize({ minWidth: overlayWidth });
        }
        if (this.nzOpen) {
            this.renderer.removeStyle(this.overlayRef.backdropElement, 'display');
        }
        else {
            this.renderer.setStyle(this.overlayRef.backdropElement, 'display', 'none');
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            if (this.isMultiple && Array.isArray(value)) {
                this.value = value;
            }
            else {
                this.value = [(/** @type {?} */ (value))];
            }
            setTimeout(() => this.updateSelectedNodes(), 100);
        }
        else {
            this.value = [];
            this.selectedNodes.forEach(node => {
                this.removeSelected(node, false);
            });
            this.selectedNodes = [];
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isDestroy = false;
        this.selectionChangeSubscription = this.subscribeSelectionChange();
        Promise.resolve().then(() => {
            this.updateDropDownClassMap();
            this.updateCdkConnectedOverlayStatus();
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.isDestroy = true;
        this.detachOverlay();
        this.selectionChangeSubscription.unsubscribe();
        this.overlayBackdropClickSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.attachOverlay();
        this.isInit = true;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.nzDisabled = isDisabled;
        this.closeDropDown();
    }
}
NzTreeSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-tree-select',
                animations: [selectDropDownAnimation, selectTagAnimation],
                template: `<ng-template #inputTemplate> <input #inputElement autocomplete="off" class="ant-select-search__field" (compositionstart)="isComposing = true" (compositionend)="isComposing = false" (keydown)="onKeyDownInput($event)" [ngModel]="inputValue" (ngModelChange)="setInputValue($event, true)" [disabled]="nzDisabled"> </ng-template> <ng-template #dropdownTemplate> <div [ngClass]="dropDownClassMap" [@selectDropDownAnimation]="nzOpen ? dropDownPosition : 'hidden'" [ngStyle]="nzDropdownStyle"> <nz-tree #treeRef [ngModel]="nzNodes" [nzMultiple]="nzMultiple" [nzSearchValue]="inputValue" [nzCheckable]="nzCheckable" [nzAsyncData]="nzAsyncData" [nzShowExpand]="nzShowExpand" [nzShowLine]="nzShowLine" [nzDefaultExpandAll]="nzDefaultExpandAll" [nzDefaultExpandedKeys]="nzDefaultExpandedKeys" [nzDefaultCheckedKeys]="nzCheckable ? value : []" [nzDefaultSelectedKeys]="!nzCheckable ? value : []" (nzExpandChange)="nzExpandChange.emit($event)" (nzClick)="nzTreeClick.emit($event)" (nzCheckBoxChange)="nzTreeCheckBoxChange.emit($event)" > </nz-tree> </div> </ng-template> <div #treeSelect class="ant-select-selection" [class.ant-select-selection--single]="!isMultiple" [class.ant-select-selection--multiple]="isMultiple" tabindex="0"> <ng-container *ngIf="!isMultiple"> <div class="ant-select-selection__rendered"> <div *ngIf="nzPlaceHolder && selectedNodes.length === 0" [style.display]="placeHolderDisplay" class="ant-select-selection__placeholder"> {{ nzPlaceHolder }} </div> <div *ngIf="selectedNodes.length === 1" class="ant-select-selection-selected-value" [attr.title]="selectedNodes[0].title" [ngStyle]="selectedValueDisplay"> {{ selectedNodes[0].title }} </div> <div *ngIf="nzShowSearch" [style.display]="searchDisplay" class="ant-select-search ant-select-search--inline"> <div class="ant-select-search__field__wrap"> <ng-template [ngTemplateOutlet]="inputTemplate"></ng-template> <span class="ant-select-search__field__mirror">{{inputValue}}&nbsp;</span> </div> </div> </div> </ng-container> <ng-container *ngIf="isMultiple"> <ul class="ant-select-selection__rendered"> <div *ngIf="nzPlaceHolder && selectedNodes.length === 0" [style.display]="placeHolderDisplay" class="ant-select-selection__placeholder"> {{ nzPlaceHolder }} </div> <ng-container *ngFor="let node of selectedNodes"> <li [@selectTagAnimation] (@selectTagAnimation.done)="updatePosition()" [attr.title]="node.title" [class.ant-select-selection__choice__disabled]="node.isDisabled" class="ant-select-selection__choice"> <span *ngIf="!node.isDisabled" class="ant-select-selection__choice__remove" (click)="removeSelected(node)"></span> <span class="ant-select-selection__choice__content">{{ node.title }}</span> </li> </ng-container> <li class="ant-select-search ant-select-search--inline"> <ng-template [ngTemplateOutlet]="inputTemplate"></ng-template> </li> </ul> </ng-container> <span *ngIf="nzAllowClear" class="ant-select-selection__clear" (click)="onClearSelection()"></span> <span *ngIf="!isMultiple" class="ant-select-arrow"><b></b></span> </div>`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NzTreeSelectComponent),
                        multi: true
                    }
                ],
                host: {
                    '[class.ant-select]': 'true',
                    '[class.ant-select-lg]': 'nzSize==="large"',
                    '[class.ant-select-sm]': 'nzSize==="small"',
                    '[class.ant-select-enabled]': '!nzDisabled',
                    '[class.ant-select-disabled]': 'nzDisabled',
                    '[class.ant-select-allow-clear]': 'nzAllowClear',
                    '[class.ant-select-open]': 'nzOpen'
                },
                styles: [`
    .ant-select-dropdown {
      top: 100%;
      left: 0;
      position: relative;
      width: 100%;
      margin-top: 4px;
      margin-bottom: 4px;
      overflow: auto;
    }
  `]
            },] },
];
/** @nocollapse */
NzTreeSelectComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef, decorators: [{ type: Optional }] },
    { type: Renderer2 },
    { type: Overlay },
    { type: ViewContainerRef }
];
NzTreeSelectComponent.propDecorators = {
    nzOpen: [{ type: Input }],
    nzAllowClear: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzDropdownMatchSelectWidth: [{ type: Input }],
    nzPlaceHolder: [{ type: Input }],
    nzShowSearch: [{ type: Input }],
    nzDisabled: [{ type: Input }],
    nzDropdownStyle: [{ type: Input }],
    nzCheckable: [{ type: Input }],
    nzShowExpand: [{ type: Input }],
    nzShowLine: [{ type: Input }],
    nzAsyncData: [{ type: Input }],
    nzMultiple: [{ type: Input }],
    nzDefaultExpandAll: [{ type: Input }],
    nzDefaultExpandedKeys: [{ type: Input }],
    nzNodes: [{ type: Input }],
    nzOpenChange: [{ type: Output }],
    nzCleared: [{ type: Output }],
    nzRemoved: [{ type: Output }],
    nzExpandChange: [{ type: Output }],
    nzTreeClick: [{ type: Output }],
    nzTreeCheckBoxChange: [{ type: Output }],
    inputElement: [{ type: ViewChild, args: ['inputElement',] }],
    treeSelect: [{ type: ViewChild, args: ['treeSelect',] }],
    dropdownTemplate: [{ type: ViewChild, args: ['dropdownTemplate', { read: TemplateRef },] }],
    treeRef: [{ type: ViewChild, args: ['treeRef',] }],
    trigger: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzTreeSelectModule {
}
NzTreeSelectModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule, FormsModule, NzTreeModule],
                declarations: [NzTreeSelectComponent],
                exports: [NzTreeSelectComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzUploadBtnComponent {
    /**
     * @param {?} http
     * @param {?} el
     * @param {?} updateHostClassService
     * @param {?} cd
     */
    constructor(http$$1, el, updateHostClassService, cd) {
        this.http = http$$1;
        this.el = el;
        this.updateHostClassService = updateHostClassService;
        this.cd = cd;
        this.reqs = {};
        this.inited = false;
        this.destroy = false;
        // region: fields
        this.classes = {};
        this.prefixCls = 'ant-upload';
        if (!http$$1) {
            throw new Error(`Not found 'HttpClient', You can import 'HttpClientModel' in your root module.`);
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this.options.disabled) {
            return;
        }
        (/** @type {?} */ (this.file.nativeElement)).click();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onKeyDown(e) {
        if (this.options.disabled) {
            return;
        }
        if (e.key === 'Enter') {
            this.onClick();
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onFileDrop(e) {
        if (this.options.disabled || e.type === 'dragover') {
            e.preventDefault();
            return;
        }
        const /** @type {?} */ files = Array.prototype.slice.call(e.dataTransfer.files).filter((file) => this.attrAccept(file, this.options.accept));
        if (files.length) {
            this.uploadFiles(files);
        }
        e.preventDefault();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onChange(e) {
        if (this.options.disabled) {
            return;
        }
        const /** @type {?} */ hie = /** @type {?} */ (e.target);
        this.uploadFiles(hie.files);
        hie.value = '';
    }
    /**
     * @param {?} file
     * @param {?} acceptedFiles
     * @return {?}
     */
    attrAccept(file, acceptedFiles) {
        if (file && acceptedFiles) {
            const /** @type {?} */ acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(',');
            const /** @type {?} */ fileName = '' + file.name;
            const /** @type {?} */ mimeType = '' + file.type;
            const /** @type {?} */ baseMimeType = mimeType.replace(/\/.*$/, '');
            return acceptedFilesArray.some(type => {
                const /** @type {?} */ validType = type.trim();
                if (validType.charAt(0) === '.') {
                    return fileName.toLowerCase().indexOf(validType.toLowerCase(), fileName.toLowerCase().length - validType.toLowerCase().length) !== -1;
                }
                else if (/\/\*$/.test(validType)) {
                    // This is something like a image/* mime type
                    return baseMimeType === validType.replace(/\/.*$/, '');
                }
                return mimeType === validType;
            });
        }
        return true;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    attachUid(file) {
        if (!file.uid) {
            file.uid = Math.random().toString(36).substring(2);
        }
        return file;
    }
    /**
     * @param {?} fileList
     * @return {?}
     */
    uploadFiles(fileList) {
        let /** @type {?} */ postFiles = Array.prototype.slice.call(fileList);
        this.options.filters.forEach(f => postFiles = f.fn(postFiles));
        postFiles.forEach((file) => {
            this.attachUid(file);
            this.upload(file, postFiles);
        });
    }
    /**
     * @param {?} file
     * @param {?} fileList
     * @return {?}
     */
    upload(file, fileList) {
        if (!this.options.beforeUpload) {
            return this.post(file);
        }
        const /** @type {?} */ before = this.options.beforeUpload(file, fileList);
        if (before instanceof Observable) {
            before.subscribe((processedFile) => {
                const /** @type {?} */ processedFileType = Object.prototype.toString.call(processedFile);
                if (processedFileType === '[object File]' || processedFileType === '[object Blob]') {
                    this.attachUid(processedFile);
                    this.post(processedFile);
                }
                else {
                    this.post(file);
                }
            });
        }
        else if (before !== false) {
            return this.post(file);
        }
    }
    /**
     * @param {?} file
     * @return {?}
     */
    post(file) {
        if (this.destroy) {
            return;
        }
        const /** @type {?} */ opt = this.options;
        const { uid } = file;
        let { data, headers } = opt;
        if (typeof data === 'function') {
            data = data(file);
        }
        if (typeof headers === 'function') {
            headers = headers(file);
        }
        const /** @type {?} */ args = {
            action: opt.action,
            name: opt.name,
            headers,
            file,
            data,
            withCredentials: opt.withCredentials,
            onProgress: opt.onProgress ? e => {
                opt.onProgress(e, file);
            } : null,
            onSuccess: (ret, xhr) => {
                delete this.reqs[uid];
                opt.onSuccess(ret, file, xhr);
            },
            onError: (xhr) => {
                delete this.reqs[uid];
                opt.onError(xhr, file);
            }
        };
        this.reqs[uid] = (opt.customRequest || this.xhr).call(this, args);
        opt.onStart(file);
    }
    /**
     * @param {?} args
     * @return {?}
     */
    xhr(args) {
        const /** @type {?} */ formData = new FormData();
        // tslint:disable-next-line:no-any
        formData.append(args.name, /** @type {?} */ (args.file));
        if (args.data) {
            Object.keys(args.data).map(key => {
                formData.append(key, args.data[key]);
            });
        }
        if (!args.headers) {
            args.headers = {};
        }
        if (args.headers['X-Requested-With'] !== null) {
            args.headers['X-Requested-With'] = `XMLHttpRequest`;
        }
        else {
            delete args.headers['X-Requested-With'];
        }
        const /** @type {?} */ req = new HttpRequest('POST', args.action, formData, {
            reportProgress: true,
            withCredentials: args.withCredentials,
            headers: new HttpHeaders(args.headers)
        });
        return this.http.request(req).subscribe((event) => {
            if (event.type === HttpEventType.UploadProgress) {
                if (event.total > 0) {
                    // tslint:disable-next-line:no-any
                    (/** @type {?} */ (event)).percent = event.loaded / event.total * 100;
                }
                args.onProgress(event, args.file);
            }
            else if (event instanceof HttpResponse) {
                args.onSuccess(event.body, args.file, event);
            }
        }, (err) => {
            this.abort(args.file);
            args.onError(err, args.file);
        });
    }
    /**
     * @param {?=} file
     * @return {?}
     */
    abort(file) {
        if (file) {
            const /** @type {?} */ uid = file && file.uid;
            if (this.reqs[uid]) {
                this.reqs[uid].unsubscribe();
                delete this.reqs[uid];
            }
        }
        else {
            Object.keys(this.reqs).forEach((uid) => {
                this.reqs[uid].unsubscribe();
                delete this.reqs[uid];
            });
        }
    }
    /**
     * @return {?}
     */
    setClassMap() {
        const /** @type {?} */ classMap = Object.assign({ [this.prefixCls]: true, [`${this.prefixCls}-disabled`]: this.options.disabled }, this.classes);
        this.updateHostClassService.updateHostClass(this.el.nativeElement, classMap);
        this.cd.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.inited = true;
        this.setClassMap();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (this.inited) {
            this.setClassMap();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy = true;
        this.abort();
    }
}
NzUploadBtnComponent.decorators = [
    { type: Component, args: [{
                selector: '[nz-upload-btn]',
                template: `<input type="file" #file (change)="onChange($event)" [attr.accept]="options.accept" [multiple]="options.multiple" style="display: none;"> <ng-content></ng-content>`,
                host: {
                    '[attr.tabindex]': '"0"',
                    '[attr.role]': '"button"'
                },
                providers: [NzUpdateHostClassService],
                preserveWhitespaces: false
            },] },
];
/** @nocollapse */
NzUploadBtnComponent.ctorParameters = () => [
    { type: HttpClient, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: NzUpdateHostClassService },
    { type: ChangeDetectorRef }
];
NzUploadBtnComponent.propDecorators = {
    file: [{ type: ViewChild, args: ['file',] }],
    classes: [{ type: Input }],
    options: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onFileDrop: [{ type: HostListener, args: ['drop', ['$event'],] }, { type: HostListener, args: ['dragover', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzUploadListComponent {
    /**
     * @param {?} el
     * @param {?} updateHostClassService
     */
    constructor(el, updateHostClassService) {
        this.el = el;
        this.updateHostClassService = updateHostClassService;
        // region: fields
        // tslint:disable-next-line:no-any
        this.locale = {};
        this.prefixCls = 'ant-upload-list';
    }
    /**
     * @return {?}
     */
    setClassMap() {
        const /** @type {?} */ classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-${this.listType}`]: true
        };
        this.updateHostClassService.updateHostClass(this.el.nativeElement, classMap);
    }
    /**
     * @param {?} file
     * @param {?} e
     * @return {?}
     */
    handlePreview(file, e) {
        if (!this.onPreview) {
            return;
        }
        e.preventDefault();
        return this.onPreview(file);
    }
    /**
     * @param {?} file
     * @param {?} e
     * @return {?}
     */
    handleRemove(file, e) {
        e.preventDefault();
        if (this.onRemove) {
            this.onRemove(file);
        }
        return;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.setClassMap();
    }
}
NzUploadListComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-upload-list',
                template: `<div *ngFor="let file of items" class="ant-upload-list-item ant-upload-list-item-{{file.status}}" @itemState> <ng-template #icon> <ng-container *ngIf="listType === 'picture' || listType === 'picture-card'; else defIcon"> <ng-container *ngIf="file.status === 'uploading' || (!file.thumbUrl && !file.url); else thumbIcon"> <div *ngIf="listType === 'picture-card'" class="ant-upload-list-item-uploading-text">{{ locale.uploading }}</div> <i *ngIf="listType !== 'picture-card'" class="anticon anticon-picture ant-upload-list-item-thumbnail"></i> </ng-container> </ng-container> <ng-template #defIcon> <i class="anticon anticon-{{file.status === 'uploading' ? 'loading anticon-spin' : 'paper-clip'}}"></i> </ng-template> <ng-template #thumbIcon> <a class="ant-upload-list-item-thumbnail" target="_blank" rel="noopener noreferrer" [href]="file.thumbUrl || file.url" (click)="handlePreview(file, $event)"> <img [src]="file.thumbUrl || file.url" [attr.alt]="file.name" /> </a> </ng-template> </ng-template> <ng-template #preview> <ng-container *ngIf="file.url; else prevText"> <a [href]="file.thumbUrl || file.url" target="_blank" rel="noopener noreferrer" (click)="handlePreview(file, $event)" class="ant-upload-list-item-name" title="{{ file.name }}">{{ file.name }}</a> </ng-container> <ng-template #prevText> <span (click)="handlePreview(file, $event)" class="ant-upload-list-item-name" title="{{ file.name }}">{{ file.name }}</span> </ng-template> </ng-template> <div class="ant-upload-list-item-info"> <nz-tooltip *ngIf="file.status === 'error'" [nzTitle]="file.message"> <span nz-tooltip> <ng-template [ngTemplateOutlet]="icon"></ng-template> <ng-template [ngTemplateOutlet]="preview"></ng-template> </span> </nz-tooltip> <span *ngIf="file.status !== 'error'"> <ng-template [ngTemplateOutlet]="icon"></ng-template> <ng-template [ngTemplateOutlet]="preview"></ng-template> </span> </div> <ng-container *ngIf="listType === 'picture-card' && file.status !== 'uploading'; else cross"> <span class="ant-upload-list-item-actions"> <a *ngIf="icons.showPreviewIcon" [href]="file.thumbUrl || file.url" target="_blank" rel="noopener noreferrer" title="{{ locale.previewFile }}" [ngStyle]="!(file.url || file.thumbUrl) && {'opacity': .5, 'pointer-events': 'none'}" (click)="handlePreview(file, $event)"> <i class="anticon anticon-eye-o"></i> </a> <i *ngIf="icons.showRemoveIcon" (click)="handleRemove(file, $event)" class="anticon anticon-delete" title="{{ locale.removeFile }}"></i> </span> </ng-container> <ng-template #cross> <i *ngIf="icons.showRemoveIcon" (click)="handleRemove(file, $event)" class="anticon anticon-cross" title="{{ locale.removeFile }}"></i> </ng-template> <div *ngIf="file.status === 'uploading'" class="ant-upload-list-item-progress"> <nz-progress [nzPercent]="file.percent" [nzShowInfo]="false" [nzStrokeWidth]="2"></nz-progress> </div> </div>`,
                providers: [NzUpdateHostClassService],
                animations: [
                    trigger('itemState', [
                        transition(':enter', [
                            style({ height: '0', width: '0', opacity: 0 }),
                            animate(150, style({ height: '*', width: '*', opacity: 1 }))
                        ]),
                        transition(':leave', [
                            animate(150, style({ height: '0', width: '0', opacity: 0 }))
                        ])
                    ])
                ],
                preserveWhitespaces: false
            },] },
];
/** @nocollapse */
NzUploadListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NzUpdateHostClassService }
];
NzUploadListComponent.propDecorators = {
    locale: [{ type: Input }],
    listType: [{ type: Input }],
    items: [{ type: Input }],
    icons: [{ type: Input }],
    onPreview: [{ type: Input }],
    onRemove: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzUploadComponent {
    /**
     * @param {?} cd
     * @param {?} i18n
     */
    constructor(cd, i18n) {
        this.cd = cd;
        this.i18n = i18n;
        this.locale = {};
        this.inited = false;
        // region: fields
        this.nzType = 'select';
        this._limit = 0;
        this._size = 0;
        this.nzFilter = [];
        this.nzFileList = [];
        this.nzFileListChange = new EventEmitter();
        this._disabled = false;
        this.nzListType = 'text';
        this._multiple = false;
        this.nzName = 'file';
        this._showUploadList = true;
        this._showBtn = true;
        this._withCredentials = false;
        this.nzChange = new EventEmitter();
        this.onStart = (file) => {
            if (!this.nzFileList) {
                this.nzFileList = [];
            }
            const /** @type {?} */ targetItem = this.fileToObject(file);
            targetItem.status = 'uploading';
            this.nzFileList.push(targetItem);
            this.genThumb(targetItem);
            this.nzFileListChange.emit(this.nzFileList);
            this.nzChange.emit({ file: targetItem, fileList: this.nzFileList, type: 'start' });
            this.cd.detectChanges();
        };
        this.onProgress = (e, file) => {
            const /** @type {?} */ fileList = this.nzFileList;
            const /** @type {?} */ targetItem = this.getFileItem(file, fileList);
            targetItem.percent = e.percent;
            this.nzChange.emit({
                event: e,
                file: Object.assign({}, targetItem),
                fileList: this.nzFileList,
                type: 'progress'
            });
            this.cd.detectChanges();
        };
        this.onSuccess = (res, file, xhr) => {
            const /** @type {?} */ fileList = this.nzFileList;
            const /** @type {?} */ targetItem = this.getFileItem(file, fileList);
            targetItem.status = 'done';
            targetItem.response = res;
            this.nzChange.emit({
                file: Object.assign({}, targetItem),
                fileList,
                type: 'success'
            });
            this.cd.detectChanges();
        };
        this.onError = (err, file) => {
            const /** @type {?} */ fileList = this.nzFileList;
            const /** @type {?} */ targetItem = this.getFileItem(file, fileList);
            targetItem.error = err;
            targetItem.status = 'error';
            targetItem["message"] = this.genErr(targetItem);
            this.nzChange.emit({
                file: Object.assign({}, targetItem),
                fileList,
                type: 'error'
            });
            this.cd.detectChanges();
        };
        // endregion
        // region: list
        this.onRemove = (file) => {
            this.upload.abort(file);
            file.status = 'removed';
            (/** @type {?} */ ((this.nzRemove ? this.nzRemove instanceof Observable ? this.nzRemove : of(this.nzRemove(file)) : of(true))))
                .pipe(filter((res) => res))
                .subscribe(res => {
                this.nzFileList = this.removeFileItem(file, this.nzFileList);
                this.nzChange.emit({
                    file,
                    fileList: this.nzFileList,
                    type: 'removed'
                });
                this.nzFileListChange.emit(this.nzFileList);
                this.cd.detectChanges();
            });
        };
        // endregion
        // region: styles
        this.prefixCls = 'ant-upload';
        this.classList = [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzLimit(value) {
        this._limit = toNumber(value, null);
    }
    /**
     * @return {?}
     */
    get nzLimit() {
        return this._limit;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzSize(value) {
        this._size = toNumber(value, null);
    }
    /**
     * @return {?}
     */
    get nzSize() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzDisabled(value) {
        this._disabled = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzDisabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzMultiple(value) {
        this._multiple = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzMultiple() {
        return this._multiple;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowUploadList(value) {
        this._showUploadList = typeof value === 'boolean' ? toBoolean(value) : value;
    }
    /**
     * @return {?}
     */
    get nzShowUploadList() {
        return this._showUploadList;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzShowButton(value) {
        this._showBtn = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzShowButton() {
        return this._showBtn;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nzWithCredentials(value) {
        this._withCredentials = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get nzWithCredentials() {
        return this._withCredentials;
    }
    /**
     * @return {?}
     */
    zipOptions() {
        if (typeof this.nzShowUploadList === 'boolean' && this.nzShowUploadList) {
            this.nzShowUploadList = {
                showPreviewIcon: true,
                showRemoveIcon: true
            };
        }
        // filters
        const /** @type {?} */ filters = this.nzFilter.slice();
        if (this.nzMultiple && this.nzLimit > 0 && filters.findIndex(w => w.name === 'limit') === -1) {
            filters.push({
                name: 'limit',
                fn: (fileList) => fileList.slice(-this.nzLimit)
            });
        }
        if (this.nzSize > 0 && filters.findIndex(w => w.name === 'size') === -1) {
            filters.push({
                name: 'size',
                fn: (fileList) => fileList.filter(w => (w.size / 1024) <= this.nzSize)
            });
        }
        if (this.nzFileType && this.nzFileType.length > 0 && filters.findIndex(w => w.name === 'type') === -1) {
            const /** @type {?} */ types = this.nzFileType.split(',');
            filters.push({
                name: 'type',
                fn: (fileList) => fileList.filter(w => ~types.indexOf(w.type))
            });
        }
        this._btnOptions = {
            disabled: this.nzDisabled,
            accept: this.nzAccept,
            action: this.nzAction,
            beforeUpload: this.nzBeforeUpload,
            customRequest: this.nzCustomRequest,
            data: this.nzData,
            headers: this.nzHeaders,
            name: this.nzName,
            multiple: this.nzMultiple,
            withCredentials: this.nzWithCredentials,
            filters,
            onStart: this.onStart,
            onProgress: this.onProgress,
            onSuccess: this.onSuccess,
            onError: this.onError
        };
        return this;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    fileToObject(file) {
        return {
            lastModified: file.lastModified,
            lastModifiedDate: file.lastModifiedDate,
            name: file.filename || file.name,
            size: file.size,
            type: file.type,
            uid: file.uid,
            response: file.response,
            error: file.error,
            percent: 0,
            // tslint:disable-next-line:no-angle-bracket-type-assertion
            originFileObj: /** @type {?} */ (file)
        };
    }
    /**
     * @param {?} file
     * @param {?} fileList
     * @return {?}
     */
    getFileItem(file, fileList) {
        return fileList.filter(item => item.uid === file.uid)[0];
    }
    /**
     * @param {?} file
     * @param {?} fileList
     * @return {?}
     */
    removeFileItem(file, fileList) {
        return fileList.filter(item => item.uid !== file.uid);
    }
    /**
     * @param {?} file
     * @return {?}
     */
    genErr(file) {
        return file.response && typeof file.response === 'string' ?
            file.response :
            (file.error && file.error.statusText) || this.locale.uploadError;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    genThumb(file) {
        if (typeof document === 'undefined' ||
            typeof window === 'undefined' ||
            !(/** @type {?} */ (window)).FileReader || !(/** @type {?} */ (window)).File ||
            !(file.originFileObj instanceof File) ||
            file.thumbUrl !== undefined) {
            return;
        }
        file.thumbUrl = '';
        const /** @type {?} */ reader = new FileReader();
        reader.onloadend = () => file.thumbUrl = reader.result;
        reader.readAsDataURL(file.originFileObj);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    fileDrop(e) {
        if (e.type === this.dragState) {
            return;
        }
        this.dragState = e.type;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    setClassMap() {
        let /** @type {?} */ subCls = [];
        if (this.nzType === 'drag') {
            subCls = [
                this.nzFileList.some(file => file.status === 'uploading') && `${this.prefixCls}-drag-uploading`,
                this.dragState === 'dragover' && `${this.prefixCls}-drag-hover`
            ];
        }
        else {
            subCls = [
                `${this.prefixCls}-select-${this.nzListType}`
            ];
        }
        this.classList = [
            this.prefixCls,
            `${this.prefixCls}-${this.nzType}`,
            ...subCls,
            this.nzDisabled && `${this.prefixCls}-disabled`
        ].filter(item => !!item);
        this.cd.detectChanges();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.inited = true;
        this.i18n$ = this.i18n.localeChange.subscribe(() => {
            this.locale = this.i18n.getLocaleData('Upload');
            this.cd.detectChanges();
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.nzFileList) {
            (this.nzFileList || []).forEach(file => file["message"] = this.genErr(file));
        }
        this.zipOptions().setClassMap();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.i18n$.unsubscribe();
    }
}
NzUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'nz-upload',
                template: `<ng-template #list> <nz-upload-list *ngIf="nzShowUploadList" [locale]="locale" [listType]="nzListType" [items]="nzFileList" [icons]="nzShowUploadList" [onPreview]="nzPreview" [onRemove]="onRemove"></nz-upload-list> </ng-template> <ng-template #con><ng-content></ng-content></ng-template> <ng-template #btn> <div [ngClass]="classList" [style.display]="nzShowButton ? '' : 'none'"> <div nz-upload-btn #upload [options]="_btnOptions"> <ng-template [ngTemplateOutlet]="con"></ng-template> </div> </div> </ng-template> <ng-container *ngIf="nzType === 'drag'; else select"> <div [ngClass]="classList" (drop)="fileDrop($event)" (dragover)="fileDrop($event)" (dragleave)="fileDrop($event)"> <div nz-upload-btn #upload [options]="_btnOptions" [classes]="{'ant-upload-btn': true}"> <div class="ant-upload-drag-container"> <ng-template [ngTemplateOutlet]="con"></ng-template> </div> </div> </div> <ng-template [ngTemplateOutlet]="list"></ng-template> </ng-container> <ng-template #select> <ng-container *ngIf="nzListType === 'picture-card'; else pic"> <ng-template [ngTemplateOutlet]="list"></ng-template> <ng-template [ngTemplateOutlet]="btn"></ng-template> </ng-container> </ng-template> <ng-template #pic> <ng-template [ngTemplateOutlet]="btn"></ng-template> <ng-template [ngTemplateOutlet]="list"></ng-template> </ng-template>`,
                preserveWhitespaces: false,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
NzUploadComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NzI18nService }
];
NzUploadComponent.propDecorators = {
    upload: [{ type: ViewChild, args: ['upload',] }],
    nzType: [{ type: Input }],
    nzLimit: [{ type: Input }],
    nzSize: [{ type: Input }],
    nzFileType: [{ type: Input }],
    nzAccept: [{ type: Input }],
    nzAction: [{ type: Input }],
    nzBeforeUpload: [{ type: Input }],
    nzCustomRequest: [{ type: Input }],
    nzData: [{ type: Input }],
    nzFilter: [{ type: Input }],
    nzFileList: [{ type: Input }],
    nzFileListChange: [{ type: Output }],
    nzDisabled: [{ type: Input }],
    nzHeaders: [{ type: Input }],
    nzListType: [{ type: Input }],
    nzMultiple: [{ type: Input }],
    nzName: [{ type: Input }],
    nzShowUploadList: [{ type: Input }],
    nzShowButton: [{ type: Input }],
    nzWithCredentials: [{ type: Input }],
    nzRemove: [{ type: Input }],
    nzPreview: [{ type: Input }],
    nzChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzUploadModule {
}
NzUploadModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, NzToolTipModule, NzProgressModule, NzI18nModule],
                declarations: [NzUploadComponent, NzUploadBtnComponent, NzUploadListComponent],
                exports: [NzUploadComponent]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NzDropdownService {
    /**
     * @param {?} overlay
     * @param {?} document
     * @param {?} zone
     */
    constructor(overlay, document, zone) {
        this.overlay = overlay;
        this.document = document;
        this.zone = zone;
        this.positions = [
            new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'top' }),
            new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),
            new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'bottom' }),
            new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
        ];
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    createOverlay($event) {
        this.createPoint($event);
        const /** @type {?} */ fakeElementRef = new ElementRef(this.locatePoint);
        this.positionStrategy = this.overlay.position().flexibleConnectedTo(fakeElementRef);
        this.handlePositionChanges(this.positionStrategy);
        const /** @type {?} */ overlayConfig = new OverlayConfig({
            hasBackdrop: true,
            scrollStrategy: this.overlay.scrollStrategies.close(),
            positionStrategy: this.positionStrategy
        });
        return this.overlay.create(overlayConfig);
    }
    /**
     * @param {?} strategy
     * @return {?}
     */
    handlePositionChanges(strategy) {
        strategy.withPositions(this.positions);
        this.onPositionChangeSubscription = this.positionStrategy.positionChanges.subscribe(data => {
            const /** @type {?} */ position = data.connectionPair.overlayY === 'bottom' ? 'top' : 'bottom';
            this.instance.setDropDownPosition(position);
        });
    }
    /**
     * @param {?} overlayRef
     * @return {?}
     */
    handleCloseEvent(overlayRef) {
        this.backdropClickSubscription = overlayRef.backdropClick().subscribe(_ => this.instance.close());
        this.detachmentsSubscription = overlayRef.detachments().subscribe(_ => this.close());
    }
    /**
     * @param {?} e
     * @return {?}
     */
    createPoint(e) {
        if (!this.locatePoint) {
            const /** @type {?} */ container = this.document.createElement('span');
            this.document.body.appendChild(container);
            this.locatePoint = container;
        }
        this.locatePoint.style.position = `fixed`;
        this.locatePoint.style.top = `${e.clientY}px`;
        this.locatePoint.style.left = `${e.clientX}px`;
    }
    /**
     * @return {?}
     */
    removePoint() {
        if (this.locatePoint) {
            this.document.body.removeChild(this.locatePoint);
            this.locatePoint = null;
        }
    }
    /**
     * @param {?} instance
     * @param {?} template
     * @return {?}
     */
    setInstanceValue(instance, template) {
        instance.open = true;
        instance.setTemplateRef(template);
        instance.setControl(this);
    }
    /**
     * @param {?} $event
     * @param {?} template
     * @return {?}
     */
    create($event, template) {
        $event.preventDefault();
        if (this.overlayRef && this.overlayRef.hasAttached()) {
            this.overlayRef.dispose();
        }
        else {
            this.overlayRef = this.createOverlay($event);
            setTimeout(() => {
                if (this.overlayRef.backdropElement) {
                    this.zone.runOutsideAngular(() => {
                        this.overlayRef.backdropElement.addEventListener('contextmenu', (e) => e.preventDefault());
                    });
                }
            });
            this.instance = this.overlayRef.attach(new ComponentPortal(NzDropdownContextComponent)).instance;
            this.setInstanceValue(this.instance, template);
            this.handleCloseEvent(this.overlayRef);
            return this.instance;
        }
    }
    /**
     * @return {?}
     */
    close() {
        this.removePoint();
        this.overlayRef.dispose();
        if (this.backdropClickSubscription) {
            this.backdropClickSubscription.unsubscribe();
            this.backdropClickSubscription = null;
        }
        if (this.detachmentsSubscription) {
            this.detachmentsSubscription.unsubscribe();
            this.detachmentsSubscription = null;
        }
        if (this.onPositionChangeSubscription) {
            this.onPositionChangeSubscription.unsubscribe();
            this.onPositionChangeSubscription = null;
        }
    }
}
NzDropdownService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
];
/** @nocollapse */
NzDropdownService.ctorParameters = () => [
    { type: Overlay },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone }
];
/** @nocollapse */ NzDropdownService.ngInjectableDef = defineInjectable({ factory: function NzDropdownService_Factory() { return new NzDropdownService(inject(Overlay), inject(DOCUMENT), inject(NgZone)); }, token: NzDropdownService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$1 = {
    today: 'اليوم',
    now: 'الأن',
    backToToday: 'العودة إلى اليوم',
    ok: 'تأكيد',
    clear: 'مسح',
    month: 'الشهر',
    year: 'السنة',
    timeSelect: 'اختيار الوقت',
    dateSelect: 'اختيار التاريخ',
    monthSelect: 'اختيار الشهر',
    yearSelect: 'اختيار السنة',
    decadeSelect: 'اختيار العقد',
    yearFormat: 'YYYY',
    dateFormat: 'M/D/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'M/D/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'الشهر السابق (PageUp)',
    nextMonth: 'الشهر التالى(PageDown)',
    previousYear: 'العام السابق (Control + left)',
    nextYear: 'العام التالى (Control + right)',
    previousDecade: 'العقد السابق',
    nextDecade: 'العقد التالى',
    previousCentury: 'القرن السابق',
    nextCentury: 'القرن التالى',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$3 = {
    placeholder: 'اختيار الوقت',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$2 = {
    lang: Object.assign({ placeholder: 'اختيار التاريخ', rangePlaceholder: ['البداية', 'النهاية'] }, CalendarLocale$1),
    timePickerLocale: Object.assign({}, locale$3),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$1 = {
    // Options.jsx
    items_per_page: '/ الصفحة',
    jump_to: 'الذهاب إلى',
    jump_to_confirm: 'تأكيد',
    page: '',
    // Pagination.jsx
    prev_page: 'الصفحة السابقة',
    next_page: 'الصفحة التالية',
    prev_5: 'خمس صفحات سابقة',
    next_5: 'خمس صفحات تالية',
    prev_3: 'ثلاث صفحات سابقة',
    next_3: 'ثلاث صفحات تالية',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ar_EG = {
    locale: 'ar',
    Pagination: Pagination$1,
    DatePicker: locale$2,
    TimePicker: locale$3,
    Calendar: CalendarLocale$1,
    Table: {
        filterTitle: 'الفلاتر',
        filterConfirm: 'تأكيد',
        filterReset: 'إعادة ضبط',
        emptyText: 'لا توجد بيانات',
        selectAll: 'اختيار الكل',
        selectInvert: 'إلغاء الاختيار',
    },
    Modal: {
        okText: 'تأكيد',
        cancelText: 'إلغاء',
        justOkText: 'تأكيد',
    },
    Popconfirm: {
        okText: 'تأكيد',
        cancelText: 'إلغاء',
    },
    Transfer: {
        notFoundContent: 'لا يوجد محتوى',
        searchPlaceholder: 'ابحث هنا',
        itemUnit: 'عنصر',
        itemsUnit: 'عناصر',
    },
    Select: {
        notFoundContent: 'لايوجد محتوى',
    },
    Upload: {
        uploading: 'جاري الرفع...',
        removeFile: 'احذف الملف',
        uploadError: 'مشكلة فى الرفع',
        previewFile: 'استعرض الملف',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$2 = {
    today: 'Днес',
    now: 'Сега',
    backToToday: 'Към днес',
    ok: 'Добре',
    clear: 'Изчистване',
    month: 'Месец',
    year: 'Година',
    timeSelect: 'Избор на час',
    dateSelect: 'Избор на дата',
    monthSelect: 'Избор на месец',
    yearSelect: 'Избор на година',
    decadeSelect: 'Десетилетие',
    yearFormat: 'YYYY',
    dateFormat: 'D M YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D M YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Предишен месец (PageUp)',
    nextMonth: 'Следващ месец (PageDown)',
    previousYear: 'Последна година (Control + left)',
    nextYear: 'Следваща година (Control + right)',
    previousDecade: 'Предишно десетилетие',
    nextDecade: 'Следващо десетилетие',
    previousCentury: 'Последен век',
    nextCentury: 'Следващ век',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$5 = {
    placeholder: 'Избор на час',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$4 = {
    lang: Object.assign({ placeholder: 'Избор на дата', rangePlaceholder: ['Начална', 'Крайна'] }, CalendarLocale$2),
    timePickerLocale: Object.assign({}, locale$5),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$2 = {
    // Options.jsx
    items_per_page: '/ страница',
    jump_to: 'Към',
    jump_to_confirm: 'потвърждавам',
    page: '',
    // Pagination.jsx
    prev_page: 'Предишна страница',
    next_page: 'Следваща страница',
    prev_5: 'Предишни 5 страници',
    next_5: 'Следващи 5 страници',
    prev_3: 'Предишни 3 страници',
    next_3: 'Следващи 3 страници',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var bg_BG = {
    locale: 'bg',
    Pagination: Pagination$2,
    DatePicker: locale$4,
    TimePicker: locale$5,
    Calendar: CalendarLocale$2,
    Table: {
        filterTitle: 'Филтриране',
        filterConfirm: 'Добре',
        filterReset: 'Нулриане',
        emptyText: 'Няма данни',
        selectAll: 'Избор на текуща страница',
        selectInvert: 'Обръщане',
    },
    Modal: {
        okText: 'Добре',
        cancelText: 'Отказ',
        justOkText: 'Добре',
    },
    Popconfirm: {
        okText: 'Добре',
        cancelText: 'Отказ',
    },
    Transfer: {
        notFoundContent: 'Няма намерени',
        searchPlaceholder: 'Търсене',
        itemUnit: 'избор',
        itemsUnit: 'избори',
    },
    Select: {
        notFoundContent: 'Няма намерени',
    },
    Upload: {
        uploading: 'Качване...',
        removeFile: 'Премахване',
        uploadError: 'Грешка при качването',
        previewFile: 'Преглед',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$3 = {
    today: 'Avui',
    now: 'Ara',
    backToToday: 'Tornar a avui',
    ok: 'Acceptar',
    clear: 'Netejar',
    month: 'Mes',
    year: 'Any',
    timeSelect: 'Seleccionar hora',
    dateSelect: 'Seleccionar data',
    monthSelect: 'Escollir un mes',
    yearSelect: 'Escollir un any',
    decadeSelect: 'Escollir una dècada',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Mes anterior (PageUp)',
    nextMonth: 'Mes següent (PageDown)',
    previousYear: 'Any anterior (Control + left)',
    nextYear: 'Mes següent (Control + right)',
    previousDecade: 'Dècada anterior',
    nextDecade: 'Dècada següent',
    previousCentury: 'Segle anterior',
    nextCentury: 'Segle següent',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$7 = {
    placeholder: 'Seleccionar hora',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$6 = {
    lang: Object.assign({ placeholder: 'Seleccionar data', rangePlaceholder: ['Data inicial', 'Data final'] }, CalendarLocale$3),
    timePickerLocale: Object.assign({}, locale$7),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$3 = {
    // Options.jsx
    items_per_page: '/ pàgina',
    jump_to: 'Anar a',
    jump_to_confirm: 'Confirma',
    page: '',
    // Pagination.jsx
    prev_page: 'Pàgina prèvia',
    next_page: 'Pàgina següent',
    prev_5: '5 pàgines prèvies',
    next_5: '5 pàgines següents',
    prev_3: '3 pàgines prèvies',
    next_3: '3 pàgines següents',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ca_ES = {
    locale: 'ca',
    Pagination: Pagination$3,
    DatePicker: locale$6,
    TimePicker: locale$7,
    Calendar: CalendarLocale$3,
    Table: {
        filterTitle: 'Filtrar Menu',
        filterConfirm: 'OK',
        filterReset: 'Restablir',
        emptyText: 'Sense dades',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Cancel·lar',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Cancel·lar',
    },
    Transfer: {
        notFoundContent: 'No trobat',
        searchPlaceholder: 'Cercar aquí',
        itemUnit: 'item',
        itemsUnit: 'items',
    },
    Select: {
        notFoundContent: 'No trobat',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$4 = {
    today: 'Dnes',
    now: 'Nyní',
    backToToday: 'Zpět na dnešek',
    ok: 'Ok',
    clear: 'Vymazat',
    month: 'Měsíc',
    year: 'Rok',
    timeSelect: 'Vybrat čas',
    dateSelect: 'Vybrat datum',
    monthSelect: 'Vyberte měsíc',
    yearSelect: 'Vyberte rok',
    decadeSelect: 'Vyberte dekádu',
    yearFormat: 'YYYY',
    dateFormat: 'D.M.YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D.M.YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Předchozí měsíc (PageUp)',
    nextMonth: 'Následující (PageDown)',
    previousYear: 'Předchozí rok (Control + left)',
    nextYear: 'Následující rok (Control + right)',
    previousDecade: 'Předchozí dekáda',
    nextDecade: 'Následující dekáda',
    previousCentury: 'Předchozí století',
    nextCentury: 'Následující století',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$9 = {
    placeholder: 'Vybrat čas',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$8 = {
    lang: Object.assign({ placeholder: 'Vybrat datum', rangePlaceholder: ['Od', 'Do'] }, CalendarLocale$4),
    timePickerLocale: Object.assign({}, locale$9),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$4 = {
    // Options.jsx
    items_per_page: '/ strana',
    jump_to: 'Přejít',
    jump_to_confirm: 'potvrdit',
    page: '',
    // Pagination.jsx
    prev_page: 'Předchozí strana',
    next_page: 'Následující strana',
    prev_5: 'Předchozích 5 stran',
    next_5: 'Následujících 5 stran',
    prev_3: 'Předchozí 3 strany',
    next_3: 'Následující 3 strany',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var cs_CZ = {
    locale: 'cs',
    Pagination: Pagination$4,
    DatePicker: locale$8,
    TimePicker: locale$9,
    Calendar: CalendarLocale$4,
    Table: {
        filterTitle: 'Filtr',
        filterConfirm: 'Potvrdit',
        filterReset: 'Obnovit',
        emptyText: 'Žádná data',
    },
    Modal: {
        okText: 'Ok',
        cancelText: 'Storno',
        justOkText: 'Ok',
    },
    Popconfirm: {
        okText: 'Ok',
        cancelText: 'Storno',
    },
    Transfer: {
        notFoundContent: 'Nenalezeno',
        searchPlaceholder: 'Vyhledávání',
        itemUnit: 'položka',
        itemsUnit: 'položek',
    },
    Select: {
        notFoundContent: 'Nenalezeno',
    },
    Upload: {
        uploading: 'Nahrávání...',
        removeFile: 'Odstranit soubor',
        uploadError: 'Chyba při nahrávání',
        previewFile: 'Zobrazit soubor',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$5 = {
    today: 'Heute',
    now: 'Jetzt',
    backToToday: 'Zurück zu Heute',
    ok: 'OK',
    clear: 'Zurücksetzen',
    month: 'Monat',
    year: 'Jahr',
    timeSelect: 'Zeit wählen',
    dateSelect: 'Datum wählen',
    monthSelect: 'Wähle einen Monat',
    yearSelect: 'Wähle ein Jahr',
    decadeSelect: 'Wähle ein Jahrzehnt',
    yearFormat: 'YYYY',
    dateFormat: 'D.M.YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D.M.YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Vorheriger Monat (PageUp)',
    nextMonth: 'Nächster Monat (PageDown)',
    previousYear: 'Vorheriges Jahr (Ctrl + left)',
    nextYear: 'Nächstes Jahr (Ctrl + right)',
    previousDecade: 'Vorheriges Jahrzehnt',
    nextDecade: 'Nächstes Jahrzehnt',
    previousCentury: 'Vorheriges Jahrhundert',
    nextCentury: 'Nächstes Jahrhundert',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$11 = {
    placeholder: 'Zeit auswählen',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$10 = {
    lang: Object.assign({ placeholder: 'Datum auswählen', rangePlaceholder: ['Startdatum', 'Enddatum'] }, CalendarLocale$5),
    timePickerLocale: Object.assign({}, locale$11),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$5 = {
    // Options.jsx
    items_per_page: '/ Seite',
    jump_to: 'Gehe zu',
    jump_to_confirm: 'bestätigen',
    page: '',
    // Pagination.jsx
    prev_page: 'Vorherige Seite',
    next_page: 'Nächste Seite',
    prev_5: '5 Seiten zurück',
    next_5: '5 Seiten vor',
    prev_3: '3 Seiten zurück',
    next_3: '3 Seiten vor',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var de_DE = {
    locale: 'de',
    Pagination: Pagination$5,
    DatePicker: locale$10,
    TimePicker: locale$11,
    Calendar: CalendarLocale$5,
    Table: {
        filterTitle: 'Filter-Menü',
        filterConfirm: 'OK',
        filterReset: 'Zurücksetzen',
        emptyText: 'Keine Daten',
        selectAll: 'Selektiere Alle',
        selectInvert: 'Selektion Invertieren',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Abbrechen',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Abbrechen',
    },
    Transfer: {
        notFoundContent: 'Nicht gefunden',
        searchPlaceholder: 'Suchen',
        itemUnit: 'Eintrag',
        itemsUnit: 'Einträge',
    },
    Select: {
        notFoundContent: 'Nicht gefunden',
    },
    Upload: {
        uploading: 'Hochladen...',
        removeFile: 'Datei entfernen',
        uploadError: 'Fehler beim Hochladen',
        previewFile: 'Dateivorschau',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$6 = {
    today: 'Σήμερα',
    now: 'Τώρα',
    backToToday: 'Πίσω στη σημερινή μέρα',
    ok: 'Ok',
    clear: 'Καθαρισμός',
    month: 'Μήνας',
    year: 'Έτος',
    timeSelect: 'Επιλογή ώρας',
    dateSelect: 'Επιλογή ημερομηνίας',
    monthSelect: 'Επιλογή μήνα',
    yearSelect: 'Επιλογή έτους',
    decadeSelect: 'Επιλογή δεκαετίας',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Προηγούμενος μήνας (PageUp)',
    nextMonth: 'Επόμενος μήνας (PageDown)',
    previousYear: 'Προηγούμενο έτος (Control + αριστερά)',
    nextYear: 'Επόμενο έτος (Control + δεξιά)',
    previousDecade: 'Προηγούμενη δεκαετία',
    nextDecade: 'Επόμενη δεκαετία',
    previousCentury: 'Προηγούμενος αιώνας',
    nextCentury: 'Επόμενος αιώνας',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$13 = {
    placeholder: 'Επιλέξτε ώρα',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$12 = {
    lang: Object.assign({ placeholder: 'Επιλέξτε ημερομηνία', rangePlaceholder: ['Αρχική ημερομηνία', 'Τελική ημερομηνία'] }, CalendarLocale$6),
    timePickerLocale: Object.assign({}, locale$13),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$6 = {
    // Options.jsx
    items_per_page: '/ σελίδα',
    jump_to: 'Μετάβαση',
    jump_to_confirm: 'επιβεβαιώνω',
    page: '',
    // Pagination.jsx
    prev_page: 'Προηγούμενη Σελίδα',
    next_page: 'Επόμενη Σελίδα',
    prev_5: 'Προηγούμενες 5 Σελίδες',
    next_5: 'Επόμενες 5 σελίδες',
    prev_3: 'Προηγούμενες 3 Σελίδες',
    next_3: 'Επόμενες 3 Σελίδες',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var el_GR = {
    locale: 'el',
    Pagination: Pagination$6,
    DatePicker: locale$12,
    TimePicker: locale$13,
    Calendar: CalendarLocale$6,
    Table: {
        filterTitle: 'Μενού φίλτρων',
        filterConfirm: 'ΟΚ',
        filterReset: 'Επαναφορά',
        emptyText: 'Δεν υπάρχουν δεδομένα',
        selectAll: 'Επιλογή τρέχουσας σελίδας',
        selectInvert: 'Αντιστροφή τρέχουσας σελίδας',
    },
    Modal: {
        okText: 'ΟΚ',
        cancelText: 'Άκυρο',
        justOkText: 'ΟΚ',
    },
    Popconfirm: {
        okText: 'ΟΚ',
        cancelText: 'Άκυρο',
    },
    Transfer: {
        notFoundContent: 'Δεν βρέθηκε',
        searchPlaceholder: 'Αναζήτηση',
        itemUnit: 'αντικείμενο',
        itemsUnit: 'αντικείμενα',
    },
    Select: {
        notFoundContent: 'Δεν βρέθηκε',
    },
    Upload: {
        uploading: 'Μεταφόρτωση...',
        removeFile: 'Αφαίρεση αρχείου',
        uploadError: 'Σφάλμα μεταφόρτωσης',
        previewFile: 'Προεπισκόπηση αρχείου',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$7 = {
    today: 'Today',
    now: 'Now',
    backToToday: 'Back to today',
    ok: 'Ok',
    clear: 'Clear',
    month: 'Month',
    year: 'Year',
    timeSelect: 'Select time',
    dateSelect: 'Select date',
    monthSelect: 'Choose a month',
    yearSelect: 'Choose a year',
    decadeSelect: 'Choose a decade',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Previous month (PageUp)',
    nextMonth: 'Next month (PageDown)',
    previousYear: 'Last year (Control + left)',
    nextYear: 'Next year (Control + right)',
    previousDecade: 'Last decade',
    nextDecade: 'Next decade',
    previousCentury: 'Last century',
    nextCentury: 'Next century',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$15 = {
    placeholder: 'Select time',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$14 = {
    lang: Object.assign({ placeholder: 'Select date', rangePlaceholder: ['Start date', 'End date'] }, CalendarLocale$7),
    timePickerLocale: Object.assign({}, locale$15),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$7 = {
    // Options.jsx
    items_per_page: '/ page',
    jump_to: 'Goto',
    jump_to_confirm: 'confirm',
    page: '',
    // Pagination.jsx
    prev_page: 'Previous Page',
    next_page: 'Next Page',
    prev_5: 'Previous 5 Pages',
    next_5: 'Next 5 Pages',
    prev_3: 'Previous 3 Pages',
    next_3: 'Next 3 Pages',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var en_GB = {
    locale: 'en-gb',
    Pagination: Pagination$7,
    DatePicker: locale$14,
    TimePicker: locale$15,
    Calendar: CalendarLocale$7,
    Table: {
        filterTitle: 'Filter menu',
        filterConfirm: 'OK',
        filterReset: 'Reset',
        emptyText: 'No data',
        selectAll: 'Select current page',
        selectInvert: 'Invert current page',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Cancel',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Cancel',
    },
    Transfer: {
        notFoundContent: 'Not Found',
        searchPlaceholder: 'Search here',
        itemUnit: 'item',
        itemsUnit: 'items',
    },
    Select: {
        notFoundContent: 'Not Found',
    },
    Upload: {
        uploading: 'Uploading...',
        removeFile: 'Remove file',
        uploadError: 'Upload error',
        previewFile: 'Preview file',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$8 = {
    today: 'Today',
    now: 'Now',
    backToToday: 'Back to today',
    ok: 'Ok',
    clear: 'Clear',
    month: 'Month',
    year: 'Year',
    timeSelect: 'Select time',
    dateSelect: 'Select date',
    monthSelect: 'Choose a month',
    yearSelect: 'Choose a year',
    decadeSelect: 'Choose a decade',
    yearFormat: 'YYYY',
    dateFormat: 'M/D/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'M/D/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Previous month (PageUp)',
    nextMonth: 'Next month (PageDown)',
    previousYear: 'Last year (Control + left)',
    nextYear: 'Next year (Control + right)',
    previousDecade: 'Last decade',
    nextDecade: 'Next decade',
    previousCentury: 'Last century',
    nextCentury: 'Next century',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$17 = {
    placeholder: 'Select time',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$16 = {
    lang: Object.assign({ placeholder: 'Select date', rangePlaceholder: ['Start date', 'End date'] }, CalendarLocale$8),
    timePickerLocale: Object.assign({}, locale$17),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$8 = {
    // Options.jsx
    items_per_page: '/ page',
    jump_to: 'Goto',
    jump_to_confirm: 'confirm',
    page: '',
    // Pagination.jsx
    prev_page: 'Previous Page',
    next_page: 'Next Page',
    prev_5: 'Previous 5 Pages',
    next_5: 'Next 5 Pages',
    prev_3: 'Previous 3 Pages',
    next_3: 'Next 3 Pages',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var en_US = {
    locale: 'en',
    Pagination: Pagination$8,
    DatePicker: locale$16,
    TimePicker: locale$17,
    Calendar: CalendarLocale$8,
    Table: {
        filterTitle: 'Filter menu',
        filterConfirm: 'OK',
        filterReset: 'Reset',
        emptyText: 'No data',
        selectAll: 'Select current page',
        selectInvert: 'Invert current page',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Cancel',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Cancel',
    },
    Transfer: {
        titles: ['', ''],
        notFoundContent: 'Not Found',
        searchPlaceholder: 'Search here',
        itemUnit: 'item',
        itemsUnit: 'items',
    },
    Select: {
        notFoundContent: 'Not Found',
    },
    Upload: {
        uploading: 'Uploading...',
        removeFile: 'Remove file',
        uploadError: 'Upload error',
        previewFile: 'Preview file',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$9 = {
    today: 'Hoy',
    now: 'Ahora',
    backToToday: 'Volver a hoy',
    ok: 'Aceptar',
    clear: 'Limpiar',
    month: 'Mes',
    year: 'Año',
    timeSelect: 'Seleccionar hora',
    dateSelect: 'Seleccionar fecha',
    monthSelect: 'Elegir un mes',
    yearSelect: 'Elegir un año',
    decadeSelect: 'Elegir una década',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Mes anterior (PageUp)',
    nextMonth: 'Mes siguiente (PageDown)',
    previousYear: 'Año anterior (Control + left)',
    nextYear: 'Año siguiente (Control + right)',
    previousDecade: 'Década anterior',
    nextDecade: 'Década siguiente',
    previousCentury: 'Siglo anterior',
    nextCentury: 'Siglo siguiente',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$19 = {
    placeholder: 'Seleccionar hora',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$18 = {
    lang: Object.assign({ placeholder: 'Seleccionar fecha', rangePlaceholder: ['Fecha inicial', 'Fecha final'] }, CalendarLocale$9),
    timePickerLocale: Object.assign({}, locale$19),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$9 = {
    // Options.jsx
    items_per_page: '/ página',
    jump_to: 'Ir a',
    jump_to_confirm: 'confirmar',
    page: '',
    // Pagination.jsx
    prev_page: 'Página anterior',
    next_page: 'Página siguiente',
    prev_5: '5 páginas previas',
    next_5: '5 páginas siguientes',
    prev_3: '3 páginas previas',
    next_3: '3 páginas siguientes',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var es_ES = {
    locale: 'es',
    Pagination: Pagination$9,
    DatePicker: locale$18,
    TimePicker: locale$19,
    Calendar: CalendarLocale$9,
    Table: {
        filterTitle: 'Filtrar menú',
        filterConfirm: 'Aceptar',
        filterReset: 'Reiniciar',
        emptyText: 'No hay datos',
        selectAll: 'Seleccionar todo',
        selectInvert: 'Invertir selección',
    },
    Modal: {
        okText: 'Aceptar',
        cancelText: 'Cancelar',
        justOkText: 'Aceptar',
    },
    Popconfirm: {
        okText: 'Aceptar',
        cancelText: 'Cancelar',
    },
    Transfer: {
        notFoundContent: 'No encontrado',
        searchPlaceholder: 'Buscar aquí',
        itemUnit: 'elemento',
        itemsUnit: 'elementos',
    },
    Select: {
        notFoundContent: 'No encontrado',
    },
    Upload: {
        uploading: 'Subiendo...',
        removeFile: 'Eliminar archivo',
        uploadError: 'Error al subir el archivo',
        previewFile: 'Vista previa',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$10 = {
    today: 'Täna',
    now: 'Praegu',
    backToToday: 'Tagasi tänase juurde',
    ok: 'Ok',
    clear: 'Tühista',
    month: 'Kuu',
    year: 'Aasta',
    timeSelect: 'Vali aeg',
    dateSelect: 'Vali kuupäev',
    monthSelect: 'Vali kuu',
    yearSelect: 'Vali aasta',
    decadeSelect: 'Vali dekaad',
    yearFormat: 'YYYY',
    dateFormat: 'D.M.YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D.M.YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Eelmine kuu (PageUp)',
    nextMonth: 'Järgmine kuu (PageDown)',
    previousYear: 'Eelmine aasta (Control + left)',
    nextYear: 'Järgmine aasta (Control + right)',
    previousDecade: 'Eelmine dekaad',
    nextDecade: 'Järgmine dekaad',
    previousCentury: 'Eelmine sajand',
    nextCentury: 'Järgmine sajand',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$21 = {
    placeholder: 'Vali aeg',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// 统一合并为完整的 Locale
const locale$20 = {
    lang: Object.assign({ placeholder: 'Vali kuupäev', rangePlaceholder: ['Algus kuupäev', 'Lõpu kuupäev'] }, CalendarLocale$10),
    timePickerLocale: Object.assign({}, locale$21),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$10 = {
    // Options.jsx
    items_per_page: '/ leheküljel',
    jump_to: 'Hüppa',
    jump_to_confirm: 'Kinnitage',
    page: '',
    // Pagination.jsx
    prev_page: 'Eelmine leht',
    next_page: 'Järgmine leht',
    prev_5: 'Eelmised 5 lehekülge',
    next_5: 'Järgmised 5 lehekülge',
    prev_3: 'Eelmised 3 lehekülge',
    next_3: 'Järgmised 3 lehekülge',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var et_EE = {
    locale: 'et',
    Pagination: Pagination$10,
    DatePicker: locale$20,
    TimePicker: locale$21,
    Calendar: CalendarLocale$10,
    Table: {
        filterTitle: 'Filtri menüü',
        filterConfirm: 'OK',
        filterReset: 'Nulli',
        emptyText: 'Andmed puuduvad',
        selectAll: 'Vali kõik',
        selectInvert: 'Inverteeri valik',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Tühista',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Tühista',
    },
    Transfer: {
        notFoundContent: 'Ei leitud',
        searchPlaceholder: 'Otsi siit',
        itemUnit: 'kogus',
        itemsUnit: 'kogus',
    },
    Select: {
        notFoundContent: 'Ei leitud',
    },
    Upload: {
        uploading: 'Üleslaadimine...',
        removeFile: 'Eemalda fail',
        uploadError: 'Üleslaadimise tõrge',
        previewFile: 'Faili eelvaade',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$11 = {
    today: 'امروز',
    now: 'اکنون',
    backToToday: 'بازگشت به روز',
    ok: 'باشه',
    clear: 'پاک کردن',
    month: 'ماه',
    year: 'سال',
    timeSelect: 'انتخاب زمان',
    dateSelect: 'انتخاب تاریخ',
    monthSelect: 'یک ماه را انتخاب کنید',
    yearSelect: 'یک سال را انتخاب کنید',
    decadeSelect: 'یک دهه را انتخاب کنید',
    yearFormat: 'YYYY',
    dateFormat: 'M/D/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'M/D/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'ماه قبل (PageUp)',
    nextMonth: 'ماه بعد (PageDown)',
    previousYear: 'سال قبل (Control + left)',
    nextYear: 'سال بعد (Control + right)',
    previousDecade: 'دهه قبل',
    nextDecade: 'دهه بعد',
    previousCentury: 'قرن قبل',
    nextCentury: 'قرن بعد',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$23 = {
    placeholder: 'انتخاب زمان',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$22 = {
    lang: Object.assign({ placeholder: 'انتخاب تاریخ', rangePlaceholder: ['تاریخ شروع', 'تاریخ پایان'] }, CalendarLocale$11),
    timePickerLocale: Object.assign({}, locale$23),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$11 = {
    // Options.jsx
    items_per_page: '/ صفحه',
    jump_to: 'برو به',
    jump_to_confirm: 'تایید',
    page: '',
    // Pagination.jsx
    prev_page: 'صفحه قبلی',
    next_page: 'صفحه بعدی',
    prev_5: '۵ صفحه قبلی',
    next_5: '۵ صفحه بعدی',
    prev_3: '۳ صفحه قبلی',
    next_3: '۳ صفحه بعدی',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var fa_IR = {
    locale: 'fa',
    Pagination: Pagination$11,
    DatePicker: locale$22,
    TimePicker: locale$23,
    Calendar: CalendarLocale$11,
    Table: {
        filterTitle: 'منوی فیلتر',
        filterConfirm: 'تایید',
        filterReset: 'پاک کردن',
        emptyText: 'داده‌ای موجود نیست',
        selectAll: 'انتخاب صفحه‌ی کنونی',
        selectInvert: 'معکوس کردن انتخاب‌ها در صفحه ی کنونی',
    },
    Modal: {
        okText: 'تایید',
        cancelText: 'لغو',
        justOkText: 'تایید',
    },
    Popconfirm: {
        okText: 'تایید',
        cancelText: 'لغو',
    },
    Transfer: {
        notFoundContent: 'داده‌ای موجود نیست',
        searchPlaceholder: 'جستجو',
        itemUnit: '',
        itemsUnit: '',
    },
    Select: {
        notFoundContent: 'داده‌ای موجود نیست',
    },
    Upload: {
        uploading: 'در حال آپلود...',
        removeFile: 'حذف فایل',
        uploadError: 'خطا در آپلود',
        previewFile: 'مشاهده‌ی فایل',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$12 = {
    today: 'Tänään',
    now: 'Nyt',
    backToToday: 'Tämä päivä',
    ok: 'Ok',
    clear: 'Tyhjennä',
    month: 'Kuukausi',
    year: 'Vuosi',
    timeSelect: 'Valise aika',
    dateSelect: 'Valitse päivä',
    monthSelect: 'Valitse kuukausi',
    yearSelect: 'Valitse vuosi',
    decadeSelect: 'Valitse vuosikymmen',
    yearFormat: 'YYYY',
    dateFormat: 'D.M.YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D.M.YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Edellinen kuukausi (PageUp)',
    nextMonth: 'Seuraava kuukausi (PageDown)',
    previousYear: 'Edellinen vuosi (Control + left)',
    nextYear: 'Seuraava vuosi (Control + right)',
    previousDecade: 'Edellinen vuosikymmen',
    nextDecade: 'Seuraava vuosikymmen',
    previousCentury: 'Edellinen vuosisata',
    nextCentury: 'Seuraava vuosisata',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$25 = {
    placeholder: 'Valitse aika',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$24 = {
    lang: Object.assign({ placeholder: 'Valitse päivä', rangePlaceholder: ['Alku päivä', 'Loppu päivä'] }, CalendarLocale$12),
    timePickerLocale: Object.assign({}, locale$25),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$12 = {
    // Options.jsx
    items_per_page: '/ sivu',
    jump_to: 'Mene',
    jump_to_confirm: 'Potvrdite',
    page: '',
    // Pagination.jsx
    prev_page: 'Edellinen sivu',
    next_page: 'Seuraava sivu',
    prev_5: 'Edelliset 5 sivua',
    next_5: 'Seuraavat 5 sivua',
    prev_3: 'Edelliset 3 sivua',
    next_3: 'Seuraavat 3 sivua',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var fi_FI = {
    locale: 'fi',
    Pagination: Pagination$12,
    DatePicker: locale$24,
    TimePicker: locale$25,
    Calendar: CalendarLocale$12,
    Table: {
        filterTitle: 'Suodatus valikko',
        filterConfirm: 'OK',
        filterReset: 'Tyhjennä',
        emptyText: 'Ei kohteita',
        selectAll: 'Valitse kaikki',
        selectInvert: 'Valitse päinvastoin',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Peruuta',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Peruuta',
    },
    Transfer: {
        notFoundContent: 'Ei löytynyt',
        searchPlaceholder: 'Etsi täältä',
        itemUnit: 'kohde',
        itemsUnit: 'kohdetta',
    },
    Select: {
        notFoundContent: 'Ei löytynyt',
    },
    Upload: {
        uploading: 'Lähetetään...',
        removeFile: 'Poista tiedosto',
        uploadError: 'Virhe lähetyksessä',
        previewFile: 'Esikatsele tiedostoa',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$13 = {
    today: 'Aujourd\'hui',
    now: 'Maintenant',
    backToToday: 'Aujourd\'hui',
    ok: 'Ok',
    clear: 'Rétablir',
    month: 'Mois',
    year: 'Année',
    timeSelect: 'Sélectionner l\'heure',
    dateSelect: 'Sélectionner l\'heure',
    monthSelect: 'Choisissez un mois',
    yearSelect: 'Choisissez une année',
    decadeSelect: 'Choisissez une décennie',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Mois précédent (PageUp)',
    nextMonth: 'Mois suivant (PageDown)',
    previousYear: 'Année précédente (Ctrl + gauche)',
    nextYear: 'Année prochaine (Ctrl + droite)',
    previousDecade: 'Décennie précédente',
    nextDecade: 'Décennie suivante',
    previousCentury: 'Siècle précédent',
    nextCentury: 'Siècle suivant',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$27 = {
    placeholder: 'Sélectionner l\'heure',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$26 = {
    lang: Object.assign({ placeholder: 'Sélectionner une date', rangePlaceholder: ['Date de début', 'Date de fin'] }, CalendarLocale$13),
    timePickerLocale: Object.assign({}, locale$27),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$13 = {
    // Options.jsx
    items_per_page: '/ page',
    jump_to: 'Aller à',
    jump_to_confirm: 'confirmer',
    page: '',
    // Pagination.jsx
    prev_page: 'Page précédente',
    next_page: 'Page suivante',
    prev_5: '5 Pages précédentes',
    next_5: '5 Pages suivantes',
    prev_3: '3 Pages précédentes',
    next_3: '3 Pages suivantes',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var fr_BE = {
    locale: 'fr',
    Pagination: Pagination$13,
    DatePicker: locale$26,
    TimePicker: locale$27,
    Calendar: CalendarLocale$13,
    Table: {
        filterTitle: 'Filtrer',
        filterConfirm: 'OK',
        filterReset: 'Réinitialiser',
        emptyText: 'Aucune donnée',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Annuler',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Annuler',
    },
    Transfer: {
        notFoundContent: 'Pas de résultat',
        searchPlaceholder: 'Recherche',
        itemUnit: 'élément',
        itemsUnit: 'éléments',
    },
    Select: {
        notFoundContent: 'Pas de résultat',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$14 = {
    today: 'Aujourd\'hui',
    now: 'Maintenant',
    backToToday: 'Aujourd\'hui',
    ok: 'Ok',
    clear: 'Rétablir',
    month: 'Mois',
    year: 'Année',
    timeSelect: 'Sélectionner l\'heure',
    dateSelect: 'Sélectionner l\'heure',
    monthSelect: 'Choisissez un mois',
    yearSelect: 'Choisissez une année',
    decadeSelect: 'Choisissez une décennie',
    yearFormat: 'YYYY',
    dateFormat: 'DD/MM/YYYY',
    dayFormat: 'DD',
    dateTimeFormat: 'DD/MM/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Mois précédent (PageUp)',
    nextMonth: 'Mois suivant (PageDown)',
    previousYear: 'Année précédente (Ctrl + gauche)',
    nextYear: 'Année prochaine (Ctrl + droite)',
    previousDecade: 'Décennie précédente',
    nextDecade: 'Décennie suivante',
    previousCentury: 'Siècle précédent',
    nextCentury: 'Siècle suivant',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$29 = {
    placeholder: 'Sélectionner l\'heure',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$28 = {
    lang: Object.assign({ placeholder: 'Sélectionner une date', rangePlaceholder: ['Date de début', 'Date de fin'] }, CalendarLocale$14),
    timePickerLocale: Object.assign({}, locale$29),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$14 = {
    // Options.jsx
    items_per_page: '/ page',
    jump_to: 'Aller à',
    jump_to_confirm: 'confirmer',
    page: '',
    // Pagination.jsx
    prev_page: 'Page précédente',
    next_page: 'Page suivante',
    prev_5: '5 Pages précédentes',
    next_5: '5 Pages suivantes',
    prev_3: '3 Pages précédentes',
    next_3: '3 Pages suivantes',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var fr_FR = {
    locale: 'fr',
    Pagination: Pagination$14,
    DatePicker: locale$28,
    TimePicker: locale$29,
    Calendar: CalendarLocale$14,
    Table: {
        filterTitle: 'Filtrer',
        filterConfirm: 'OK',
        filterReset: 'Réinitialiser',
        emptyText: 'Aucune donnée',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Annuler',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Annuler',
    },
    Transfer: {
        notFoundContent: 'Pas de résultat',
        searchPlaceholder: 'Recherche',
        itemUnit: 'élément',
        itemsUnit: 'éléments',
    },
    Select: {
        notFoundContent: 'Pas de résultat',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$15 = {
    today: 'Í dag',
    now: 'Núna',
    backToToday: 'Til baka til dagsins í dag',
    ok: 'Í lagi',
    clear: 'Hreinsa',
    month: 'Mánuður',
    year: 'Ár',
    timeSelect: 'Velja tíma',
    dateSelect: 'Velja dag',
    monthSelect: 'Velja mánuð',
    yearSelect: 'Velja ár',
    decadeSelect: 'Velja áratug',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Fyrri mánuður (PageUp)',
    nextMonth: 'Næsti mánuður (PageDown)',
    previousYear: 'Fyrra ár (Control + left)',
    nextYear: 'Næsta ár (Control + right)',
    previousDecade: 'Fyrri áratugur',
    nextDecade: 'Næsti áratugur',
    previousCentury: 'Fyrri öld',
    nextCentury: 'Næsta öld',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$31 = {
    placeholder: 'Velja tíma',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$30 = {
    lang: Object.assign({ placeholder: 'Veldu dag', rangePlaceholder: ['Upphafsdagur', 'Lokadagur'] }, CalendarLocale$15),
    timePickerLocale: Object.assign({}, locale$31),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$15 = {
    // Options.jsx
    items_per_page: '/ síðu',
    jump_to: 'Síða',
    jump_to_confirm: 'staðfest',
    page: '',
    // Pagination.jsx
    prev_page: 'Fyrri síða',
    next_page: 'Næsta síða',
    prev_5: 'Til baka 5 síður',
    next_5: 'Áfram 5 síður',
    prev_3: 'Til baka 3 síður',
    next_3: 'Áfram 3 síður',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var is_IS = {
    locale: 'is',
    Pagination: Pagination$15,
    DatePicker: locale$30,
    TimePicker: locale$31,
    Calendar: CalendarLocale$15,
    Table: {
        filterTitle: 'Afmarkanir',
        filterConfirm: 'Staðfesta',
        filterReset: 'Núllstilla',
        emptyText: 'Engin gögn',
        selectAll: 'Velja allt',
        selectInvert: 'Viðsnúa vali',
    },
    Modal: {
        okText: 'Áfram',
        cancelText: 'Hætta við',
        justOkText: 'Í lagi',
    },
    Popconfirm: {
        okText: 'Áfram',
        cancelText: 'Hætta við',
    },
    Transfer: {
        notFoundContent: 'Engar færslur',
        searchPlaceholder: 'Leita hér',
        itemUnit: 'færsla',
        itemsUnit: 'færslur',
    },
    Select: {
        notFoundContent: 'Ekkert finnst',
    },
    Upload: {
        uploading: 'Hleð upp...',
        removeFile: 'Fjarlægja skrá',
        uploadError: 'Villa við að hlaða upp',
        previewFile: 'Forskoða skrá',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$16 = {
    today: 'Oggi',
    now: 'adesso',
    backToToday: 'Torna ad oggi',
    ok: 'Ok',
    clear: 'Chiaro',
    month: 'Mese',
    year: 'Anno',
    timeSelect: 'Seleziona il tempo',
    dateSelect: 'Select date',
    monthSelect: 'Seleziona la data',
    yearSelect: 'Scegli un anno',
    decadeSelect: 'Scegli un decennio',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Il mese scorso (PageUp)',
    nextMonth: 'Il prossimo mese (PageDown)',
    previousYear: 'L\'anno scorso (Control + sinistra)',
    nextYear: 'L\'anno prossimo (Control + destra)',
    previousDecade: 'Ultimo decennio',
    nextDecade: 'Prossimo decennio',
    previousCentury: 'Secolo precedente',
    nextCentury: 'Prossimo secolo',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$33 = {
    placeholder: 'Selezionare il tempo',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$32 = {
    lang: Object.assign({ placeholder: 'Selezionare la data', rangePlaceholder: ['Data d\'inizio', 'Data di fine'] }, CalendarLocale$16),
    timePickerLocale: Object.assign({}, locale$33),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$16 = {
    // Options.jsx
    items_per_page: '/ pagina',
    jump_to: 'vai a',
    jump_to_confirm: 'Conferma',
    page: '',
    // Pagination.jsx
    prev_page: 'Pagina precedente',
    next_page: 'Pagina successiva',
    prev_5: 'Precedente 5 pagine',
    next_5: 'Prossime 5 pagine',
    prev_3: 'Precedente 3 pagine',
    next_3: 'Prossime 3 pagine',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var it_IT = {
    locale: 'it',
    Pagination: Pagination$16,
    DatePicker: locale$32,
    TimePicker: locale$33,
    Calendar: CalendarLocale$16,
    Table: {
        filterTitle: 'Menu Filtro',
        filterConfirm: 'OK',
        filterReset: 'Reset',
        emptyText: 'Nessun dato',
        selectAll: 'Seleziona pagina corrente',
        selectInvert: 'Selezionare Inverti',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Annulla',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Annulla',
    },
    Transfer: {
        notFoundContent: 'Non trovato',
        searchPlaceholder: 'Cerca qui',
        itemUnit: 'articolo',
        itemsUnit: 'elementi',
    },
    Select: {
        notFoundContent: 'Non trovato',
    },
    Upload: {
        uploading: 'Caricamento...',
        removeFile: 'Rimuovi il file',
        uploadError: 'Errore di caricamento',
        previewFile: 'Anteprima file',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$17 = {
    today: '今日',
    now: '現在時刻',
    backToToday: '今日に戻る',
    ok: '決定',
    timeSelect: '時間を選択',
    dateSelect: '日時を選択',
    clear: 'クリア',
    month: '月',
    year: '年',
    previousMonth: '前月 (ページアップキー)',
    nextMonth: '翌月 (ページダウンキー)',
    monthSelect: '月を選択',
    yearSelect: '年を選択',
    decadeSelect: '年代を選択',
    yearFormat: 'YYYY年',
    dayFormat: 'D日',
    dateFormat: 'YYYY年M月D日',
    dateTimeFormat: 'YYYY年M月D日 HH時mm分ss秒',
    previousYear: '前年 (Controlを押しながら左キー)',
    nextYear: '翌年 (Controlを押しながら右キー)',
    previousDecade: '前の年代',
    nextDecade: '次の年代',
    previousCentury: '前の世紀',
    nextCentury: '次の世紀',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$35 = {
    placeholder: '時刻を選択',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$34 = {
    lang: Object.assign({ placeholder: '日付を選択', rangePlaceholder: ['開始日付', '終了日付'] }, CalendarLocale$17),
    timePickerLocale: Object.assign({}, locale$35),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$17 = {
    // Options.jsx
    items_per_page: '/ ページ',
    jump_to: '移動',
    jump_to_confirm: '確認する',
    page: 'ページ',
    // Pagination.jsx
    prev_page: '前のページ',
    next_page: '次のページ',
    prev_5: '前 5ページ',
    next_5: '次 5ページ',
    prev_3: '前 3ページ',
    next_3: '次 3ページ',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ja_JP = {
    locale: 'ja',
    Pagination: Pagination$17,
    DatePicker: locale$34,
    TimePicker: locale$35,
    Calendar: CalendarLocale$17,
    Table: {
        filterTitle: 'メニューをフィルター',
        filterConfirm: 'OK',
        filterReset: 'リセット',
        emptyText: 'データがありません',
        selectAll: 'すべてを選択',
        selectInvert: '選択を反転',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'キャンセル',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'キャンセル',
    },
    Transfer: {
        notFoundContent: '結果はありません',
        searchPlaceholder: 'ここを検索',
        itemUnit: 'アイテム',
        itemsUnit: 'アイテム',
    },
    Select: {
        notFoundContent: '結果はありません',
    },
    Upload: {
        uploading: 'アップロード中...',
        removeFile: 'ファイルを削除',
        uploadError: 'アップロードエラー',
        previewFile: 'ファイルをプレビュー',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$18 = {
    today: '오늘',
    now: '현재 시각',
    backToToday: '오늘로 돌아가기',
    ok: '확인',
    clear: '지우기',
    month: '월',
    year: '년',
    timeSelect: '시간 선택',
    dateSelect: '날짜 선택',
    monthSelect: '달 선택',
    yearSelect: '연 선택',
    decadeSelect: '연대 선택',
    yearFormat: 'YYYY년',
    dateFormat: 'YYYY-MM-DD',
    dayFormat: 'Do',
    dateTimeFormat: 'YYYY-MM-DD HH:mm:ss',
    monthBeforeYear: false,
    previousMonth: '이전 달 (PageUp)',
    nextMonth: '다음 달 (PageDown)',
    previousYear: '이전 해 (Control + left)',
    nextYear: '다음 해 (Control + right)',
    previousDecade: '이전 연대',
    nextDecade: '다음 연대',
    previousCentury: '이전 세기',
    nextCentury: '다음 세기',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$37 = {
    placeholder: '날짜 선택',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$36 = {
    lang: Object.assign({ placeholder: '날짜 선택', rangePlaceholder: ['시작일', '종료일'] }, CalendarLocale$18),
    timePickerLocale: Object.assign({}, locale$37),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$18 = {
    // Options.jsx
    items_per_page: '/ 쪽',
    jump_to: '이동하기',
    jump_to_confirm: '확인하다',
    page: '',
    // Pagination.jsx
    prev_page: '이전 페이지',
    next_page: '다음 페이지',
    prev_5: '이전 5 페이지',
    next_5: '다음 5 페이지',
    prev_3: '이전 3 페이지',
    next_3: '다음 3 페이지',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ko_KR = {
    locale: 'ko',
    Pagination: Pagination$18,
    DatePicker: locale$36,
    TimePicker: locale$37,
    Calendar: CalendarLocale$18,
    Table: {
        filterTitle: '필터 메뉴',
        filterConfirm: '확인',
        filterReset: '초기화',
        emptyText: '데이터 없음',
    },
    Modal: {
        okText: '확인',
        cancelText: '취소',
        justOkText: '확인',
    },
    Popconfirm: {
        okText: '확인',
        cancelText: '취소',
    },
    Transfer: {
        notFoundContent: '데이터 없음',
        searchPlaceholder: '여기에 검색하세요',
        itemUnit: '개',
        itemsUnit: '개',
    },
    Select: {
        notFoundContent: '데이터 없음',
    },
    Upload: {
        uploading: '업로드 중...',
        removeFile: '파일 삭제',
        uploadError: '업로드 실패',
        previewFile: '파일 미리보기',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$19 = {
    today: 'I dag',
    now: 'Nå',
    backToToday: 'Gå til i dag',
    ok: 'Ok',
    clear: 'Annuller',
    month: 'Måned',
    year: 'År',
    timeSelect: 'Velg tidspunkt',
    dateSelect: 'Velg dato',
    monthSelect: 'Velg måned',
    yearSelect: 'Velg år',
    decadeSelect: 'Velg årti',
    yearFormat: 'YYYY',
    dateFormat: 'DD.MM.YYYY',
    dayFormat: 'DD',
    dateTimeFormat: 'DD.MM.YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Forrige måned(PageUp)',
    nextMonth: 'Neste måned (PageDown)',
    previousYear: 'Forrige år (Control + left)',
    nextYear: 'Neste år (Control + right)',
    previousDecade: 'Forrige tiår',
    nextDecade: 'Neste tiår',
    previousCentury: 'Forrige århundre',
    nextCentury: 'Neste århundre',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$39 = {
    placeholder: 'Velg tid',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$38 = {
    lang: Object.assign({ placeholder: 'Velg dato', rangePlaceholder: ['Startdato', 'Sluttdato'] }, CalendarLocale$19),
    timePickerLocale: Object.assign({}, locale$39),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$19 = {
    // Options.jsx
    items_per_page: '/ side',
    jump_to: 'Gå til side',
    page: '',
    // Pagination.jsx
    prev_page: 'Forrige side',
    next_page: 'Neste side',
    prev_5: '5 forrige',
    next_5: '5 neste',
    prev_3: '3 forrige',
    next_3: '3 neste',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var nb_NO = {
    locale: 'nb',
    DatePicker: locale$38,
    TimePicker: locale$39,
    Calendar: CalendarLocale$19,
    Pagination: Pagination$19,
    Table: {
        filterTitle: 'Filtermeny',
        filterConfirm: 'OK',
        filterReset: 'Nullstill',
        emptyText: 'Ingen data',
        selectAll: 'Velg alle',
        selectInvert: 'Inverter valg',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Avbryt',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Avbryt',
    },
    Transfer: {
        notFoundContent: 'Ingen treff',
        searchPlaceholder: 'Søk her',
        itemUnit: 'element',
        itemsUnit: 'elementer',
    },
    Select: {
        notFoundContent: 'Ingen treff',
    },
    Upload: {
        uploading: 'Laster opp...',
        removeFile: 'Fjern fil',
        uploadError: 'Feil ved opplastning',
        previewFile: 'Forhåndsvisning',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$20 = {
    today: 'Vandaag',
    now: 'Nu',
    backToToday: 'Terug naar vandaag',
    ok: 'Ok',
    clear: 'Reset',
    month: 'Maand',
    year: 'Jaar',
    timeSelect: 'Selecteer tijd',
    dateSelect: 'Selecteer datum',
    monthSelect: 'Kies een maand',
    yearSelect: 'Kies een jaar',
    decadeSelect: 'Kies een decennium',
    yearFormat: 'YYYY',
    dateFormat: 'D-M-YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D-M-YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Vorige maand (PageUp)',
    nextMonth: 'Volgende maand (PageDown)',
    previousYear: 'Vorig jaar (Control + left)',
    nextYear: 'Volgend jaar (Control + right)',
    previousDecade: 'Vorig decennium',
    nextDecade: 'Volgend decennium',
    previousCentury: 'Vorige eeuw',
    nextCentury: 'Volgende eeuw',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$41 = {
    placeholder: 'Selecteer tijd',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$40 = {
    lang: Object.assign({ placeholder: 'Selecteer datum', rangePlaceholder: ['Begin datum', 'Eind datum'] }, CalendarLocale$20),
    timePickerLocale: Object.assign({}, locale$41),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$20 = {
    // Options.jsx
    items_per_page: '/ pagina',
    jump_to: 'Ga naar',
    jump_to_confirm: 'bevestigen',
    page: '',
    // Pagination.jsx
    prev_page: 'Vorige pagina',
    next_page: 'Volgende pagina',
    prev_5: 'Vorige 5 pagina\'s',
    next_5: 'Volgende 5 pagina\'s',
    prev_3: 'Vorige 3 pagina\'s',
    next_3: 'Volgende 3 pagina\'s',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var nl_BE = {
    locale: 'nl-be',
    Pagination: Pagination$20,
    DatePicker: locale$40,
    TimePicker: locale$41,
    Calendar: CalendarLocale$20,
    Table: {
        filterTitle: 'FilterMenu',
        filterConfirm: 'OK',
        filterReset: 'Reset',
        emptyText: 'Geen gegevens',
        selectAll: 'Selecteer huidige pagina',
        selectInvert: 'Selecteer huidige pagina',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Annuleer',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Annuleer',
    },
    Transfer: {
        notFoundContent: 'Niet gevonden',
        searchPlaceholder: 'Zoek hier',
        itemUnit: 'item',
        itemsUnit: 'items',
    },
    Select: {
        notFoundContent: 'Niet gevonden',
    },
    Upload: {
        uploading: 'Uploaden...',
        removeFile: 'Bestand verwijderen',
        uploadError: 'Upload fout',
        previewFile: 'Preview bestand',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$21 = {
    today: 'Vandaag',
    now: 'Nu',
    backToToday: 'Terug naar vandaag',
    ok: 'Ok',
    clear: 'Reset',
    month: 'Maand',
    year: 'Jaar',
    timeSelect: 'Selecteer tijd',
    dateSelect: 'Selecteer datum',
    monthSelect: 'Kies een maand',
    yearSelect: 'Kies een jaar',
    decadeSelect: 'Kies een decennium',
    yearFormat: 'YYYY',
    dateFormat: 'D-M-YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D-M-YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Vorige maand (PageUp)',
    nextMonth: 'Volgende maand (PageDown)',
    previousYear: 'Vorig jaar (Control + left)',
    nextYear: 'Volgend jaar (Control + right)',
    previousDecade: 'Vorig decennium',
    nextDecade: 'Volgend decennium',
    previousCentury: 'Vorige eeuw',
    nextCentury: 'Volgende eeuw',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$43 = {
    placeholder: 'Selecteer tijd',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$42 = {
    lang: Object.assign({ placeholder: 'Selecteer datum', rangePlaceholder: ['Begin datum', 'Eind datum'] }, CalendarLocale$21),
    timePickerLocale: Object.assign({}, locale$43),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$21 = {
    // Options.jsx
    items_per_page: '/ pagina',
    jump_to: 'Ga naar',
    jump_to_confirm: 'bevestigen',
    page: '',
    // Pagination.jsx
    prev_page: 'Vorige pagina',
    next_page: 'Volgende pagina',
    prev_5: 'Vorige 5 pagina\'s',
    next_5: 'Volgende 5 pagina\'s',
    prev_3: 'Vorige 3 pagina\'s',
    next_3: 'Volgende 3 pagina\'s',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var nl_NL = {
    locale: 'nl',
    Pagination: Pagination$21,
    DatePicker: locale$42,
    TimePicker: locale$43,
    Calendar: CalendarLocale$21,
    Table: {
        filterTitle: 'Filteren',
        filterConfirm: 'OK',
        filterReset: 'Reset',
        emptyText: 'Geen gegevens',
        selectAll: 'Selecteer huidige pagina',
        selectInvert: 'Deselecteer huidige pagina',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Annuleren',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Annuleren',
    },
    Transfer: {
        notFoundContent: 'Niet gevonden',
        searchPlaceholder: 'Zoeken',
        itemUnit: 'item',
        itemsUnit: 'items',
    },
    Select: {
        notFoundContent: 'Niet gevonden',
    },
    Upload: {
        uploading: 'Uploaden...',
        removeFile: 'Verwijder bestand',
        uploadError: 'Fout tijdens uploaden',
        previewFile: 'Bekijk bestand',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$22 = {
    today: 'Dzisiaj',
    now: 'Teraz',
    backToToday: 'Ustaw dzisiaj',
    ok: 'Ok',
    clear: 'Wyczyść',
    month: 'Miesiąc',
    year: 'Rok',
    timeSelect: 'Ustaw czas',
    dateSelect: 'Ustaw datę',
    monthSelect: 'Wybierz miesiąc',
    yearSelect: 'Wybierz rok',
    decadeSelect: 'Wybierz dekadę',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Poprzedni miesiąc (PageUp)',
    nextMonth: 'Następny miesiąc (PageDown)',
    previousYear: 'Ostatni rok (Ctrl + left)',
    nextYear: 'Następny rok (Ctrl + right)',
    previousDecade: 'Ostatnia dekada',
    nextDecade: 'Następna dekada',
    previousCentury: 'Ostatni wiek',
    nextCentury: 'Następny wiek',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$45 = {
    placeholder: 'Wybierz godzinę',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$44 = {
    lang: Object.assign({ placeholder: 'Wybierz datę', rangePlaceholder: ['Data początkowa', 'Data końcowa'] }, CalendarLocale$22),
    timePickerLocale: Object.assign({}, locale$45),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$22 = {
    // Options.jsx
    items_per_page: '/ stronę',
    jump_to: 'Idź do',
    jump_to_confirm: 'potwierdzać',
    page: '',
    // Pagination.jsx
    prev_page: 'Poprzednia strona',
    next_page: 'Następna strona',
    prev_5: 'Poprzednie 5 stron',
    next_5: 'Następne 5 stron',
    prev_3: 'Poprzednie 3 strony',
    next_3: 'Następne 3 strony',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var pl_PL = {
    locale: 'pl',
    Pagination: Pagination$22,
    DatePicker: locale$44,
    TimePicker: locale$45,
    Calendar: CalendarLocale$22,
    Table: {
        filterTitle: 'Menu filtra',
        filterConfirm: 'OK',
        filterReset: 'Wyczyść',
        emptyText: 'Brak danych',
        selectAll: 'Zaznacz bieżącą stronę',
        selectInvert: 'Odwróć zaznaczenie',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Anuluj',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Anuluj',
    },
    Transfer: {
        notFoundContent: 'Nie znaleziono',
        searchPlaceholder: 'Szukaj',
        itemUnit: 'obiekt',
        itemsUnit: 'obiekty',
    },
    Select: {
        notFoundContent: 'Nie znaleziono',
    },
    Upload: {
        uploading: 'Wysyłanie...',
        removeFile: 'Usuń plik',
        uploadError: 'Błąd wysyłania',
        previewFile: 'Podejrzyj plik',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$23 = {
    today: 'Hoje',
    now: 'Agora',
    backToToday: 'Voltar para hoje',
    ok: 'Ok',
    clear: 'Limpar',
    month: 'Mês',
    year: 'Ano',
    timeSelect: 'Selecionar tempo',
    dateSelect: 'Selecionar data',
    monthSelect: 'Escolher mês',
    yearSelect: 'Escolher ano',
    decadeSelect: 'Escolher década',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: false,
    previousMonth: 'Mês anterior (PageUp)',
    nextMonth: 'Próximo mês (PageDown)',
    previousYear: 'Ano anterior (Control + esquerda)',
    nextYear: 'Próximo ano (Control + direita)',
    previousDecade: 'Década anterior',
    nextDecade: 'Próxima década',
    previousCentury: 'Século anterior',
    nextCentury: 'Próximo século',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$47 = {
    placeholder: 'Hora',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$46 = {
    lang: Object.assign({ placeholder: 'Selecionar data', rangePlaceholder: ['Data de início', 'Data de fim'] }, CalendarLocale$23),
    timePickerLocale: Object.assign({}, locale$47),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$23 = {
    // Options.jsx
    items_per_page: '/ páginas',
    jump_to: 'Vá até',
    jump_to_confirm: 'confirme',
    page: '',
    // Pagination.jsx
    prev_page: 'Página anterior',
    next_page: 'Próxima página',
    prev_5: '5 páginas anteriores',
    next_5: '5 próximas páginas',
    prev_3: '3 páginas anteriores',
    next_3: '3 próximas páginas',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var pt_BR = {
    locale: 'pt-br',
    Pagination: Pagination$23,
    DatePicker: locale$46,
    TimePicker: locale$47,
    Calendar: CalendarLocale$23,
    Table: {
        filterTitle: 'Filtro',
        filterConfirm: 'OK',
        filterReset: 'Resetar',
        emptyText: 'Não há dados',
        selectAll: 'Selecionar página atual',
        selectInvert: 'Inverter seleção',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Cancelar',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Cancelar',
    },
    Transfer: {
        notFoundContent: 'Não encontrado',
        searchPlaceholder: 'Procurar',
        itemUnit: 'item',
        itemsUnit: 'items',
    },
    Select: {
        notFoundContent: 'Não encontrado',
    },
    Upload: {
        uploading: 'Enviando...',
        removeFile: 'Remover arquivo',
        uploadError: 'Erro no envio',
        previewFile: 'Visualizar arquivo',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$24 = {
    today: 'Hoje',
    now: 'Agora',
    backToToday: 'Hoje',
    ok: 'Ok',
    clear: 'Limpar',
    month: 'Mês',
    year: 'Ano',
    timeSelect: 'Selecionar hora',
    dateSelect: 'Selecionar data',
    monthSelect: 'Selecionar mês',
    yearSelect: 'Selecionar ano',
    decadeSelect: 'Selecionar década',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Mês anterior (PageUp)',
    nextMonth: 'Mês seguinte (PageDown)',
    previousYear: 'Ano anterior (Control + left)',
    nextYear: 'Ano seguinte (Control + right)',
    previousDecade: 'Década anterior',
    nextDecade: 'Década seguinte',
    previousCentury: 'Século anterior',
    nextCentury: 'Século seguinte',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$49 = {
    placeholder: 'Hora',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$48 = {
    lang: Object.assign({}, CalendarLocale$24, { placeholder: 'Data', rangePlaceholder: ['Data inicial', 'Data final'], today: 'Hoje', now: 'Agora', backToToday: 'Hoje', ok: 'Ok', clear: 'Limpar', month: 'Mês', year: 'Ano', timeSelect: 'Hora', dateSelect: 'Selecionar data', monthSelect: 'Selecionar mês', yearSelect: 'Selecionar ano', decadeSelect: 'Selecionar década', yearFormat: 'YYYY', dateFormat: 'D/M/YYYY', dayFormat: 'D', dateTimeFormat: 'D/M/YYYY HH:mm:ss', monthFormat: 'MMMM', monthBeforeYear: false, previousMonth: 'Mês anterior (PageUp)', nextMonth: 'Mês seguinte (PageDown)', previousYear: 'Ano anterior (Control + left)', nextYear: 'Ano seguinte (Control + right)', previousDecade: 'Última década', nextDecade: 'Próxima década', previousCentury: 'Último século', nextCentury: 'Próximo século' }),
    timePickerLocale: Object.assign({}, locale$49, { placeholder: 'Hora' }),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$24 = {
    // Options.jsx
    items_per_page: '/ página',
    jump_to: 'Saltar',
    jump_to_confirm: 'confirmar',
    page: '',
    // Pagination.jsx
    prev_page: 'Página Anterior',
    next_page: 'Página Seguinte',
    prev_5: 'Recuar 5 Páginas',
    next_5: 'Avançar 5 Páginas',
    prev_3: 'Recuar 3 Páginas',
    next_3: 'Avançar 3 Páginas',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var pt_PT = {
    locale: 'pt',
    Pagination: Pagination$24,
    DatePicker: locale$48,
    TimePicker: locale$49,
    Calendar: CalendarLocale$24,
    Table: {
        filterTitle: 'Filtro',
        filterConfirm: 'Aplicar',
        filterReset: 'Reiniciar',
        emptyText: 'Sem resultados',
        selectAll: 'Selecionar página atual',
        selectInvert: 'Inverter seleção',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Cancelar',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Cancelar',
    },
    Transfer: {
        notFoundContent: 'Sem resultados',
        searchPlaceholder: 'Procurar...',
        itemUnit: 'item',
        itemsUnit: 'itens',
    },
    Select: {
        notFoundContent: 'Sem resultados',
    },
    Upload: {
        uploading: 'A carregar...',
        removeFile: 'Remover',
        uploadError: 'Erro ao carregar',
        previewFile: 'Pré-visualizar',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$25 = {
    today: 'Сегодня',
    now: 'Сейчас',
    backToToday: 'Текущая дата',
    ok: 'Ok',
    clear: 'Очистить',
    month: 'Месяц',
    year: 'Год',
    timeSelect: 'Выбрать время',
    dateSelect: 'Выбрать дату',
    monthSelect: 'Выбрать месяц',
    yearSelect: 'Выбрать год',
    decadeSelect: 'Выбрать десятилетие',
    yearFormat: 'YYYY',
    dateFormat: 'D-M-YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D-M-YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Предыдущий месяц (PageUp)',
    nextMonth: 'Следующий месяц (PageDown)',
    previousYear: 'Предыдущий год (Control + left)',
    nextYear: 'Следующий год (Control + right)',
    previousDecade: 'Предыдущее десятилетие',
    nextDecade: 'Следущее десятилетие',
    previousCentury: 'Предыдущий век',
    nextCentury: 'Следующий век',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by Andrey Gayvoronsky on 13/04/16.
 */
const locale$51 = {
    placeholder: 'Выберите время',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by Andrey Gayvoronsky on 13/04/16.
 */
const locale$50 = {
    lang: Object.assign({ placeholder: 'Выберите дату', rangePlaceholder: ['Начальная дата', 'Конечная дата'] }, CalendarLocale$25),
    timePickerLocale: Object.assign({}, locale$51),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$25 = {
    // Options.jsx
    items_per_page: '/странице',
    jump_to: 'Перейти',
    jump_to_confirm: 'подтвердить',
    page: '',
    // Pagination.jsx
    prev_page: 'Назад',
    next_page: 'Вперед',
    prev_5: 'Предыдущие 5',
    next_5: 'Следующие 5',
    prev_3: 'Предыдущие 3',
    next_3: 'Следующие 3',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ru_RU = {
    locale: 'ru',
    Pagination: Pagination$25,
    DatePicker: locale$50,
    TimePicker: locale$51,
    Calendar: CalendarLocale$25,
    Table: {
        filterTitle: 'Фильтр',
        filterConfirm: 'OK',
        filterReset: 'Сбросить',
        emptyText: 'Нет данных',
        selectAll: 'Выбрать всё',
        selectInvert: 'Инвертировать выбор',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Отмена',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Отмена',
    },
    Transfer: {
        notFoundContent: 'Ничего не найдено',
        searchPlaceholder: 'Введите название для поиска',
        itemUnit: 'item',
        itemsUnit: 'items',
    },
    Select: {
        notFoundContent: 'Ничего не найдено',
    },
    Upload: {
        uploading: 'Закачиваю...',
        removeFile: 'Удалить файл',
        uploadError: 'Ошибка при закачке',
        previewFile: 'Предпросмотр файла',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$26 = {
    today: 'Dnes',
    now: 'Teraz',
    backToToday: 'Späť na dnes',
    ok: 'Ok',
    clear: 'Vymazať',
    month: 'Mesiac',
    year: 'Rok',
    timeSelect: 'Vybrať čas',
    dateSelect: 'Vybrať dátum',
    monthSelect: 'Vybrať mesiac',
    yearSelect: 'Vybrať rok',
    decadeSelect: 'Vybrať dekádu',
    yearFormat: 'YYYY',
    dateFormat: 'D.M.YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D.M.YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Predchádzajúci mesiac (PageUp)',
    nextMonth: 'Nasledujúci mesiac (PageDown)',
    previousYear: 'Predchádzajúci rok (Control + left)',
    nextYear: 'Nasledujúci rok (Control + right)',
    previousDecade: 'Predchádzajúca dekáda',
    nextDecade: 'Nasledujúca dekáda',
    previousCentury: 'Predchádzajúce storočie',
    nextCentury: 'Nasledujúce storočie',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$53 = {
    placeholder: 'Vybrať čas',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// 统一合并为完整的 Locale
const locale$52 = {
    lang: Object.assign({ placeholder: 'Vybrať dátum', rangePlaceholder: ['Od', 'Do'] }, CalendarLocale$26),
    timePickerLocale: Object.assign({}, locale$53),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$26 = {
    // Options.jsx
    items_per_page: '/ strana',
    jump_to: 'Choď na',
    jump_to_confirm: 'potvrdit',
    page: '',
    // Pagination.jsx
    prev_page: 'Predchádzajúca strana',
    next_page: 'Nasledujúca strana',
    prev_5: 'Predchádzajúcich 5 strán',
    next_5: 'Nasledujúcich 5 strán',
    prev_3: 'Predchádzajúce 3 strany',
    next_3: 'Nasledujúce 3 strany',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var sk_SK = {
    locale: 'sk',
    Pagination: Pagination$26,
    DatePicker: locale$52,
    TimePicker: locale$53,
    Calendar: CalendarLocale$26,
    Table: {
        filterTitle: 'Filter',
        filterConfirm: 'OK',
        filterReset: 'Obnoviť',
        emptyText: 'Žiadne dáta',
        selectAll: 'Vybrať všetko',
        selectInvert: 'Vybrať opačné',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Zrušiť',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Zrušiť',
    },
    Transfer: {
        notFoundContent: 'Nenájdené',
        searchPlaceholder: 'Vyhľadávanie',
        itemUnit: 'položka',
        itemsUnit: 'položiek',
    },
    Select: {
        notFoundContent: 'Nenájdené',
    },
    Upload: {
        uploading: 'Nahrávanie...',
        removeFile: 'Odstrániť súbor',
        uploadError: 'Chyba pri nahrávaní',
        previewFile: 'Zobraziť súbor',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$27 = {
    today: 'Danas',
    now: 'Sada',
    backToToday: 'Vrati se na danas',
    ok: 'U redu',
    clear: 'Obriši',
    month: 'Mesec',
    year: 'Godina',
    timeSelect: 'Izaberi vreme',
    dateSelect: 'Izaberi datum',
    monthSelect: 'Izaberi mesec',
    yearSelect: 'Izaberi godinu',
    decadeSelect: 'Izaberi deceniju',
    yearFormat: 'YYYY',
    dateFormat: 'DD.MM.YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'DD.MM.YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Prethodni mesec (PageUp)',
    nextMonth: 'Sledeći mesec (PageDown)',
    previousYear: 'Prethodna godina (Control + left)',
    nextYear: 'Sledeća godina (Control + right)',
    previousDecade: 'Prethodna decenija',
    nextDecade: 'Sledeća decenija',
    previousCentury: 'Prethodni vek',
    nextCentury: 'Sledeći vek',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$55 = {
    placeholder: 'Izaberite vreme',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$54 = {
    lang: Object.assign({ placeholder: 'Izaberite datum', rangePlaceholder: ['Početni datum', 'Krajnji datum'] }, CalendarLocale$27),
    timePickerLocale: Object.assign({}, locale$55),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$27 = {
    // Options.jsx
    items_per_page: '/ strani',
    jump_to: 'Idi na',
    page: '',
    // Pagination.jsx
    prev_page: 'Prethodna strana',
    next_page: 'Sledeća strana',
    prev_5: 'Prethodnih 5 Strana',
    next_5: 'Sledećih 5 Strana',
    prev_3: 'Prethodnih 3 Strane',
    next_3: 'Sledećih 3 Strane',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var sr_RS = {
    locale: 'sr',
    Pagination: Pagination$27,
    DatePicker: locale$54,
    TimePicker: locale$55,
    Calendar: CalendarLocale$27,
    Table: {
        filterTitle: 'Filter',
        filterConfirm: 'Primeni filter',
        filterReset: 'Resetuj filter',
        emptyText: 'Nema podataka',
        selectAll: 'Obeleži sve na trenutnoj strani',
        selectInvert: 'Obrni selekciju na trenutnoj stranici',
    },
    Modal: {
        okText: 'U redu',
        cancelText: 'Otkaži',
        justOkText: 'U redu',
    },
    Popconfirm: {
        okText: 'U redu',
        cancelText: 'Otkaži',
    },
    Transfer: {
        notFoundContent: 'Nisu pronađeni rezultati pretrage',
        searchPlaceholder: 'Pretražite ovde',
        itemUnit: 'stavka',
        itemsUnit: 'stavki',
    },
    Select: {
        notFoundContent: 'Nije pronađeno',
    },
    Upload: {
        uploading: 'Slanje...',
        removeFile: 'Ukloni fajl',
        uploadError: 'Greška prilikom slanja',
        previewFile: 'Pogledaj fajl',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$28 = {
    today: 'I dag',
    now: 'Nu',
    backToToday: 'Till idag',
    ok: 'Ok',
    clear: 'Avbryt',
    month: 'Månad',
    year: 'År',
    timeSelect: 'Välj tidpunkt',
    dateSelect: 'Välj datum',
    monthSelect: 'Välj månad',
    yearSelect: 'Välj år',
    decadeSelect: 'Välj årtionde',
    yearFormat: 'YYYY',
    dateFormat: 'YYYY-MM-DD',
    dayFormat: 'D',
    dateTimeFormat: 'YYYY-MM-DD H:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Förra månaden (PageUp)',
    nextMonth: 'Nästa månad (PageDown)',
    previousYear: 'Föreg år (Control + left)',
    nextYear: 'Nästa år (Control + right)',
    previousDecade: 'Föreg årtionde',
    nextDecade: 'Nästa årtionde',
    previousCentury: 'Föreg århundrade',
    nextCentury: 'Nästa århundrade',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$57 = {
    placeholder: 'Välj tid',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$56 = {
    lang: Object.assign({ placeholder: 'Välj datum', rangePlaceholder: ['Startdatum', 'Slutdatum'] }, CalendarLocale$28),
    timePickerLocale: Object.assign({}, locale$57),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$28 = {
    // Options.jsx
    items_per_page: '/ sida',
    jump_to: 'Gå till',
    jump_to_confirm: 'bekräfta',
    page: '',
    // Pagination.jsx
    prev_page: 'Föreg sida',
    next_page: 'Nästa sida',
    prev_5: 'Föreg 5 sidor',
    next_5: 'Nästa 5 sidor',
    prev_3: 'Föreg 3 sidor',
    next_3: 'Nästa 3 sidor',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var sv_SE = {
    locale: 'sv',
    Pagination: Pagination$28,
    DatePicker: locale$56,
    TimePicker: locale$57,
    Calendar: CalendarLocale$28,
    Table: {
        filterTitle: 'Filtermeny',
        filterConfirm: 'OK',
        filterReset: 'Rensa',
        emptyText: 'Ingen information',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Avbryt',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Avbryt',
    },
    Transfer: {
        notFoundContent: 'Info saknas',
        searchPlaceholder: 'Sök',
        itemUnit: 'element',
        itemsUnit: 'element',
    },
    Select: {
        notFoundContent: 'Info saknas',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$29 = {
    today: 'วันนี้',
    now: 'ตอนนี้',
    backToToday: 'กลับไปยังวันนี้',
    ok: 'ตกลง',
    clear: 'ลบล้าง',
    month: 'เดือน',
    year: 'ปี',
    timeSelect: 'เลือกเวลา',
    dateSelect: 'เลือกวัน',
    monthSelect: 'เลือกเดือน',
    yearSelect: 'เลือกปี',
    decadeSelect: 'เลือกทศวรรษ',
    yearFormat: 'YYYY',
    dateFormat: 'D/M/YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D/M/YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'เดือนก่อนหน้า (PageUp)',
    nextMonth: 'เดือนถัดไป (PageDown)',
    previousYear: 'ปีก่อนหน้า (Control + left)',
    nextYear: 'ปีถัดไป (Control + right)',
    previousDecade: 'ทศวรรษก่อนหน้า',
    nextDecade: 'ทศวรรษถัดไป',
    previousCentury: 'ศตวรรษก่อนหน้า',
    nextCentury: 'ศตวรรษถัดไป',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$59 = {
    placeholder: 'เลือกเวลา',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$58 = {
    lang: Object.assign({ placeholder: 'เลือกวันที่', rangePlaceholder: ['วันเริ่มต้น', 'วันสิ้นสุด'] }, CalendarLocale$29),
    timePickerLocale: Object.assign({}, locale$59)
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$29 = {
    // Options.jsx
    items_per_page: '/ หน้า',
    jump_to: 'ไปยัง',
    jump_to_confirm: 'ยืนยัน',
    page: '',
    // Pagination.jsx
    prev_page: 'หน้าก่อนหน้า',
    next_page: 'หน้าถัดไป',
    prev_5: 'ย้อนกลับ 5 หน้า',
    next_5: 'ถัดไป 5 หน้า',
    prev_3: 'ย้อนกลับ 3 หน้า',
    next_3: 'ถัดไป 3 หน้า',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var th_TH = {
    locale: 'th',
    Pagination: Pagination$29,
    DatePicker: locale$58,
    TimePicker: locale$59,
    Calendar: CalendarLocale$29,
    Table: {
        filterTitle: 'ตัวกรอง',
        filterConfirm: 'ยืนยัน',
        filterReset: 'รีเซ็ต',
        emptyText: 'ไม่มีข้อมูล',
        selectAll: 'เลือกทั้งหมดในหน้านี้',
        selectInvert: 'เลือกสถานะตรงกันข้าม',
    },
    Modal: {
        okText: 'ตกลง',
        cancelText: 'ยกเลิก',
        justOkText: 'ตกลง',
    },
    Popconfirm: {
        okText: 'ตกลง',
        cancelText: 'ยกเลิก',
    },
    Transfer: {
        notFoundContent: 'ไม่พบข้อมูล',
        searchPlaceholder: 'ค้นหา',
        itemUnit: 'ชิ้น',
        itemsUnit: 'ชิ้น',
    },
    Select: {
        notFoundContent: 'ไม่พบข้อมูล',
    },
    Upload: {
        uploading: 'กำลังอัปโหลด...',
        removeFile: 'ลบไฟล์',
        uploadError: 'เกิดข้อผิดพลาดในการอัปโหลด',
        previewFile: 'ดูตัวอย่างไฟล์',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$61 = {
    placeholder: 'Zaman Seç',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$60 = {
    lang: Object.assign({ placeholder: 'Tarih Seç', rangePlaceholder: ['Başlangıç Tarihi', 'Bitiş Tarihi'] }, CalendarLocale$8),
    timePickerLocale: Object.assign({}, locale$61),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var tr_TR = {
    locale: 'tr',
    Pagination: Pagination$8,
    DatePicker: locale$60,
    TimePicker: locale$61,
    Calendar: CalendarLocale$8,
    Table: {
        filterTitle: 'Menü Filtrele',
        filterConfirm: 'Tamam',
        filterReset: 'Sıfırla',
        emptyText: 'Veri Yok',
        selectAll: 'Hepsini Seç',
        selectInvert: 'Tersini Seç',
    },
    Modal: {
        okText: 'Tamam',
        cancelText: 'İptal',
        justOkText: 'Tamam',
    },
    Popconfirm: {
        okText: 'Tamam',
        cancelText: 'İptal',
    },
    Transfer: {
        notFoundContent: 'Bulunamadı',
        searchPlaceholder: 'Arama',
        itemUnit: 'Öğe',
        itemsUnit: 'Öğeler',
    },
    Select: {
        notFoundContent: 'Bulunamadı',
    },
    Upload: {
        uploading: 'Yükleniyor...',
        removeFile: `Dosyayı kaldır`,
        uploadError: 'Yükleme Hatası',
        previewFile: `Dosyayı Önizle`,
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$30 = {
    today: 'Сьогодні',
    now: 'Зараз',
    backToToday: 'Поточна дата',
    ok: 'Ok',
    clear: 'Очистити',
    month: 'Місяць',
    year: 'Рік',
    timeSelect: 'Обрати час',
    dateSelect: 'Обрати дату',
    monthSelect: 'Обрати місяць',
    yearSelect: 'Обрати рік',
    decadeSelect: 'Обрати десятиріччя',
    yearFormat: 'YYYY',
    dateFormat: 'D-M-YYYY',
    dayFormat: 'D',
    dateTimeFormat: 'D-M-YYYY HH:mm:ss',
    monthBeforeYear: true,
    previousMonth: 'Попередній місяць (PageUp)',
    nextMonth: 'Наступний місяць (PageDown)',
    previousYear: 'Попередній рік (Control + left)',
    nextYear: 'Наступний рік (Control + right)',
    previousDecade: 'Попереднє десятиріччя',
    nextDecade: 'Наступне десятиріччя',
    previousCentury: 'Попереднє століття',
    nextCentury: 'Наступне століття',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$63 = {
    placeholder: 'Оберіть час',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$62 = {
    lang: Object.assign({ placeholder: 'Оберіть дату', rangePlaceholder: ['Початкова дата', 'Кінцева дата'] }, CalendarLocale$30),
    timePickerLocale: Object.assign({}, locale$63),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$30 = {
    // Options.jsx
    items_per_page: '/ сторінці',
    jump_to: 'Перейти',
    jump_to_confirm: 'підтвердити',
    page: '',
    // Pagination.jsx
    prev_page: 'Попередня сторінка',
    next_page: 'Наступна сторінка',
    prev_5: 'Попередні 5 сторінок',
    next_5: 'Наступні 5 сторінок',
    prev_3: 'Попередні 3 сторінки',
    next_3: 'Наступні 3 сторінки',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var uk_UA = {
    locale: 'uk',
    Pagination: Pagination$30,
    DatePicker: locale$62,
    TimePicker: locale$63,
    Calendar: CalendarLocale$30,
    Table: {
        filterTitle: 'Фільтрувати',
        filterConfirm: 'OK',
        filterReset: 'Скинути',
        emptyText: 'Даних немає',
        selectAll: 'Обрати всі',
        selectInvert: 'Інвертувати вибір',
    },
    Modal: {
        okText: 'Гаразд',
        cancelText: 'Скасувати',
        justOkText: 'Гаразд',
    },
    Popconfirm: {
        okText: 'Гаразд',
        cancelText: 'Скасувати',
    },
    Transfer: {
        notFoundContent: 'Нічого не знайдено',
        searchPlaceholder: 'Введіть текст для пошуку',
        itemUnit: 'item',
        itemsUnit: 'items',
    },
    Select: {
        notFoundContent: 'Нічого не знайдено',
    },
    Upload: {
        uploading: 'Завантаження ...',
        removeFile: 'Видалити файл',
        uploadError: 'Помилка завантаження',
        previewFile: 'Попередній перегляд файлу',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Merge into a locale object
const locale$64 = {
    lang: Object.assign({ placeholder: 'Chọn thời điểm', rangePlaceholder: ['Ngày bắt đầu', 'Ngày kết thúc'] }, CalendarLocale$8),
    timePickerLocale: Object.assign({}, locale$17),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$31 = {
    // Options.jsx
    items_per_page: '/ trang',
    jump_to: 'Đến',
    jump_to_confirm: 'xác nhận',
    page: '',
    // Pagination.jsx
    prev_page: 'Trang Trước',
    next_page: 'Trang Kế',
    prev_5: 'Về 5 Trang Trước',
    next_5: 'Đến 5 Trang Kế',
    prev_3: 'Về 3 Trang Trước',
    next_3: 'Đến 3 Trang Kế',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$65 = {
    placeholder: 'Chọn thời gian',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var vi_VN = {
    locale: 'vi',
    Pagination: Pagination$31,
    DatePicker: locale$64,
    TimePicker: locale$65,
    Calendar: locale$64,
    Table: {
        filterTitle: 'Bộ ',
        filterConfirm: 'OK',
        filterReset: 'Tạo Lại',
        emptyText: 'Trống',
        selectAll: 'Chọn Tất Cả',
        selectInvert: 'Chọn Ngược Lại',
    },
    Modal: {
        okText: 'OK',
        cancelText: 'Huỷ',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: 'OK',
        cancelText: 'Huỷ',
    },
    Transfer: {
        notFoundContent: 'Không Tìm Thấy',
        searchPlaceholder: 'Tìm ở đây',
        itemUnit: 'mục',
        itemsUnit: 'mục',
    },
    Select: {
        notFoundContent: 'Không Tìm Thấy',
    },
    Upload: {
        uploading: 'Đang tải lên...',
        removeFile: 'Gỡ bỏ tập tin',
        uploadError: 'Lỗi tải lên',
        previewFile: 'Xem thử tập tin',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarLocale$31 = {
    today: '今天',
    now: '此刻',
    backToToday: '返回今天',
    ok: '確定',
    timeSelect: '選擇時間',
    dateSelect: '選擇日期',
    clear: '清除',
    month: '月',
    year: '年',
    previousMonth: '上個月 (翻頁上鍵)',
    nextMonth: '下個月 (翻頁下鍵)',
    monthSelect: '選擇月份',
    yearSelect: '選擇年份',
    decadeSelect: '選擇年代',
    yearFormat: 'YYYY年',
    dayFormat: 'D日',
    dateFormat: 'YYYY年M月D日',
    dateTimeFormat: 'YYYY年M月D日 HH時mm分ss秒',
    previousYear: '上一年 (Control鍵加左方向鍵)',
    nextYear: '下一年 (Control鍵加右方向鍵)',
    previousDecade: '上一年代',
    nextDecade: '下一年代',
    previousCentury: '上一世紀',
    nextCentury: '下一世紀',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$67 = {
    placeholder: '請選擇時間',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const locale$66 = {
    lang: Object.assign({ placeholder: '請選擇日期', rangePlaceholder: ['開始日期', '結束日期'] }, CalendarLocale$31),
    timePickerLocale: Object.assign({}, locale$67),
};
locale$66.lang.ok = '確 定';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Pagination$32 = {
    // Options.jsx
    items_per_page: '條/頁',
    jump_to: '跳至',
    jump_to_confirm: '確定',
    page: '頁',
    // Pagination.jsx
    prev_page: '上一頁',
    next_page: '下一頁',
    prev_5: '向前 5 頁',
    next_5: '向後 5 頁',
    prev_3: '向前 3 頁',
    next_3: '向後 3 頁',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var zh_TW = {
    locale: 'zh-tw',
    Pagination: Pagination$32,
    DatePicker: locale$66,
    TimePicker: locale$67,
    Calendar: CalendarLocale$31,
    Table: {
        filterTitle: '篩選器',
        filterConfirm: '確 定',
        filterReset: '重 置',
        emptyText: '目前尚無資料',
        selectAll: '全部選取',
        selectInvert: '反向選取',
    },
    Modal: {
        okText: '確 定',
        cancelText: '取 消',
        justOkText: 'OK',
    },
    Popconfirm: {
        okText: '確 定',
        cancelText: '取 消',
    },
    Transfer: {
        notFoundContent: '查無此資料',
        searchPlaceholder: '搜尋資料',
        itemUnit: '項目',
        itemsUnit: '項目',
    },
    Select: {
        notFoundContent: '查無此資料',
    },
    Upload: {
        uploading: '正在上傳...',
        removeFile: '刪除檔案',
        uploadError: '上傳失敗',
        previewFile: '檔案預覽',
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgZorroAntdModule {
    /**
     * @deprecated Use `NgZorroAntdModule` instead.
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgZorroAntdModule
        };
    }
}
NgZorroAntdModule.decorators = [
    { type: NgModule, args: [{
                exports: [
                    NzButtonModule,
                    NzCalendarModule,
                    NzGridModule,
                    NzSwitchModule,
                    NzSelectModule,
                    NzMenuModule,
                    NzMentionModule,
                    NzAnchorModule,
                    NzAffixModule,
                    NzDropDownModule,
                    NzLayoutModule,
                    NzBreadCrumbModule,
                    NzPaginationModule,
                    NzStepsModule,
                    NzInputModule,
                    NzCheckboxModule,
                    NzInputNumberModule,
                    NzSliderModule,
                    NzRateModule,
                    NzBadgeModule,
                    NzRadioModule,
                    NzAlertModule,
                    NzSpinModule,
                    NzProgressModule,
                    NzTabsModule,
                    NzCardModule,
                    NzAvatarModule,
                    NzTimelineModule,
                    NzTimePickerModule,
                    NzTransferModule,
                    NzCarouselModule,
                    NzCollapseModule,
                    NzTableModule,
                    NzDatePickerModule,
                    NzDividerModule,
                    NzFormModule,
                    NzListModule,
                    NzI18nModule,
                    NzUploadModule,
                    NzAutocompleteModule,
                    NzTagModule,
                    NzMessageModule,
                    NzNotificationModule,
                    NzPopoverModule,
                    NzToolTipModule,
                    NzPopconfirmModule,
                    NzModalModule,
                    NzBackTopModule,
                    NzCascaderModule,
                    NzTreeModule,
                    NzTreeSelectModule,
                    NzTimePickerModule
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NgZorroAntdModule, NzAffixComponent, NzAffixModule, NzAlertComponent, NzAlertModule, NzAnchorLinkComponent, NzAnchorComponent, NzAnchorModule, NzAvatarComponent, NzAvatarModule, NzBackTopComponent, NzBackTopModule, NzBadgeComponent, NzBadgeModule, NzBreadCrumbItemComponent, NzBreadCrumbComponent, NzBreadCrumbModule, NzButtonComponent, NzButtonGroupComponent, NzButtonModule, NzCalendarComponent, NzCalendarModule, NzCardGridDirective, NzCardComponent, NzCardModule, NzCardLoadingComponent, NzCardMetaComponent, NzCardTabComponent, NzCarouselModule, NzCarouselComponent, NzCarouselContentDirective, NzCheckboxComponent, NzCheckboxModule, NzCheckboxGroupComponent, NzCheckboxWrapperComponent, NzCollapsePanelComponent, NzCollapseComponent, NzCollapseModule, CandyDate, NzDatePickerModule, NzDatePickerComponent, NzRangePickerComponent, NzMonthPickerComponent, NzWeekPickerComponent, NzDividerComponent, NzDividerModule, NzDropdownContextComponent, NzDropDownComponent, NzDropDownDirective, NzDropdownService, NzDropDownButtonComponent, NzDropDownModule, NzFormModule, NzFormDirective, NzFormControlComponent, NzFormExplainComponent, NzFormItemComponent, NzFormExtraComponent, NzFormLabelComponent, NzFormSplitComponent, NzFormTextComponent, NzRowDirective, NzRowComponent, NzColComponent, NzColDirective, NzGridModule, NzI18nModule, NZ_I18N, NzI18nService, ar_EG, bg_BG, ca_ES, cs_CZ, de_DE, el_GR, en_GB, en_US, es_ES, et_EE, fa_IR, fi_FI, fr_BE, fr_FR, is_IS, it_IT, ja_JP, ko_KR, nb_NO, nl_BE, nl_NL, pl_PL, pt_BR, pt_PT, ru_RU, sk_SK, sr_RS, sv_SE, th_TH, tr_TR, uk_UA, vi_VN, zh_CN, zh_TW, NzInputGroupComponent, NzInputModule, NzInputNumberComponent, NzInputNumberModule, NzContentComponent, NzFooterComponent, NzHeaderComponent, NzLayoutComponent, NzSiderComponent, NzLayoutModule, NzListItemMetaComponent, NzListItemComponent, NzListComponent, NzListModule, NzMentionModule, NzMentionComponent, NZ_MENTION_TRIGGER_ACCESSOR, NzMentionTriggerDirective, NzMenuDirective, NzMenuGroupComponent, NzMenuDividerDirective, NzMenuItemDirective, NzSubMenuComponent, NzMenuModule, NzPaginationComponent, NzPaginationModule, NzProgressModule, NzProgressComponent, NzRadioButtonComponent, NzRadioGroupComponent, NzRadioComponent, NzRadioModule, NzRateComponent, NzRateModule, NzOptionGroupComponent, NzOptionContainerComponent, NzOptionComponent, NzSelectComponent, NzSelectModule, NzSpinComponent, NzSpinModule, NzStepsComponent, NzStepComponent, NzStepsModule, NzSwitchComponent, NzSwitchModule, NzTableComponent, NzTableModule, NzTbodyDirective, NzTdComponent, NzThComponent, NzTheadComponent, NzTrDirective, NzTabBodyComponent, NzTabLabelDirective, NzTabComponent, NzTabsInkBarDirective, NzTabsModule, NzTabsNavComponent, NzTabChangeEvent, NzTabSetComponent, NzTimelineItemComponent, NzTimelineComponent, NzTimelineModule, NzTransferListComponent, NzTransferSearchComponent, NzTransferComponent, NzTransferModule, NzUploadBtnComponent, NzUploadListComponent, NzUploadComponent, NzUploadModule, NzTagComponent, NzTagModule, NzAutocompleteModule, NzAutocompleteComponent, NZ_AUTOCOMPLETE_VALUE_ACCESSOR, getNzAutocompleteMissingPanelError, NzAutocompleteTriggerDirective, NzOptionSelectionChange, NzAutocompleteOptionComponent, NzAutocompleteOptgroupComponent, NzMessageBaseService, NzMessageService, NzMessageModule, NzMessageComponent, NzMessageContainerComponent, NZ_MESSAGE_DEFAULT_CONFIG, NZ_MESSAGE_CONFIG, NZ_MESSAGE_DEFAULT_CONFIG_PROVIDER, NzTimePickerComponent, NzTimePickerModule, NzToolTipComponent, NzTooltipDirective, NzToolTipModule, SliderHandle, NzSliderComponent, NzSliderModule, NzSliderService, NzSliderHandleComponent, NzSliderMarksComponent, Marks, MarksArray, NzSliderStepComponent, NzSliderTrackComponent, NzPopoverComponent, NzPopoverDirective, NzPopoverModule, NZ_NOTIFICATION_DEFAULT_CONFIG, NZ_NOTIFICATION_CONFIG, NZ_NOTIFICATION_DEFAULT_CONFIG_PROVIDER, NzNotificationComponent, NzNotificationModule, NzNotificationService, NzNotificationContainerComponent, NzPopconfirmComponent, NzPopconfirmDirective, NzPopconfirmModule, NzModalComponent, NzModalRef, NzModalModule, NzModalService, NzCascaderModule, NzCascaderComponent, NzTreeComponent, NzTreeNodeComponent, NzTreeNode, NzTreeService, NzTreeModule, NzTreeSelectComponent, NzTreeSelectModule, NzAffixComponent as ɵco, NzAffixModule as ɵcn, NzAlertComponent as ɵeg, NzAlertModule as ɵef, NzAnchorLinkComponent as ɵcm, NzAnchorComponent as ɵci, NzAnchorModule as ɵch, NzAutocompleteOptgroupComponent as ɵhu, NzAutocompleteOptionComponent as ɵhr, NZ_AUTOCOMPLETE_VALUE_ACCESSOR as ɵhs, NzAutocompleteTriggerDirective as ɵht, NzAutocompleteComponent as ɵhq, NzAutocompleteModule as ɵhp, NzAvatarComponent as ɵez, NzAvatarModule as ɵey, NzBackTopComponent as ɵjb, NzBackTopModule as ɵja, NzBadgeComponent as ɵee, NzBadgeModule as ɵed, NzBreadCrumbItemComponent as ɵdb, NzBreadCrumbComponent as ɵda, NzBreadCrumbModule as ɵcz, NzButtonGroupComponent as ɵd, NzButtonComponent as ɵb, NzButtonModule as ɵa, NzDateCellDirective as ɵq, NzDateFullCellDirective as ɵs, NzMonthCellDirective as ɵr, NzMonthFullCellDirective as ɵt, NzCalendarHeaderComponent as ɵf, NzCalendarComponent as ɵp, NzCalendarModule as ɵe, NzCardGridDirective as ɵev, NzCardLoadingComponent as ɵex, NzCardMetaComponent as ɵew, NzCardTabComponent as ɵeu, NzCardComponent as ɵet, NzCardModule as ɵes, NzCarouselContentDirective as ɵfn, NzCarouselComponent as ɵfm, NzCarouselModule as ɵfl, NzCascaderComponent as ɵjd, NzCascaderModule as ɵjc, NzCheckboxGroupComponent as ɵdn, NzCheckboxWrapperComponent as ɵdm, NzCheckboxComponent as ɵdl, NzCheckboxModule as ɵdk, NzCollapsePanelComponent as ɵfp, NzCollapseComponent as ɵfq, NzCollapseModule as ɵfo, dropDownAnimation as ɵbx, fadeAnimation as ɵdz, selectDropDownAnimation as ɵjk, selectTagAnimation as ɵjl, NzScrollService as ɵcj, SCROLL_SERVICE_PROVIDER as ɵcl, SCROLL_SERVICE_PROVIDER_FACTORY as ɵck, NzMatchMediaService as ɵcy, NzMeasureScrollbarService as ɵfu, NzUpdateHostClassService as ɵc, InputBoolean as ɵgr, LoggerModule as ɵv, LOGGER_SERVICE_PROVIDER as ɵo, LOGGER_SERVICE_PROVIDER_FACTORY as ɵn, LoggerService as ɵl, NZ_LOGGER_STATE as ɵm, throttleByAnimationFrameDecorator as ɵcp, AbstractPickerComponent as ɵgq, NzDatePickerComponent as ɵgo, NzDatePickerModule as ɵfz, DateRangePickerComponent as ɵgp, CalendarFooterComponent as ɵgd, CalendarHeaderComponent as ɵgb, CalendarInputComponent as ɵgc, OkButtonComponent as ɵge, TimePickerButtonComponent as ɵgf, TodayButtonComponent as ɵgg, DateTableComponent as ɵgh, DecadePanelComponent as ɵgl, LibPackerModule as ɵga, MonthPanelComponent as ɵgj, MonthTableComponent as ɵgk, DateRangePopupComponent as ɵgn, InnerPopupComponent as ɵgm, YearPanelComponent as ɵgi, NzMonthPickerComponent as ɵgu, NzPickerComponent as ɵgs, NzRangePickerComponent as ɵgt, NzWeekPickerComponent as ɵgv, NzDividerComponent as ɵgx, NzDividerModule as ɵgw, NzDropDownButtonComponent as ɵbz, NzDropdownContextComponent as ɵcr, NzDropDownComponent as ɵbw, NzDropDownDirective as ɵby, NzDropDownModule as ɵcq, NzFormControlComponent as ɵhd, NzFormExplainComponent as ɵhe, NzFormExtraComponent as ɵgz, NzFormItemComponent as ɵhc, NzFormLabelComponent as ɵha, NzFormSplitComponent as ɵhg, NzFormTextComponent as ɵhf, NzFormDirective as ɵhb, NzFormModule as ɵgy, NzColComponent as ɵbo, NzColDirective as ɵbn, NzGridModule as ɵbl, NzRowComponent as ɵbm, NzRowDirective as ɵbp, NzI18nModule as ɵu, NzI18nPipe as ɵw, NZ_I18N_SERVICE_PROVIDER as ɵi, NZ_LOCALE_SERVICE_PROVIDER_FACTORY as ɵh, NzI18nService as ɵg, NZ_I18N as ɵj, NzInputNumberComponent as ɵdp, NzInputNumberModule as ɵdo, NzInputGroupComponent as ɵdj, NzInputDirective as ɵdi, NzInputModule as ɵdh, NzContentComponent as ɵcv, NzFooterComponent as ɵcw, NzHeaderComponent as ɵcu, NzLayoutComponent as ɵct, NzLayoutModule as ɵcs, NzSiderComponent as ɵcx, NzListItemMetaComponent as ɵhk, NzListItemComponent as ɵhj, NzListComponent as ɵhi, NzListModule as ɵhh, NzMentionSuggestionDirective as ɵcg, NZ_MENTION_TRIGGER_ACCESSOR as ɵce, NzMentionTriggerDirective as ɵcf, NzMentionComponent as ɵcd, NzMentionModule as ɵcc, NzMenuDividerDirective as ɵca, NzMenuGroupComponent as ɵcb, NzMenuItemDirective as ɵbu, NzMenuDirective as ɵbt, NzMenuModule as ɵbs, NzSubMenuComponent as ɵbv, NZ_MESSAGE_CONFIG as ɵib, NZ_MESSAGE_DEFAULT_CONFIG as ɵia, NZ_MESSAGE_DEFAULT_CONFIG_PROVIDER as ɵic, NzMessageContainerComponent as ɵhy, NzMessageComponent as ɵid, NzMessageModule as ɵhx, NzMessageBaseService as ɵie, NzMessageService as ɵif, CssUnitPipe as ɵiy, NzModalControlService as ɵix, NzModalRef as ɵiw, NzModalComponent as ɵiv, NzModalModule as ɵiu, NzModalService as ɵiz, NZ_NOTIFICATION_CONFIG as ɵil, NZ_NOTIFICATION_DEFAULT_CONFIG as ɵik, NZ_NOTIFICATION_DEFAULT_CONFIG_PROVIDER as ɵim, NzNotificationContainerComponent as ɵii, NzNotificationComponent as ɵih, NzNotificationModule as ɵig, NzNotificationService as ɵin, NzPaginationComponent as ɵdd, NzPaginationModule as ɵdc, NzPopconfirmComponent as ɵis, NzPopconfirmDirective as ɵit, NzPopconfirmModule as ɵir, NzPopoverComponent as ɵip, NzPopoverDirective as ɵiq, NzPopoverModule as ɵio, NzProgressComponent as ɵek, NzProgressModule as ɵej, NzRadioButtonComponent as ɵba, NzRadioGroupComponent as ɵz, NzRadioComponent as ɵy, NzRadioModule as ɵx, NzRateComponent as ɵec, NzRateModule as ɵeb, NzOptionContainerComponent as ɵbh, NzOptionGroupComponent as ɵbj, NzOptionLiComponent as ɵbi, NzOptionComponent as ɵbe, NzOptionPipe as ɵbc, NzSubOptionPipe as ɵbd, NzSelectTopControlComponent as ɵbg, NzSelectUnselectableDirective as ɵbk, NzSelectComponent as ɵbf, NzSelectModule as ɵbb, NzSliderHandleComponent as ɵdu, NzSliderMarksComponent as ɵdw, NzSliderStepComponent as ɵdv, NzSliderTrackComponent as ɵdt, NzSliderComponent as ɵdr, NzSliderModule as ɵdq, NzSliderService as ɵds, NzSpinComponent as ɵei, NzSpinModule as ɵeh, NzStepComponent as ɵdg, NzStepsComponent as ɵdf, NzStepsModule as ɵde, NzSwitchComponent as ɵbr, NzSwitchModule as ɵbq, NzTableComponent as ɵfs, NzTableModule as ɵfr, NzTbodyDirective as ɵfx, NzTdComponent as ɵfv, NzThComponent as ɵft, NzTheadComponent as ɵfw, NzTrDirective as ɵfy, NzTabBodyComponent as ɵer, NzTabLabelDirective as ɵep, NzTabComponent as ɵem, NzTabsInkBarDirective as ɵeq, NzTabsNavComponent as ɵeo, NzTabsModule as ɵel, NzTabSetComponent as ɵen, NzTagComponent as ɵhw, NzTagModule as ɵhv, NzTimePickerPanelComponent as ɵff, NzTimePickerComponent as ɵfe, NzTimePickerModule as ɵfd, NzTimeValueAccessorDirective as ɵfg, NzTimelineItemComponent as ɵfb, NzTimelineComponent as ɵfc, NzTimelineModule as ɵfa, NzToolTipComponent as ɵdy, NzTooltipDirective as ɵea, NzToolTipModule as ɵdx, NzTransferListComponent as ɵfj, NzTransferSearchComponent as ɵfk, NzTransferComponent as ɵfi, NzTransferModule as ɵfh, NzTreeSelectComponent as ɵjj, NzTreeSelectModule as ɵji, NzTreeNodeComponent as ɵjh, NzTreeComponent as ɵjf, NzTreeModule as ɵje, NzTreeService as ɵjg, NzUploadBtnComponent as ɵhn, NzUploadListComponent as ɵho, NzUploadComponent as ɵhm, NzUploadModule as ɵhl };
//# sourceMappingURL=antd.js.map
